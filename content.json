{"meta":{"title":"bomo的开发随笔","subtitle":"记录工作学习点滴","description":"懒人","author":"bomo","url":"http://zhengbomo.github.io","root":"/"},"pages":[{"title":"","date":"2023-06-11T03:02:51.855Z","updated":"2023-06-11T03:02:51.855Z","comments":true,"path":"404.html","permalink":"http://zhengbomo.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2016-04-18T14:15:00.000Z","updated":"2023-06-11T03:02:51.870Z","comments":false,"path":"about/index.html","permalink":"http://zhengbomo.github.io/about/index.html","excerpt":"","text":"简介好的习惯是成功一半 链接 Github"},{"title":"我的简历","date":"2017-05-13T16:06:30.000Z","updated":"2019-06-02T13:24:00.000Z","comments":false,"path":"about/resume.html","permalink":"http://zhengbomo.github.io/about/resume.html","excerpt":"","text":"联系方式 手机：18102620462 Email：&#122;&#104;&#x65;&#110;&#103;&#98;&#x6f;&#x6d;&#x6f;&#64;&#104;&#111;&#116;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#109; QQ&#x2F;微信号：449179249&#x2F;bomo00 个人信息 郑贤凯&#x2F;男&#x2F;1992 本科&#x2F;东莞理工学院-信息与计算科学 工作年限：5年 技术博客：https://blog.bombox.org github：http://github.com/zhengbomo 期望职位：iOS高级工程师 期望城市：广州 自我描述 有扎实的iOS 开发开发调试及重构经验，能主导一个新项目的框架设计及具体实现，有一定的风险把控能力 对多线程，block，runtime，runloop有深刻的理解 熟悉苹果支付，第三方支付，代码混淆，马甲包处理 熟悉 Instrument 调试工具解决和优化内存和性能问题 掌握 MonkeyDev, Theos, Tweak等逆向套路 掌握 Frida 动态调试，class-dump, Reveal, Hopper, IDA等逆向分析 熟悉 .NET 平台的开发，做过 WindowsPhone，Windows 平台开发 掌握 ReactNative 开发，掌握 Flutter 开发 熟悉 Python，写过爬虫，工具链 有良好的编程⻛格和习惯，对代码有追求，有强迫症 良好的英文阅读能力，关注新工具，新技术，热爱讨论与分享 自我评价责任心, 执行力, 抗压能力, 自驱动, 协调沟通能力 对技术饱含热情，对代码有强迫症，有较强的学习能力和探索精神，思维严谨，喜欢简单，不喜欢重复，喜欢工具做事，高效率做事，喜欢交流和分享，想做事，能担当，能抗事 工作经历浙江星飞信息技术有限公司(广州分公司) （ 2018年01月 ~ 至今 ）标签SDK, 马甲包, 逆向, 内购, 混淆, Swift, 工具 游多多iOS上半年负责游多多iOS端的开发，后来因为公司层面原因，被暂停 独立负责项目搭建，使用swift开发 集成第三方支付，第三方登录 URL路由设计 业务组件化设计与实现 UI自动化测试（Jenkins+WebDriver+Appium+Python） iOS 渠道追踪（类似openinstall） 无入侵埋点设计 启动时长优化，性能优化 单元测试，自动打包，持续集成 业务中台支撑201806-至今在业务中台负责业务支撑，不同于App开发，负责的事情比较多，主要有下面几块 负责iOS游戏出包，负责游戏出包，签名，马甲包过包策略和技术跟进 渠道聚合SDK开发，已接入70+个渠道，用于不同渠道分包，类似于QuickSDK，支持直接通过ipa进行渠道分包 iOS聚合广告SDK，已接入6个广告平台，用于集成多个广告平台，动态配置平台和参数 负责马甲包（Unity和Cocos2d）的过包处理，代码混淆，资源混淆 负责H5小游戏（Cordova）的提审工作 负责出包工具的开发，基于动态库实现自动分包，自动打包（类似quickSDK） 负责统计SDK的维护，对接数据中心（类似友盟） 分析和排查崩溃问题 为马甲包，企业签业务编写各种配套辅助工具 深圳新思维教育科技有限公司（广州）（ 2017年6月 ~ 2017年11月 ）标签Objective-C, iOS, SDWebImage, RactiveCocoa, FMDB, 分享, 规范 泡单词在职期间负责项目重构， 疑难问题解决，持续集成，代码规范，技术分享推行等工作 负责项目重构（网络层，数据库）重构，分离业务和数据 负责下载模块的设计与重构，基于SDWebImage，实现文件分组下载（通过闭包管理状态） 负责规范项目，规范代码，解决代码不规范带来的内存泄露，性能低下等问题 北京快乐茄信息技术有限公司（ 2015年12月 ~ 2017年04月 ）标签Objective-C, Socket, WebSocket, HTTP, FFMpeg, UWP, WindowsPhone, 分享, 架构, ReactiveCocoa 在职期间主要负责茄子快传Windows端的开发，茄子快传iOS端的疑难问题解决，和主导TickTalk项目开发，负责项目架构，疑难问题，项目规范等工作 茄子快传茄子快传是一个基于局域网的端对端传输App，有10亿用户，主要面向双印市场，是公司的主要产品 负责茄子快传Windows平台的开发（WindowsPhone, WindowsStore, WPF） 负责茄子快传iOS平台的功能迭代（实现ffmpeg视频播放，广告流） 基于socket实现http协议基础功能（苹果限制了http的接口访问，用于局域网传输） TickTalkTickTalk是一个陌生人社交应用，通过兴趣推荐用户，iOS端开发人员4人，我作为技术负责人，产品定位类似于陌陌，主要面向双印市场，后来没有推广起来被暂停 负责项目搭建，项目架构，技术选型 负责项目进度，项目分工 负责项通信模块底层设计与开发（数据层，包括通信，数据库，对外接口），底层基于WebSocket协议 负责技术难点的解决 负责部分基础组件和通信数据组件的维护（SDK），业务层面向SDK进行开发 负责单元测试的编写与推行，主要用于通信模块的稳定性测试和性能测试，主要针对IM模块 北京易动分享科技有限公司（ 2015年04月 ~ 2015年12月 ）标签iOS, UITableView, sqlite, FMDB, CRM 纷享销客iOS纷享逍客是一个面相企业的信息系统，包含企业微信，工作信息流，考勤，工作报告，CRM等企业管理系统，在职期间主要负责业务相关模块的开发，竞品为阿里钉钉，在职期间主要负责模块开发 工作信息流模块的开发，类似于网易新闻的header和信息流 企业通讯录模块的开发，包含部门层级结构展现（面包屑：类似目录结构），选人控件的开发，通讯录模块是一个基础模块，被其他所有的模块使用 员工资料模块的开发，主要是信息展示 参与设计和完成数据库升级框架，数据库优化与加密 参与开发CRM模块的开发 &amp;nbsp; 广州超级周末科技有限公司（2015-04之前）独立负责《超级课程表》WindowsPhone平台的开发 课表模块，主要是UI交互 社区模块，信息流页面 IM模块（实现C#版本的gopush协议） 技能清单以下均为我熟练使用的技能 iOS开发：Swift &#x2F; Objective-C &#x2F; C++ Windows平台：C# &#x2F; WPF &#x2F; .NET Web框架：python &#x2F; flask 跨平台框架：dart &#x2F; flutter 数据库相关：MySQL &#x2F; SQLite 版本管理、文档和自动化部署工具：svn &#x2F; git 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。"},{"title":"categories","date":"2016-04-28T09:32:38.000Z","updated":"2023-06-11T03:02:51.870Z","comments":false,"path":"categories/index.html","permalink":"http://zhengbomo.github.io/categories/index.html","excerpt":"","text":""},{"title":"iOS技术支持","date":"2023-04-24T14:15:00.000Z","updated":"2023-04-24T14:15:00.000Z","comments":false,"path":"apps/app_support.html","permalink":"http://zhengbomo.github.io/apps/app_support.html","excerpt":"","text":"iOS&#x2F;MacOS技术支持网址: 关于《新标准日本语》《大家的日语》app有问题的可以留言。 邮箱地址: &#119;&#x65;&#x6e;&#119;&#x65;&#105;&#x6a;&#117;&#97;&#x6e;&#64;&#104;&#111;&#x74;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#109;"},{"title":"iOS技术支持","date":"2023-04-24T14:15:00.000Z","updated":"2023-04-24T14:15:00.000Z","comments":false,"path":"apps/bomo_app_support.html","permalink":"http://zhengbomo.github.io/apps/bomo_app_support.html","excerpt":"","text":"iOS&#x2F;MacOS技术支持网址: 关于《休息一下》《BuildReport for Xcode》app有问题的可以留言。 邮箱地址: &#x7a;&#x68;&#x65;&#x6e;&#x67;&#98;&#x6f;&#x6d;&#x6f;&#64;&#104;&#x6f;&#x74;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;"},{"title":"tags","date":"2016-04-28T09:22:31.000Z","updated":"2023-06-11T03:02:52.105Z","comments":false,"path":"tags/index.html","permalink":"http://zhengbomo.github.io/tags/index.html","excerpt":"","text":""},{"title":"iOS技术支持","date":"2023-04-14T14:15:00.000Z","updated":"2023-04-14T14:15:00.000Z","comments":false,"path":"apps/jlpt_support.html","permalink":"http://zhengbomo.github.io/apps/jlpt_support.html","excerpt":"","text":"JLPT Ninja 技术支持 关于自动续期订阅服务请您在购买前仔细阅读本协议，当您成为自动付费会员用户时视为您已充分理解并同意如下使用规则: 本服务是在您已购买订阅会员的前提下，为您提供的自动续费服务。如您开通订阅会员，则视为您授权JLPT Ninja有权在您的会员服务即将到期时，从您的iTunes账户（以下统称“账户”）余额中代扣下一个计费周期服务费，该服务的周期为一年。该服务实现的前提是可成功从上述账户中扣款，因上述账户中可扣款余额不足导致的续费失败，由您自行承担。 购买自动续费服务的账号，会在到期前24小时，自动续订并扣除相应费用以及延长您的会员有效期。如需取消自动续订，请至少提前24小时操作取消。苹果手机“设置” –&gt; 进入“iTunes Store 与 App Store”–&gt;点击 “Apple ID”，选择”查看Apple ID”，进入”账户设置”页面，点击“订阅”，选择JLPT Ninja取消订阅即可。 联系作者关于《JLPT Ninja》app有问题的可以联系下面邮箱 邮箱地址: &#106;&#108;&#x70;&#x74;&#110;&#105;&#x6e;&#x6a;&#97;&#x40;&#x68;&#111;&#116;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;"},{"title":"APP技术支持","date":"2023-04-14T14:15:00.000Z","updated":"2023-04-14T14:15:00.000Z","comments":false,"path":"apps/nhg_support.html","permalink":"http://zhengbomo.github.io/apps/nhg_support.html","excerpt":"","text":"iOS&#x2F;MacOS技术支持 关于《新标准日本语》《大家的日语》app有问题的可以留言。 邮箱地址: &#119;&#x65;&#x6e;&#x77;&#101;&#x69;&#x6a;&#x75;&#x61;&#x6e;&#64;&#104;&#x6f;&#x74;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;"},{"title":"APP隐私政策","date":"2023-04-14T14:15:00.000Z","updated":"2023-04-14T14:15:00.000Z","comments":false,"path":"apps/privacy_policy.html","permalink":"http://zhengbomo.github.io/apps/privacy_policy.html","excerpt":"","text":"隐私政策本应用尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，本应用会按照本隐私权政策的规定使用和披露您的个人信息。但本应用将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，本应用不会将这些信息对外披露或向第三方提供。本应用会不时更新本隐私权政策。 您在同意本应用服务使用协议之时，即视为您已经同意本隐私权政策全部内容。本隐私权政策属于本应用服务使用协议不可分割的一部分。 1. 适用范围(a) 在您注册本应用帐号时，您根据本应用要求提供的个人注册信息；(b) 在您使用本应用网络服务，或访问本应用平台网页时，本应用自动接收并记录的您的浏览器和计算机上的信息，包括但不限于您的IP地址、浏览器的类型、使用的语言、访问日期和时间、软硬件特征信息及您需求的网页记录等数据；(c) 本应用通过合法途径从商业伙伴处取得的用户个人数据。您了解并同意，以下信息不适用本隐私权政策：(a) 您在使用本应用平台提供的搜索服务时输入的关键字信息；(b) 本应用收集到的您在本应用发布的有关信息数据，包括但不限于参与活动、成交信息及评价详情；(c) 违反法律规定或违反本应用规则行为及本应用已对您采取的措施。 2. 信息使用(a)本应用不会向任何无关第三方提供、出售、出租、分享或交易您的个人信息，除非事先得到您的许可，或该第三方和本应用（含本应用关联公司）单独或共同为您提供服务，且在该服务结束后，其将被禁止访问包括其以前能够访问的所有这些资料。(b) 本应用亦不允许任何第三方以任何手段收集、编辑、出售或者无偿传播您的个人信息。任何本应用平台用户如从事上述活动，一经发现，本应用有权立即终止与该用户的服务协议。(c) 为服务用户的目的，本应用可能通过使用您的个人信息，向您提供您感兴趣的信息，包括但不限于向您发出产品和服务信息，或者与本应用合作伙伴共享信息以便他们向您发送有关其产品和服务的信息（后者需要您的事先同意）。 3. 信息披露在如下情况下，本应用将依据您的个人意愿或法律的规定全部或部分的披露您的个人信息：(a) 经您事先同意，向第三方披露；(b)为提供您所要求的产品和服务，而必须和第三方分享您的个人信息；(c) 根据法律的有关规定，或者行政或司法机构的要求，向第三方或者行政、司法机构披露；(d) 如您出现违反中国有关法律、法规或者本应用服务协议或相关规则的情况，需要向第三方披露；(e) 如您是适格的知识产权投诉人并已提起投诉，应被投诉人要求，向被投诉人披露，以便双方处理可能的权利纠纷；(f) 在本应用平台上创建的某一交易中，如交易任何一方履行或部分履行了交易义务并提出信息披露请求的，本应用有权决定向该用户提供其交易对方的联络方式等必要信息，以促成交易的完成或纠纷的解决。(g) 其它本应用根据法律、法规或者网站政策认为合适的披露。 4. 信息存储和交换本应用收集的有关您的信息和资料将保存在本应用及（或）其关联公司的服务器上，这些信息和资料可能传送至您所在国家、地区或本应用收集信息和资料所在地的境外并在境外被访问、存储和展示。 5. Cookie的使用(a) 在您未拒绝接受cookies的情况下，本应用会在您的计算机上设定或取用cookies ，以便您能登录或使用依赖于cookies的本应用平台服务或功能。本应用使用cookies可为您提供更加周到的个性化服务，包括推广服务。(b) 您有权选择接受或拒绝接受cookies。您可以通过修改浏览器设置的方式拒绝接受cookies。但如果您选择拒绝接受cookies，则您可能无法登录或使用依赖于cookies的本应用网络服务或功能。(c) 通过本应用所设cookies所取得的有关信息，将适用本政策。 6. 信息安全(a) 本应用帐号均有安全保护功能，请妥善保管您的用户名及密码信息。本应用将通过对用户密码进行加密等安全措施确保您的信息不丢失，不被滥用和变造。尽管有前述安全措施，但同时也请您注意在信息网络上不存在“完善的安全措施”。(b) 在使用本应用网络服务进行网上交易时，您不可避免的要向交易对方或潜在的交易对 7. 本隐私政策的更改(a)如果决定更改隐私政策，我们会在本政策中、本公司网站中以及我们认为适当的位置发布这些更改，以便您了解我们如何收集、使用您的个人信息，哪些人可以访问这些信息，以及在什么情况下我们会透露这些信息。(b)本公司保留随时修改本政策的权利，因此请经常查看。如对本政策作出重大更改，本公司会通过网站通知的形式告知。方披露自己的个人信息，如联络方式或者邮政地址。请您妥善保护自己的个人信息，仅在必要的情形下向他人提供。如您发现自己的个人信息泄密，尤其是本应用用户名及密码发生泄露，请您立即联络本应用客服，以便本应用采取相应措施。"}],"posts":[{"title":"Xcode调试链优化(速度提升50&#37+)","slug":"xcode-build-io-optimize","date":"2021-11-15T06:48:37.000Z","updated":"2021-11-15T06:48:37.000Z","comments":true,"path":"2021-11-15/xcode-build-io-optimize/","link":"","permalink":"http://zhengbomo.github.io/2021-11-15/xcode-build-io-optimize/","excerpt":"Xcode是增量编译的，所以日常开发很多时候，我们都是改少量的代码或不改代码而重复调试，实际使用发现，从工程要跑到手机上调试仍然非常耗时，由于缓存的存在，编译可能不是最耗时的环节了，这里探究和优化影响编译完成到App启动调试速度的因素。","text":"Xcode是增量编译的，所以日常开发很多时候，我们都是改少量的代码或不改代码而重复调试，实际使用发现，从工程要跑到手机上调试仍然非常耗时，由于缓存的存在，编译可能不是最耗时的环节了，这里探究和优化影响编译完成到App启动调试速度的因素。 分析这里只考虑DEBUG包，我们看一张Xcode打包日志细节图 上图选中的为主要耗时的步骤，可以看出，编译成功后，还有下面步骤较为耗时 Linking Embed Pod Frameworks Copy Pods Resources Custom Script（这里为自定义脚本，主要用于资源处理） Sign 还有一个较为耗时的时间是Deploy，但Xcode并不没有输出Deploy的时间，后面使用ideviceinstaller工具单独测试，时间总体上与Xcode基本一致 12345678910# 安装# brew install ideviceinstallerbegin=`date &#x27;+%s&#x27;`# 这里直接拿编译好的app文件安装即可ideviceinstaller -i &#x27;xxx.ipa&#x27;end=`date &#x27;+%s&#x27;`# 计算时间差，单位sexpr $begin - $end 分析 Linking: 合并静态资源与地址修正，考虑使用第三方更快的link工具zld Embed Pod Frameworks: 主要是处理动态库，拷贝到目标路径，主要影响是动态库文件数量 Copy Pods Resources: 主要对文件资源拷贝，主要影响是文件IO Custom Script：这里是自定义脚本，主要是的图片文件的处理，主要是对图片文件进行展开，文件多则文件IO耗时长 Sign：对整个包签名，主要影响是文件数量和大小，文件多则文件IO耗时长 Deploy：主要是拷贝文件和签名校验，主要影响是文件数量，文件多则文件IO耗时长，文件大小影响首次安装，而二次安装会做差异拷贝，有缓存，影响会减小 有上面可以看出，减少IO操作是一个可行的优化方向，项目中的图片资源是放到根目录的，由于项目中用到的图片非常多，直接使用目录管理，并且使用Custom Script脚本单独处理图片，把图片拷贝到包的根目录上，查看xx直播在编译完成后的包，总文件数为9297个, 其中8821个为图片，占95%，文件数量占比大，这意味着每次都要进行大量的IO操作，如果能减少文件的数量，就能减少整个流程的时间 优化关于IO问题对于图片，我们知道除了可以放到根目录，还有可以放到Images.xcassets，放到Images.xcassets的图片最终会被编译成Assets.car，这里考虑把png和jpg图片提前制作成Assets.car，在日常开发迭代过程中，项目中用到的图片不会频繁的变动，这里我们考虑提前把图片做成Assets.car，如果有变动，再重新编译一次，操作步骤如下 如果项目已经存在Images.xcassets，则拷贝一份出来，在它的基础上添加图片 通过工具把所有图片构造成xxx.imageset，放到Images.xcassets里面，如 把bottom_logo@2x.png和bottom_logo@3x.png构造成下面目录结构 1234├── bottom_logo.imageset│ ├── Contents.json│ ├── bottom_logo@2x.png│ └── bottom_logo@3x.png 其中Content.json为 123456789101112131415161718&#123; &quot;images&quot; : [ &#123; &quot;idiom&quot; : &quot;universal&quot;, &quot;filename&quot; : &quot;bottom_logo@2x.png&quot;, &quot;scale&quot; : &quot;2x&quot; &#125;, &#123; &quot;idiom&quot; : &quot;universal&quot;, &quot;filename&quot; : &quot;bottom_logo@3x.png&quot;, &quot;scale&quot; : &quot;3x&quot; &#125; ], &quot;info&quot; : &#123; &quot;version&quot; : 1, &quot;author&quot; : &quot;xcode&quot; &#125;&#125; 使用actool编译Images.xcassets 123456789101112131415161718192021# 输入xcassetPath=&quot;path/to/Images.xcassets&quot;# 输出文件夹outputPath=&quot;path/to/outputpath&quot;dependenciesPath=&quot;path/to/outputpath/dependenciesPath&quot;generatedInfoPath=&quot;path/to/outputpath/generatedInfoPath&quot;/usr/bin/actool \\ --output-format &quot;human-readable-text&quot; \\ --notices \\ --export-dependency-info &quot;$dependenciesPath&quot; \\ --output-partial-info-plist &quot;$generatedInfoPath&quot; \\ --app-icon &quot;AppIcon&quot; \\ --compress-pngs \\ --enable-on-demand-resources &quot;YES&quot; \\ --development-region &quot;English&quot; \\ --target-device &quot;iphone&quot; \\ --minimum-deployment-target &quot;9.0&quot; \\ --platform &quot;iphoneos&quot; \\ --compile &quot;$outputPath&quot; &quot;$xcassetPath&quot; 编译后得到Assets.car 由于Images.xcassets已经编译好了，去掉工程对Images.xcassets的引用，并且把编译好的Assets.car引入工程，上面我们只把jpg/png图片编译进了Assets.car，对于其他文件（不多），这里我通过工具单独引入工程 把Run Script中的图片拷贝去掉，我这里的是去掉Pods-xxx-resources.sh文件中对图片资源的引用 经过上面一番处理后，重新测试，数据对比如下 优化前 优化后 Copy Pod Resources 11s 0.1s（减少97%） Run Custom Script 32.5 0s(减少100%) Sign 4.5 2.5s（减少45%） 从上面的测试结果来看，速度提升效果显著 因为优化后的方案有前置处理时间，需要把编译图片为Assets.car，这个时间没算上，上面的对比仅供参考 需要注意的是，Assets.car的图片只能通过UIImage.named(&quot;xxx&quot;)读取，如果项目中是通过路径 上面的操作过于繁琐，这里我写了一个工具进行处理【一键操作】 关于Linking有一个第三方的linking工具zld，优化的缓存策略，在Other Linker Flag添加-fuse-ld=&#39;/path/to/zld&#39; -Wl,-zld_original_ld_path,$(DT_TOOLCHAIN_DIR)/usr/bin/ld即可 经测试，Linking时间从15s减少到10.1s，减少了32% 关于CodeSign Xcode默认使用SHA-256签名，我们可以改成更快的SHA-1，由于只是本地开发调试使用，不会有安全性问题，在Other Code Signing Flags添加--digest-algorithm=sha1 iOS校验签名只会二进制的签名，其他文件不签名也不会报错，可以通过过滤文件减少签名的文件，在Other Code Signing Flags添加--resource-rules=/path/to/rule.plist，rule.plist文件如下 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;rules&lt;/key&gt; &lt;dict&gt; &lt;key&gt;.*&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt;&lt;/dict&gt;&lt;/plist&gt; 上面处理并不会影响正常开发，通过上面处理编译后的包_CodeSignature/CodeResources文件从2.88 MB减少到589 Byte，减少了99.98%Sign时间从2.2s减少到0.5s，减少了77% 关于Deploy由于APFS的特性，相同的文件不会深拷贝，省去拷贝的时间，由于文件数量大大减少，IO次数也大幅提高，如果不改动文件的话，基本可以达到秒启动，由于Xcode没有输出安装所有的时间，这里使用ideviceinstaller进行测试，这里把优化前后打出来的xxx.app安装到手机上（卸载），测试时间 1234# 安装ideviceinstaller# brew install -HEAD libimobiledeviceideviceinstaller -i xxx.ipa 优化前：40s，优化后：18s，时间减少了55% 综合统计微观统计 优化前 优化后 Linking 15s 10.1s（下降32%） Copy Pod Resources 11s 0.1（减少97%） Run Custom Script 32.5s 0（下降100%)） Sign 2.2s 0.5s（下降77%） Deploy 40s 18s（下降55%） 汇总 100.7s 28.7s（下降71%） 数据来源：Xcode编译日志 宏观统计为了减少编译时间的影响，工程中大多数组件都使用二进制库，数据来源为Xcode编译打包后显示的时间（不包含Deploy和Run），如下 首次 二次（修改代码） 二次（不改代码） 优化前 88.75s 27.4s 9.2s 优化后 37.35s 14.2s 2.2s 对比 减少58% 减少48% 减少76% 测试设备：Mac Mini M1 16G 总结经过一段时间的使用，上面所有操作都是基于对开发效率的提升（for DEBUG），通过一些细节优化，可以把项目入侵降到最小，可以做到提高效率的同时，基本不影响日常开发 市面上大多数App包里面都会带非常多图片资源，图片太多确实会影响调试性能，减少图片数量从而减少IO次数，提升开发体验明显","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"}]},{"title":"xx直播编译优化(减少372.7s)","slug":"fanxing-build-optimize","date":"2021-09-27T09:49:32.000Z","updated":"2021-09-27T09:49:32.000Z","comments":true,"path":"2021-09-27/fanxing-build-optimize/","link":"","permalink":"http://zhengbomo.github.io/2021-09-27/fanxing-build-optimize/","excerpt":"一、背景编译对于开发者可以说是最为频繁的操作，编译速度的快慢会极大的影响我们的开发效率，对于xx直播App来说，由于代码量大，加上代码结构设计不合理等原因，导致编译速度非常慢，每次启动App（即使不改动代码）需要3分钟的时间才能跑在手机上，而一次完整的编译，则需要15分钟，严重影响日常的业务开发和调试，现阶段编译速度的优化显得尤为重要，主要的时间消耗有","text":"一、背景编译对于开发者可以说是最为频繁的操作，编译速度的快慢会极大的影响我们的开发效率，对于xx直播App来说，由于代码量大，加上代码结构设计不合理等原因，导致编译速度非常慢，每次启动App（即使不改动代码）需要3分钟的时间才能跑在手机上，而一次完整的编译，则需要15分钟，严重影响日常的业务开发和调试，现阶段编译速度的优化显得尤为重要，主要的时间消耗有 Compile Linking Run Script Sign Install（文件多可能是主因） 其中Compile时间占用90%以上，这里只关注Compile 二、调研Xcode是基于llvm编译的，llvm编译器的编译过程主要分为3个部分 前端（Frontend）：负责解析源码，检查错误，生成抽象语法树（AST），并把 AST 转化成类汇编中间代码 优化器（Optimizer）：对中间代码进行架构无关的优化，提高运行效率，减少代码体积，例如无效代码，无用变量等 后端（Backend）：把中间代码转换成目标平台的机器码 其中我们代码影响最大的前端，这里我们只关注前端，前端处理主要有 预处理：这阶段的工作主要是 头文件展开处理 宏展开&#x2F;替换，预编译指令处理 注释去除处理 编译：这阶段做的事情比较多 词法分析（Lexical Analysis）：将代码转换成一系列 token 语法分析（Semantic Analysis）：将token树抽象语法树 AST 静态分析（Static Analysis）：检查代码错误，例如参数类型是否错误，调用对象方法是否有实现 中间代码生成（Code Generation）：将语法树自顶向下遍历逐步翻译成 LLVM IR llvm9.0之后添加了一个新的编译参数可以用于统计编译过程中各个阶段的耗时（-ftime-trace），利用该参数和编译器我们可以得到项目中所有文件编译的详细时间信息 2.1 -ftime-trace测试 下载llvm编译器，9.0以上的版本均可，解压后得到clang+llvm-9.0.0，我这里放到（~&#x2F;development&#x2F;clang+llvm-9.0.0） 在需要统计编译时间的Target中修改clang前端编译器（CC和CXX），和编译参数（OtherCFlag） 123CC: /path/to/clangCXX: /path/to/clang++Other C Flag: 添加-ftime-trace 关闭INDEX：COMPILER_INDEX_STORE_ENABLE=NO 编译后，在目标文件（xxx.o）同个目录下，会生成xxx.json文件，如 YYTimer.o YYTimer.json 整个json文件如下 1&#123;&quot;traceEvents&quot;:[&#123;&quot;pid&quot;:1,&quot;tid&quot;:0,&quot;ph&quot;:&quot;X&quot;,&quot;ts&quot;:21778,&quot;dur&quot;:43204,&quot;name&quot;:&quot;Module Load&quot;,&quot;args&quot;:&#123;&quot;detail&quot;:&quot;UIKit&quot;&#125;&#125;,&#123;&quot;pid&quot;:1,&quot;tid&quot;:0,&quot;ph&quot;:&quot;X&quot;,&quot;ts&quot;:21329,&quot;dur&quot;:44253,&quot;name&quot;:&quot;Source&quot;,&quot;args&quot;:&#123;&quot;detail&quot;:&quot;/Users/bomo/Documents/Code/iOS/Work/Analyze/4986-02-header2/FanXing/Pods/Target Support Files/KGThirdParty/KGThirdParty-prefix.pch&quot;&#125;&#125;,&#123;&quot;pid&quot;:1,&quot;tid&quot;:0,&quot;ph&quot;:&quot;X&quot;,&quot;ts&quot;:66818,&quot;dur&quot;:1868,&quot;name&quot;:&quot;Source&quot;,&quot;args&quot;:&#123;&quot;detail&quot;:&quot;/Users/bomo/Documents/Code/iOS/Work/Analyze/4986-02-header2/FanXing/Pods/KGThirdParty/KGThirdParty/YYKit/Utility/YYTimer.h&quot;&#125;&#125;,&#123;&quot;pid&quot;:1,&quot;tid&quot;:0,&quot;ph&quot;:&quot;X&quot;,&quot;ts&quot;:20679,&quot;dur&quot;:70778,&quot;name&quot;:&quot;Frontend&quot;&#125;,&#123;&quot;pid&quot;:1,&quot;tid&quot;:0,&quot;ph&quot;:&quot;X&quot;,&quot;ts&quot;:91457,&quot;dur&quot;:595,&quot;name&quot;:&quot;Frontend&quot;&#125;,&#123;&quot;pid&quot;:1,&quot;tid&quot;:0,&quot;ph&quot;:&quot;X&quot;,&quot;ts&quot;:94811,&quot;dur&quot;:617,&quot;name&quot;:&quot;RunPass&quot;,&quot;args&quot;:&#123;&quot;detail&quot;:&quot;AArch64 Assembly Printer&quot;&#125;&#125;,&#123;&quot;pid&quot;:1,&quot;tid&quot;:0,&quot;ph&quot;:&quot;X&quot;,&quot;ts&quot;:94084,&quot;dur&quot;:1370,&quot;name&quot;:&quot;OptFunction&quot;,&quot;args&quot;:&#123;&quot;detail&quot;:&quot;\\u0001+[YYTimer timerWithTimeInterval:target:selector:repeats:]&quot;&#125;&#125;,&#123;&quot;pid&quot;:1,&quot;tid&quot;:0,&quot;ph&quot;:&quot;X&quot;,&quot;ts&quot;:95456,&quot;dur&quot;:526,&quot;name&quot;:&quot;OptFunction&quot;,&quot;args&quot;:&#123;&quot;detail&quot;:&quot;\\u0001-[YYTimer init]&quot;&#125;&#125;,&#123;&quot;pid&quot;:1,&quot;tid&quot;:0,&quot;ph&quot;:&quot;X&quot;,&quot;ts&quot;:95983,&quot;dur&quot;:1123,&quot;name&quot;:&quot;OptFunction&quot;,&quot;args&quot;:&#123;&quot;detail&quot;:&quot;\\u0001-[YYTimer initWithFireTime:interval:target:selector:repeats:]&quot;&#125;&#125;,&#123;&quot;pid&quot;:1,&quot;tid&quot;:0,&quot;ph&quot;:&quot;X&quot;,&quot;ts&quot;:93022,&quot;dur&quot;:6873,&quot;name&quot;:&quot;OptModule&quot;,&quot;args&quot;:&#123;&quot;detail&quot;:&quot;/Users/bomo/Documents/Code/iOS/Work/Analyze/4986-02-header2/FanXing/Pods/KGThirdParty/KGThirdParty/YYKit/Utility/YYTimer.m&quot;&#125;&#125;,&#123;&quot;pid&quot;:1,&quot;tid&quot;:0,&quot;ph&quot;:&quot;X&quot;,&quot;ts&quot;:93013,&quot;dur&quot;:6977,&quot;name&quot;:&quot;CodeGenPasses&quot;&#125;,&#123;&quot;pid&quot;:1,&quot;tid&quot;:0,&quot;ph&quot;:&quot;X&quot;,&quot;ts&quot;:92061,&quot;dur&quot;:8108,&quot;name&quot;:&quot;Backend&quot;&#125;,&#123;&quot;pid&quot;:1,&quot;tid&quot;:0,&quot;ph&quot;:&quot;X&quot;,&quot;ts&quot;:66,&quot;dur&quot;:100526,&quot;name&quot;:&quot;ExecuteCompiler&quot;&#125;,&#123;&quot;pid&quot;:1,&quot;tid&quot;:1,&quot;ph&quot;:&quot;X&quot;,&quot;ts&quot;:0,&quot;dur&quot;:100526,&quot;name&quot;:&quot;Total ExecuteCompiler&quot;,&quot;args&quot;:&#123;&quot;count&quot;:1,&quot;avg ms&quot;:100&#125;&#125;,&#123;&quot;pid&quot;:1,&quot;tid&quot;:2,&quot;ph&quot;:&quot;X&quot;,&quot;ts&quot;:0,&quot;dur&quot;:71372,&quot;name&quot;:&quot;Total Frontend&quot;,&quot;args&quot;:&#123;&quot;count&quot;:2,&quot;avg ms&quot;:35&#125;&#125;,&#123;&quot;pid&quot;:1,&quot;tid&quot;:3,&quot;ph&quot;:&quot;X&quot;,&quot;ts&quot;:0,&quot;dur&quot;:46121,&quot;name&quot;:&quot;Total Source&quot;,&quot;args&quot;:&#123;&quot;count&quot;:2,&quot;avg ms&quot;:23&#125;&#125;,&#123;&quot;pid&quot;:1,&quot;tid&quot;:4,&quot;ph&quot;:&quot;X&quot;,&quot;ts&quot;:0,&quot;dur&quot;:43318,&quot;name&quot;:&quot;Total Module Load&quot;,&quot;args&quot;:&#123;&quot;count&quot;:3,&quot;avg ms&quot;:14&#125;&#125;,&#123;&quot;pid&quot;:1,&quot;tid&quot;:5,&quot;ph&quot;:&quot;X&quot;,&quot;ts&quot;:0,&quot;dur&quot;:8108,&quot;name&quot;:&quot;Total Backend&quot;,&quot;args&quot;:&#123;&quot;count&quot;:1,&quot;avg ms&quot;:8&#125;&#125;,&#123;&quot;pid&quot;:1,&quot;tid&quot;:6,&quot;ph&quot;:&quot;X&quot;,&quot;ts&quot;:0,&quot;dur&quot;:7094,&quot;name&quot;:&quot;Total OptModule&quot;,&quot;args&quot;:&#123;&quot;count&quot;:2,&quot;avg ms&quot;:3&#125;&#125;,&#123;&quot;pid&quot;:1,&quot;tid&quot;:7,&quot;ph&quot;:&quot;X&quot;,&quot;ts&quot;:0,&quot;dur&quot;:6977,&quot;name&quot;:&quot;Total CodeGenPasses&quot;,&quot;args&quot;:&#123;&quot;count&quot;:1,&quot;avg ms&quot;:6&#125;&#125;,&#123;&quot;pid&quot;:1,&quot;tid&quot;:8,&quot;ph&quot;:&quot;X&quot;,&quot;ts&quot;:0,&quot;dur&quot;:5819,&quot;name&quot;:&quot;Total OptFunction&quot;,&quot;args&quot;:&#123;&quot;count&quot;:40,&quot;avg ms&quot;:0&#125;&#125;,&#123;&quot;pid&quot;:1,&quot;tid&quot;:9,&quot;ph&quot;:&quot;X&quot;,&quot;ts&quot;:0,&quot;dur&quot;:5585,&quot;name&quot;:&quot;Total RunPass&quot;,&quot;args&quot;:&#123;&quot;count&quot;:729,&quot;avg ms&quot;:0&#125;&#125;,&#123;&quot;pid&quot;:1,&quot;tid&quot;:10,&quot;ph&quot;:&quot;X&quot;,&quot;ts&quot;:0,&quot;dur&quot;:479,&quot;name&quot;:&quot;Total DebugType&quot;,&quot;args&quot;:&#123;&quot;count&quot;:88,&quot;avg ms&quot;:0&#125;&#125;,&#123;&quot;pid&quot;:1,&quot;tid&quot;:11,&quot;ph&quot;:&quot;X&quot;,&quot;ts&quot;:0,&quot;dur&quot;:279,&quot;name&quot;:&quot;Total CodeGen Function&quot;,&quot;args&quot;:&#123;&quot;count&quot;:1,&quot;avg ms&quot;:0&#125;&#125;,&#123;&quot;pid&quot;:1,&quot;tid&quot;:12,&quot;ph&quot;:&quot;X&quot;,&quot;ts&quot;:0,&quot;dur&quot;:223,&quot;name&quot;:&quot;Total PerModulePasses&quot;,&quot;args&quot;:&#123;&quot;count&quot;:1,&quot;avg ms&quot;:0&#125;&#125;,&#123;&quot;pid&quot;:1,&quot;tid&quot;:13,&quot;ph&quot;:&quot;X&quot;,&quot;ts&quot;:0,&quot;dur&quot;:56,&quot;name&quot;:&quot;Total Module LoadIndex&quot;,&quot;args&quot;:&#123;&quot;count&quot;:1,&quot;avg ms&quot;:0&#125;&#125;,&#123;&quot;pid&quot;:1,&quot;tid&quot;:14,&quot;ph&quot;:&quot;X&quot;,&quot;ts&quot;:0,&quot;dur&quot;:21,&quot;name&quot;:&quot;Total PerFunctionPasses&quot;,&quot;args&quot;:&#123;&quot;count&quot;:1,&quot;avg ms&quot;:0&#125;&#125;,&#123;&quot;pid&quot;:1,&quot;tid&quot;:15,&quot;ph&quot;:&quot;X&quot;,&quot;ts&quot;:0,&quot;dur&quot;:3,&quot;name&quot;:&quot;Total PerformPendingInstantiations&quot;,&quot;args&quot;:&#123;&quot;count&quot;:1,&quot;avg ms&quot;:0&#125;&#125;,&#123;&quot;cat&quot;:&quot;&quot;,&quot;pid&quot;:1,&quot;tid&quot;:0,&quot;ts&quot;:0,&quot;ph&quot;:&quot;M&quot;,&quot;name&quot;:&quot;process_name&quot;,&quot;args&quot;:&#123;&quot;name&quot;:&quot;clang-10&quot;&#125;&#125;]&#125; 可以用Chrome打开chrome://tracing，然后拖入该json文件，可以直观的看到各个阶段编译消耗的时间 这里摘取YYTimer.json里面的一个片段 1234567891011121314151617181920212223&#123; &quot;pid&quot;: 1, &quot;tid&quot;: 0, &quot;ph&quot;: &quot;X&quot;, &quot;ts&quot;: 66818, &quot;dur&quot;: 1868, &quot;name&quot;: &quot;Source&quot;, &quot;args&quot;: &#123; &quot;detail&quot;: &quot;/Users/bomo/Documents/Code/iOS/Work/FanXing/Pods/KGThirdParty/KGThirdParty/YYKit/Utility/YYTimer.h&quot; &#125; &#125;, &#123; &quot;pid&quot;: 1, &quot;tid&quot;: 1, &quot;ph&quot;: &quot;X&quot;, &quot;ts&quot;: 0, &quot;dur&quot;: 100526, &quot;name&quot;: &quot;Total ExecuteCompiler&quot;, &quot;args&quot;: &#123; &quot;count&quot;: 1, &quot;avg ms&quot;: 100 &#125;&#125; 这里的name=Source为头文件YYTimer.h预编译处理的时间，dur为时间，单位为微秒，name&#x3D;Total ExecuteCompiler为该文件的编译时间 三、项目测试通过上面的方法，编译整个项目，并统计所有文件的预编译处理时间，我这里用python扫描所有编译文件，然后做汇总统计 3.1 各编译阶段耗时 编译类型 耗时 Total ExecuteCompiler: 5077.09 秒 Total Frontend: 3571.56 秒 Total Source: 2479.86 秒 Total Module Load: 1598.68 秒 Total Backend: 396.09 秒 Total CodeGenPasses: 373.86 秒 Total OptModule: 371.34 秒 Total OptFunction: 272.03 秒 Total RunPass: 263.66 秒 Total Module Compile: 142.07 秒 从上面数据看出Source耗时最长，占用2479.86s，占比较大 3.2 头文件引用次数（TOP10） 通过上面生成的json文件可以得到 头文件 引用次数 平均耗时 ******Common-prefix.pch 1619次 51.91毫秒 ******Singleton.h 712次 6.01毫秒 ******User-prefix.pch 701次 50.23毫秒 ******GiftList.h 623次 10.22毫秒 ******ModelObject.h 617次 3.42毫秒 ******Constants.h 617次 1.86毫秒 ******LiveInfo.h 612次 3.34毫秒 ******ProgramInfo.h 612次 5.58毫秒 ******AnimationView.h 612次 2.27毫秒 ******ViewDefine.h 611次 2.75毫秒 注：这里的引用，包含间接引用 * A引用C * B引用A * D引用B 则C被引用3次，会参与3次预编译处理，当D被引用100次时，A,B,C也会被引用处理100次，编译器在编译的时候会有其他优化策略，具体次数可能会细微差异 3.3 头文件单次预处理耗时（TOP10） 头文件 耗时（平均） 引用次数 ******ResultVC.h 31971.25毫秒 1 ******ListView.h 17175.35毫秒 1 ******ItemEntity.h 16750.17毫秒 1 ******GuideView.h 16623.81毫秒 1 ******RecommendView.h 15125.93毫秒 1 ******DrawerCell.h 13072.67毫秒 2 ******HelperMsgContainer.h 13055.01毫秒 2 ******RecordCell.h 10176.65毫秒 2 ******VerifyDao.h 7482.75毫秒 2 ******AppealModel.h 7247.25毫秒 4 注：由于头文件会多级引用，所以处理时间会叠加，这里仅供参考 3.4 头文件预处理总耗时（TOP10） 头文件 总耗时 引用次数 ****Common.h 939.64秒 610 ****AlertView.h 267.89秒 608 ****Common-prefix.pch 84.04秒 1619 ****MesageParse.h 58.98秒 600 ****RoomManager.h 43.77秒 598 ****User-prefix.pch 35.21秒 701 ****VideoInfoModel.h 34.40秒 10 ****VideoModel.h 33.91秒 8 ****ResultVC.h 31.97秒 1 ****Data-umbrella.h 31.47秒 64 注：xxxxCommon.h文件引用次数不是最多，但总耗时最长 4. 方案通过上面测试数据可以看出，xxxxCommon.h预处理耗时最长，通过查看该文件可以看出 该文件引用了非常多头文件（500+），完全展开的话会非常大，符合耗时的预期 项目中很多地方引用xxxxCommon.h文件可能只是用到里面其中一个或几个类，而有些地方为了图方便，就引用了这个大而全的文件，而引用整个xxxxCommon.h导致而预处理却花去了大量非必要的时间 这里决定给xxxxCommon.h文件进行瘦身，逐步把引用迁移到更轻量的头文件引用，并在具体的文件中补齐其他缺失的头文件，**头文件按需引用，减少不必要的预编译处理** 5. 成效 机器：iMac (Retina 4K, 21.5-inch, 2019)， CPU: 3 GHz 六核Intel Core i5 * 内存：16 GB 2667 MHz DDR4 * 显卡：Radeon Pro 560X 4 GB Configuration: DEBUG 编译架构：arm64 5.1宏观统计（6核）（减少110.9s）测试方法： 关闭Xcode，关闭Chrome等大进程 删除所有Xcode缓存文件（~/Library/Developer/Xcode/DerivedData/） 打开Xcode编译 编译完成后，查看Xcode显示的编译总时间 测试结果去掉最高最低值 宏观统计 测试1 测试2 测试3 测试4 平均 基础工程 447.9 446.3 452.7 453.2 450.025 优化后工程 339.8 336.8 338.1 341.7 339.1 注：部分子库用了二进制，这里更多关注差值 5.2 微观统计（减少372.7s） 测试方法： 使用上面提到的llvm自带统计工具，然后汇总结果统计所有文件的Total ExecuteCompiler 测试结果去掉最高最低值 去掉所有的clang插件 微观统计 测试1 测试2 测试3 平均 基础工程 1449.3 1445.8 1456.3 1450.4 优化后工程 1076.8 1092.3 1064.1 1077.7 总结 上面优化修改了2115个文件，工作量还是比较大的，主要还是编码习惯和长期未规范使用带来量变积累，导致质变，平时养成良好的编码习惯，减少量变积累 Xcode在编译的时候会把#import &lt;AAA/BBB.h&gt;自动转成@import AAA.BBB，为了统一风格，建议统一使用#import &lt;AAA/BBB.h&gt;方式引用，详情见WWDC2013-Advances in Objective-C 坚持一个原则：按需引用，按需引用（最小import原则），请引用#import &lt;FAFuncUnit/XXX.h&gt;，而不是#import &lt;LibA/LibA-umbrella.h&gt;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"}]},{"title":"（六）树莓派4B安装gitea","slug":"raspberrypi-gitea","date":"2021-09-12T08:56:54.000Z","updated":"2021-09-12T08:56:54.000Z","comments":true,"path":"2021-09-12/raspberrypi-gitea/","link":"","permalink":"http://zhengbomo.github.io/2021-09-12/raspberrypi-gitea/","excerpt":"最近git项目多了一些比较大的文件（数据库），第三方服务器的lfs基本都要收费，所以考虑自己搭建一个git服务器存放代码，关于git服务器有gitea，gitlab，gitlab功能太多，个人使用很多用不到，而且内存占用高，而gitea相对简洁，功能够用，选择gitea","text":"最近git项目多了一些比较大的文件（数据库），第三方服务器的lfs基本都要收费，所以考虑自己搭建一个git服务器存放代码，关于git服务器有gitea，gitlab，gitlab功能太多，个人使用很多用不到，而且内存占用高，而gitea相对简洁，功能够用，选择gitea 安装12345# 下载giteawget -O gitea https://dl.gitea.io/gitea/1.17.2/gitea-1.17.2-linux-arm64# 添加权限chmod +x gitea 启动指定端口为8899 1./gitea web -p 8899 访问http://192.168.2.11:8899就能进入gitea 由于是自己用，我这里选择SQLite，配置完成后，会跳转到http://localhost:3000/user/login，由于服务在树莓派上，我们需要把localhost改为树莓派的地址，配置完成后会custom/conf/app.ini生成配置文件，我们需要吧localhost换成对应的地址，如果绑定了域名，可以换成域名 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576APP_NAME = Gitea: Git with a cup of teaRUN_USER = ubuntuRUN_MODE = prod[server]LOCAL_ROOT_URL = http://192.168.2.11:8899/SSH_DOMAIN = 192.168.2.11DOMAIN = 192.168.2.11HTTP_PORT = 8899ROOT_URL = http://192.168.2.11:8899/DISABLE_SSH = falseSSH_PORT = 22222LFS_START_SERVER = trueLFS_JWT_SECRET = JU6s1q1kgPVDIIKHRzsUkjJ5HgUSBknJGN7FyKf-hgYOFFLINE_MODE = true[database]DB_TYPE = sqlite3HOST = 127.0.0.1:3306NAME = giteaUSER = giteaPASSWD =SCHEMA =SSL_MODE = disableCHARSET = utf8PATH = /home/ubuntu/server/gitea/data/gitea.dbLOG_SQL = false[repository]ROOT = /home/ubuntu/server/gitea/data/gitea-repositories[lfs]PATH = /home/ubuntu/server/gitea/data[mailer]ENABLED = false[service]REGISTER_EMAIL_CONFIRM = falseENABLE_NOTIFY_MAIL = falseDISABLE_REGISTRATION = falseALLOW_ONLY_EXTERNAL_REGISTRATION = falseENABLE_CAPTCHA = falseREQUIRE_SIGNIN_VIEW = falseDEFAULT_KEEP_EMAIL_PRIVATE = falseDEFAULT_ALLOW_CREATE_ORGANIZATION = trueDEFAULT_ENABLE_TIMETRACKING = trueNO_REPLY_ADDRESS = noreply.localhost[picture]DISABLE_GRAVATAR = trueENABLE_FEDERATED_AVATAR = false[openid]ENABLE_OPENID_SIGNIN = falseENABLE_OPENID_SIGNUP = false[session]PROVIDER = file[log]MODE = consoleLEVEL = infoROOT_PATH = /home/ubuntu/server/gitea/logROUTER = console[repository.pull-request]DEFAULT_MERGE_STYLE = merge[repository.signing]DEFAULT_TRUST_MODEL = committer[security]INSTALL_LOCK = trueINTERNAL_TOKEN = eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYmYiOjE2NjQ3NjIwMDR9.C0b_xPSiljfhuDChyKTnzKuVtvSMjZsFSr31RxRZYLAPASSWORD_HASH_ALGO = pbkdf2 如果使用gitea内置的SSH服务器的话，需要添加START_SSH_SERVER开启服务 123[server]...START_SSH_SERVER = true 开机启动添加一个系统用户gitea用于执行gitea 12345# 创建用户gitea，用户组为watchdogsudo adduser --system --ingroup watchdog --disabled-password --shell /bin/bash --no-create-home --gecos &#x27;Git Version Control&#x27; gitea# 给用户添加文件权限sudo chown -R gitea:watchdog /home/ubuntu/server/gitea 添加开机启动脚本/etc/systemd/system/gitea.service 12345678910111213141516[Unit]Description=Gitea (Git with a cup of tea)After=syslog.targetAfter=network.target#After=mysqld.service[Service]RestartSec=2sUser=giteaGroup=watchdogUMask=0002WorkingDirectory=/home/ubuntu/server/giteaExecStart=/home/ubuntu/server/gitea/gitea -c /home/ubuntu/server/gitea/custom/conf/app.ini -p 8899[Install]WantedBy=multi-user.target 开机启动 1234567891011121314151617# 重新加载配置文件sudo systemctl daemon-reload# 开机启动sudo systemctl enable gitea# 关闭开机启动sudo systemctl disable gitea# 启动sudo systemctl start gitea# 停止sudo systemctl stop gitea# 重启sudo systemctl restart gitea# 查看状态sudo systemctl status gitea 接下来就可以直接在web页面玩耍了","categories":[{"name":"树莓派","slug":"树莓派","permalink":"http://zhengbomo.github.io/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"http://zhengbomo.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"}]},{"title":"（五）树莓派安装可道云","slug":"raspberrypi-kodexplorer","date":"2021-09-08T14:11:26.000Z","updated":"2021-09-08T14:11:26.000Z","comments":true,"path":"2021-09-08/raspberrypi-kodexplorer/","link":"","permalink":"http://zhengbomo.github.io/2021-09-08/raspberrypi-kodexplorer/","excerpt":"文件管理的工具有很多，如filebrowser，可道云，nextcloud，seafile，几种都试过，最终觉得可道云最符合自己的操作习惯，可道云有两个版本，kodbox和 kodexplorer，kodbox为kodexplorer的重构版本，新增了一些功能，个人用我认为kodexplorer就够了","text":"文件管理的工具有很多，如filebrowser，可道云，nextcloud，seafile，几种都试过，最终觉得可道云最符合自己的操作习惯，可道云有两个版本，kodbox和 kodexplorer，kodbox为kodexplorer的重构版本，新增了一些功能，个人用我认为kodexplorer就够了 下载安装可道云是基于php开发的，这里需要先安装apache2和php 12345678910sudo apt update# apache2sudo apt install apache2# 安装phpsudo apt install php# 解压sudo apt install unzip 安装php依赖 1sudo apt install php-curl php-mbstring 下载可道云 1234567891011# 下载wget https://static.kodcloud.com/update/download/kodexplorer4.46.zip# 解压unzip kodexplorer4.46.zip# 移动sudo mv kodexplorer /var/www/kodexplorer# 设置权限sudo chmod -R 777 /var/www/kodexplorer 配置apache2修改apache2站点配置 /etc/apache2/sites-available/000-default.conf，添加端口8081用于可道云（也可以使用原来的80端口） 1234567891011121314151617# 这是apache默认的站点&lt;VirtualHost *:80&gt; ServerAdmin webmaster@localhost DocumentRoot /var/www/html ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined&lt;/VirtualHost&gt;# 可道云&lt;VirtualHost *:8081&gt; ServerAdmin webmaster@localhost DocumentRoot /var/www/kodexplorer ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined&lt;/VirtualHost&gt; 添加端口监听 /etc/apache2/ports.conf 12345678910111213Listen 80# 可道云端口NameVirtualHost *:8081Listen 8081&lt;IfModule ssl_module&gt; Listen 443&lt;/IfModule&gt;&lt;IfModule mod_gnutls.c&gt; Listen 443&lt;/IfModule&gt; 配置完成后，重启apache2 1sudo systemctl restart apache2 这时候就可以访问可道云了 http://192.168.2.*:8081 权限apache2默认使用的用户为www-data，这里给www-data添加组权限，这样管理文件方便点（这里我用的组是watchdog，可以根据自己的习惯或需要设置） 12345# 添加www-data到组watchdogsudo gpasswd -a www-data watchdog# 也可以www-data为watchdog组sudo usermod -g watchdog www-data 其他设置在可道云上默认的文件创建权限为755，可以到config/config.php修改，我自己是改为774，组内成员可以修改 1define(&#x27;DEFAULT_PERRMISSIONS&#x27;,0755); //新建文件、解压文件默认权限，777 部分虚拟主机限制了777;","categories":[{"name":"树莓派","slug":"树莓派","permalink":"http://zhengbomo.github.io/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"http://zhengbomo.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"}]},{"title":"（四）树莓派安装Samba","slug":"raspberrypi-samba","date":"2021-09-05T02:55:59.000Z","updated":"2021-09-05T02:55:59.000Z","comments":true,"path":"2021-09-05/raspberrypi-samba/","link":"","permalink":"http://zhengbomo.github.io/2021-09-05/raspberrypi-samba/","excerpt":"树莓派挂载了一个硬盘，用来存放文件，视频，照片，需要共享到其他设备查看，并且需要权限管理 常用的文件共享工具有 DLNA: 主要用于多媒体共享，没有权限管理，所有人都可以看到，由于视频是服务器解码，对于大码率（4K）视频支持比较好 Samba: 主要用于局域网文件共享，支持权限控制，大码率视频支持较弱 FTP: 速度比Samba快，支持权限控制","text":"树莓派挂载了一个硬盘，用来存放文件，视频，照片，需要共享到其他设备查看，并且需要权限管理 常用的文件共享工具有 DLNA: 主要用于多媒体共享，没有权限管理，所有人都可以看到，由于视频是服务器解码，对于大码率（4K）视频支持比较好 Samba: 主要用于局域网文件共享，支持权限控制，大码率视频支持较弱 FTP: 速度比Samba快，支持权限控制 我这里还是选择用Samba，因为电视和手机支持比较好，而对于大码率视频，则使用DLNA（minidlna），这里介绍安装samba的过程 安装12sudo apt updatesudo apt install samba 配置配置文件在/etc/samba/smb.conf，下面配置放到文件最后面 12345678910111213141516[学习] comment = 学习，可读写，只有bomo可以查看 path = /mnt/h1/learn browseable = yes writable = yes available = yes valid users = ubuntu,bomo guest ok = no [视频] comment = 视频，所有人可以查看，只读 path = /home/ubuntu/git browseable = yes writable = no available = yes guest ok = yes 由于samba的用户必须是系统用户，这里我们创建用户bomo，并且不需要密码，不需要 12# 添加系统用户bomo，属于组watchdog，无密码，不创建home目录sudo adduser --system --ingroup watchdog --disabled-password --shell /bin/bash --no-create-home bomo 虽然samba的用户必须是系统用户，但是密码可以单独设置 12# 设置用户samba密码smbpasswd -a bomo 设置完成，重启samba 12# 重启sambasudo systemctl restart smbd 接下来就可以在其他支持samba的设备发现并登录了 设置文件权限安装samba的时候，会自动添加开机启动服务/lib/systemd/system/smbd.service，这里我们添加UMask和Group，方便管理文件 1234567891011121314151617181920212223[Unit]Description=Samba SMB DaemonDocumentation=man:smbd(8) man:samba(7) man:smb.conf(5)Wants=network-online.targetAfter=network.target network-online.target nmbd.service winbind.service[Service]Type=notifyNotifyAccess=allPIDFile=/run/samba/smbd.pidUser=rootGroup=watchdogUMask=0002LimitNOFILE=16384EnvironmentFile=-/etc/default/sambaExecStartPre=/usr/share/samba/update-apparmor-samba-profileExecStart=/usr/sbin/smbd --foreground --no-process-group $SMBDOPTIONSExecReload=/bin/kill -HUP $MAINPIDLimitCORE=infinity[Install]WantedBy=multi-user.target 刷新服务重启 123sudo systemctl daemon-reload# 启动sudo systemctl restart smbd","categories":[{"name":"树莓派","slug":"树莓派","permalink":"http://zhengbomo.github.io/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"http://zhengbomo.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"}]},{"title":"（三）树莓派开机自动挂载硬盘","slug":"raspberrypi-mount-disk","date":"2021-09-02T11:13:42.000Z","updated":"2021-09-02T11:13:42.000Z","comments":true,"path":"2021-09-02/raspberrypi-mount-disk/","link":"","permalink":"http://zhengbomo.github.io/2021-09-02/raspberrypi-mount-disk/","excerpt":"我的硬盘是长期接在树莓派上的，这里设置开机自动挂载，避免重启后，读不到硬盘数据","text":"我的硬盘是长期接在树莓派上的，这里设置开机自动挂载，避免重启后，读不到硬盘数据 挂载硬盘1234567891011121314# 查看硬盘，得到硬盘为/dev/sda1sudo fdisk -l# 需要确保挂载的目录是存在的，如果不存在则创建mkdir /mnt/h1# 1. 挂载硬盘sudo mount /dev/sdb1 /mnt/h1# 2. 挂载硬盘可以设置目录的所属用户所属组和umasksudo mount -o umask=0002,gid=watchdog,uid=ubuntu /dev/sdb1 /mnt/h1# 取消挂载sudo umount /dev/sdb1 自动挂载硬盘 查看硬盘UUID12345# 1. 查看硬盘uuidsudo blkid# 输出得到下面信息/dev/sda1: LABEL=&quot;pi&quot; UUID=&quot;3E5F551D2B409931&quot; TYPE=&quot;ntfs&quot; PTTYPE=&quot;atari&quot; 得到UUID为：3E5F551D2B409931 开机挂载/etc/fstab 1234UUID=&quot;3E5F551D2B409931&quot; /mnt/h1 ntfs defaults 0 1# 添加所属用户，组，umaskUUID=&quot;3E5F551D2B409931&quot; /mnt/h1 ntfs user,rw,umask=0002,uid=ubuntu,gid=watchdog 0 1 使用 df命令查看硬盘挂载情况 1234567ubuntu@ubuntu:~$ dfFilesystem 1K-blocks Used Available Use% Mounted ontmpfs 189000 4080 184920 3% /runtmpfs 944992 0 944992 0% /dev/shmtmpfs 5120 0 5120 0% /run/locktmpfs 4096 0 4096 0% /sys/fs/cgroup/dev/sda1 976760828 72838540 903922288 8% /mnt/h1 完成","categories":[{"name":"树莓派","slug":"树莓派","permalink":"http://zhengbomo.github.io/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"http://zhengbomo.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"}]},{"title":"（二）树莓派4B自动控制风扇开关","slug":"raspberrypi-autofan","date":"2021-08-28T03:27:39.000Z","updated":"2021-08-28T03:27:39.000Z","comments":true,"path":"2021-08-28/raspberrypi-autofan/","link":"","permalink":"http://zhengbomo.github.io/2021-08-28/raspberrypi-autofan/","excerpt":"树莓派4B性能强大，发热也大，我在上面跑可道云和aria2，在没有风扇的情况下基本都要到60-70℃了，通常都会买个外壳接一个小风扇用于散热，淘宝上有很多，挑一个自己喜欢的，我这台设备加了风扇后可以稳定在40-50之间 默认情况下，风扇是随着电源开关控制的，即使关机了，风扇也会转，这里介绍使用三极管控制风扇开关的方法","text":"树莓派4B性能强大，发热也大，我在上面跑可道云和aria2，在没有风扇的情况下基本都要到60-70℃了，通常都会买个外壳接一个小风扇用于散热，淘宝上有很多，挑一个自己喜欢的，我这台设备加了风扇后可以稳定在40-50之间 默认情况下，风扇是随着电源开关控制的，即使关机了，风扇也会转，这里介绍使用三极管控制风扇开关的方法 接线引脚树莓派4B的引脚如下图 买来的风扇的正负极接4, 6引脚 通过三极管添加控制线风扇接上树莓派引脚后就会开启，随电源开关，无法进行控制，关机的时候也会转，通常有两种方式 使用三极管接线从而达到控制风扇的目的 taobao买T9温控模块（https://item.taobao.com/item.htm?id=553295324487） 这里第一种方式，添加三极管 三极管，我这里用的是S8050（NPN型）的三极管 我是在这里买的，2.8块钱50个 杜邦线-公对母: 2根 杜邦线-母对母: 2根 三极管三级 接线示意图（分别接到4，6，12号引脚上） 效果图 有朋友可能买到的是S8850（PNP型）的三极管，接线和上面不一样，需要注意，可以参考这个链接，不过我没试过，https://blog.csdn.net/Xxy605/article/details/115960846 接完之后开机，会发现风扇默认是不转的，我们需要手动控制风扇的开关 通过python脚本控制开关安装依赖文件 12345sudo apt updatesudo apt install python3-pipsudo apt -y install python3-rpi.gpiosudo pip install RPi.GPIO 下面脚本控制风扇开关 12345678910111213141516171819202122232425import RPi.GPIO as GPIO# 控制线接的是12号引脚FAN = 12GPIO.setwarnings(False)GPIO.setmode(GPIO.BOARD)# 设为输出模式GPIO.setup(FAN, GPIO.OUT)# 开风扇GPIO.output(FAN, GPIO.HIGH)# 关风扇GPIO.output(FAN, GPIO.LOW)# 设为输入模式GPIO.setup(FAN, GPIO.IN, pull_up_down=GPIO.PUD_UP)# 读取当前风扇状态isOff = GPIO.input(FAN) == GPIO.LOW;# 关闭GPIO.cleanup() 可以PWM控制风扇的风速 1234567pwm = GPIO.PWM(FAN, 50)# 满速（0-100）pwm.start(100)# 关闭pwm.stop() 查看CPU温度通过读取文件/sys/class/thermal/thermal_zone0/temp获得CPU温度 12345# 查看当前CPU温度cat /sys/class/thermal/thermal_zone0/temp# 观察CPU温度，每秒更新一次watch -n 1 cat /sys/class/thermal/thermal_zone0/temp 温控风扇脚本下面是通过温度控制风扇开关的脚本（由于我的风扇比较小，就没有考虑控制风速，只做开关） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# -*- coding: utf-8 -*- import RPi.GPIO as GPIOimport time # 控制风扇的GPIOFAN_GPIO = 12# 低温阈值，低于它则关闭风扇MIN_TEMP = 45# 高温阈值，高于它则全速运转MAX_TEMP = 50# 多长时间读取一次CPU温度，单位秒SAMPLING = 60 # 单位为千分之一度def get_cpu_temp(): with open(&#x27;/sys/class/thermal/thermal_zone0/temp&#x27;) as f: cpu_temp = int(f.read()) return cpu_temp def main(): GPIO.setwarnings(False) GPIO.setmode(GPIO.BOARD) GPIO.setup(FAN_GPIO, GPIO.OUT) GPIO.output(FAN_GPIO, GPIO.LOW) time.sleep(5) try: while 1: temp = get_cpu_temp() print(&#x27;CPU temperature:&#x27;, temp) if temp &lt; MIN_TEMP * 1000: GPIO.output(FAN_GPIO, 0) elif temp &gt; MAX_TEMP * 1000: GPIO.output(FAN_GPIO, 1) else: # 中间地带，开 GPIO.output(FAN_GPIO, 1) time.sleep(SAMPLING) except KeyboardInterrupt: pass GPIO.cleanup()if __name__ == &#x27;__main__&#x27;: main() 脚本保存到/home/ubuntu/server/fan/autofan.py 开机启动创建service（/etc/systemd/system/autofan.service） 1234567891011121314[Unit]Description=auto fan controlAfter=syslog.targetAfter=network.target[Service]RestartSec=2sUser=rootGroup=rootWorkingDirectory=/home/ubuntu/server/fan/ExecStart=/usr/bin/python3 /home/ubuntu/server/fan/autofan.py[Install]WantedBy=multi-user.target 刷新并加载 12345678# 重新加载配置 sudo systemctl daemon-reload# 开机启动sudo systemctl enable autofan# 启动sudo systemctl start autofan# 状态sudo systemctl status autofan 之后每次重启都会自动根据温度开关风扇了","categories":[{"name":"树莓派","slug":"树莓派","permalink":"http://zhengbomo.github.io/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"http://zhengbomo.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"}]},{"title":"（一）树莓派4B开机","slug":"raspberrypi-start","date":"2021-08-27T02:42:56.000Z","updated":"2021-08-27T02:42:56.000Z","comments":true,"path":"2021-08-27/raspberrypi-start/","link":"","permalink":"http://zhengbomo.github.io/2021-08-27/raspberrypi-start/","excerpt":"最近上手了一个树莓派4B，这里记录安装系统和连接的过程的，由于没有mini hdmi线，需要提前做一些设置","text":"最近上手了一个树莓派4B，这里记录安装系统和连接的过程的，由于没有mini hdmi线，需要提前做一些设置 安装系统1. 下载镜像写入工具用官方的Raspberry Pi Imager就行 2. 下载系统 官方系统: https://www.raspberrypi.org/software/operating-systems ubuntu: https://ubuntu.com/download/raspberry-pi 其他: https://www.raspberrypi.org/software/operating-systems 树莓派虽然很强大，但还是很难作为真正的生产力，大多数情况还是作为服务，我没有选择Desktop版本，而是选择Ubuntu Server 20.04 TLS 3. 写入TF卡 4. SSH连接特别是没法外接显示器的，第一步只能通过SSH连接，烧录完成后，先不急着开机，会提示拔出卡，重新插入tf卡，可以看到system-boot分区，这里我们在里面新建一个空的文本文件，命名为SSH，这样开机后就可以通过SSH连接了 5. wifi设置如果你没有网线，也没有外接屏幕，可以设置wifi信息，树莓派在启动后会自动连接wifi，在system-boot分区根目录有个network-config文件，可以配置无线网络，找到wifis相关配置 12345678910111213141516#wifis:# wlan0:# dhcp4: true# optional: true# access-points:# myhomewifi:# password: &quot;S3kr1t&quot;# myworkwifi:# password: &quot;correct battery horse staple&quot;# workssid:# auth:# key-management: eap# method: peap# identity: &quot;me@example.com&quot;# password: &quot;passw0rd&quot;# ca-certificate: /etc/my_ca.pem 修改为（SSID: HomeWifi，密码：12345678） 1234567wifis: wlan0: dhcp4: true optional: true access-points: &quot;HomeWifi&quot;: password: &quot;12345678&quot; 6. 关闭LED指示灯可以通过config.txt文件的[pi4]下面添加下面命令关闭 1234567891011# 关闭电源指示灯(红色)dtparam=pwr_led_trigger=nonedtparam=pwr_led_activelow=off# 关闭活动指示灯(绿色)dtparam=act_led_trigger=nonedtparam=act_led_activelow=off# 关闭网线口指示灯dtparam=eth_led0=4dtparam=eth_led1=4 安装TF卡插入树莓派通电即可，通过路由器可以看到树莓派连接的IP地址（如：192.168.2.*），通过ssh连接 ubuntu系统默认用户名和密码都是ubuntu 官方系统的默认用户名和密码是pi和raspberry 1ssh ubuntu@192.168.2.* 接下来就可以愉快的玩耍了 通过VNC连接如果你安装的是官方的系统，则可以通过VNC连接到树莓派，而不用外接屏幕 通过ssh连接到树莓派后，进入设置 1sudo raspi-config 选择Interfacing Options -&gt; VNC-&gt; （询问是否enabled）Yes 之后直接用VNC Viewer，就可以连接到树莓派了 黑屏这里可能会遇到黑屏的情况，还是进入raspi-config，选择Advanced Options -&gt; Resolution -&gt; 1280x720（随便选择一个分辨率，不要选Default） 其他查看硬件版本，我的是1.4版本的，另外还有1.1和1.2版本 12cat /sys/firmware/devicetree/base/modelRaspberry Pi 4 Model B Rev 1.4","categories":[{"name":"树莓派","slug":"树莓派","permalink":"http://zhengbomo.github.io/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"http://zhengbomo.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"}]},{"title":"【OpenGL案例5】球的自转和公转","slug":"opengl-demo5","date":"2020-07-20T08:47:49.000Z","updated":"2023-06-11T03:02:51.869Z","comments":true,"path":"2020-07-20/opengl-demo5/","link":"","permalink":"http://zhengbomo.github.io/2020-07-20/opengl-demo5/","excerpt":"通过案例4我们已经知道如何绘制球了，本案例绘制一个非常经典的案例，就是球的自转和公转（小球公转，大球自转）","text":"通过案例4我们已经知道如何绘制球了，本案例绘制一个非常经典的案例，就是球的自转和公转（小球公转，大球自转） 为了方便看出自转，这里只画三角形线，不进行填充 绘制图形基于前面的案例4的基础上来绘制 绘制地板1234567891011121314151617// 地板GLBatch floorBatch;// 设置地板顶点数据floorBatch.Begin(GL_LINES, 324);for(GLfloat x = -20.0; x &lt;= 20.0f; x+= 0.5) &#123; floorBatch.Vertex3f(x, -0.55f, 20.0f); floorBatch.Vertex3f(x, -0.55f, -20.0f); floorBatch.Vertex3f(20.0f, -0.55f, x); floorBatch.Vertex3f(-20.0f, -0.55f, x);&#125;floorBatch.End();// 在renderSence绘制地板shaderManager.UseStockShader(GLT_SHADER_FLAT, transformPipeline.GetModelViewProjectionMatrix(), vGreen);floorBatch.Draw(); 大球和小球自转公转小球 12345// 设置大球模型gltMakeSphere(torusBatch, 0.4f, 20, 40);// 设置小球模型gltMakeSphere(sphereBatch, 0.2f, 8, 16); 随机小球 12345678910111213141516// 随机球个数#define NUM_SPHERES 50// 记录随机球位置GLFrame spheres[NUM_SPHERES];// 随机生成位置放置小球for (int i = 0; i &lt; NUM_SPHERES; i++) &#123; //y轴不变，X,Z产生随机值 GLfloat x = ((GLfloat)((rand() % 400) - 200 ) * 0.1f); GLfloat z = ((GLfloat)((rand() % 400) - 200 ) * 0.1f); // 在y方向，将球体设置为0.0的位置，这使得它们看起来是飘浮在眼睛的高度 // 对spheres数组中的每一个顶点，设置顶点数据 spheres[i].SetOrigin(x, 0.0f, z);&#125; renderSence添加视图矩阵到矩阵堆栈 12345678// 模型视图矩阵，push单元矩阵modelViewMatrix.PushMatrix();// 模型变换M3DMatrix44f mCamera;cameraFrame.GetCameraMatrix(mCamera);// push视图变换modelViewMatrix.PushMatrix(mCamera); 由于地板不需要其他变换，这时候可以绘制地板 12shaderManager.UseStockShader(GLT_SHADER_FLAT, transformPipeline.GetModelViewProjectionMatrix(), vGreen);floorBatch.Draw(); 让大小球显示在观察者前面，这里添加一个视图变换 12// 平移（z轴）让小球显示到观察者前面，modelViewMatrix.Translate(0.0f, 0.0f, -3.0f); 然后绘制大球，这里使用点点光源着⾊器，可以看到球的光照效果 123456789101112131415161718192021222324252627282930313233343536373839// 这里添加一个旋转角度(5°)，通过这个变量控制自转float yRot = 5;// 定义光源位置M3DVector4f vLightPos = &#123;0.0f,10.0f,5.0f,1.0f&#125;;// 绘制随机球，这里直接用小球的批次类来绘制for (int i = 0; i &lt; NUM_SPHERES; i++) &#123; modelViewMatrix.PushMatrix(); modelViewMatrix.MultMatrix(spheres[i]); shaderManager.UseStockShader( GLT_SHADER_POINT_LIGHT_DIFF, transformPipeline.GetModelViewMatrix(), transformPipeline.GetProjectionMatrix(), vLightPos, vBlue); sphereBatch.Draw(); modelViewMatrix.PopMatrix();&#125;// 旋转（用于大球自转）modelViewMatrix.PushMatrix();modelViewMatrix.Rotate(yRot, 0.0f, 1.0f, 0.0f);// 球上的三角形画线glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);glLineWidth(2f);// 指定合适的着色器(点光源着色器)shaderManager.UseStockShader( GLT_SHADER_POINT_LIGHT_DIFF, transformPipeline.GetModelViewMatrix(), transformPipeline.GetProjectionMatrix(), vLightPos, vRed);// 画球torusBatch.Draw();// 弹出旋转矩阵（因为旋转只用于大球）modelViewMatrix.PopMatrix(); 接下来画小球，先旋转，再平移（先旋转到固定的角度，再移到外面） 1234567891011121314151617// 旋转（公转）modelViewMatrix.Rotate(yRot * -2.0f, 0.0f, 1.0f, 0.0f);// 平移modelViewMatrix.Translate(0.8f, 0.0f, 0.0f);shaderManager.UseStockShader( GLT_SHADER_POINT_LIGHT_DIFF, transformPipeline.GetModelViewMatrix(), transformPipeline.GetProjectionMatrix(), vLightPos, vBlue);// 画小球sphereBatch.Draw();// 前面一共push了三个矩阵，用完后popmodelViewMatrix.PopMatrix();modelViewMatrix.PopMatrix();modelViewMatrix.PopMatrix(); 注意，这里的小球没有自转，只是跟随者Y轴旋转 定时器接下来是控制刷新，主要是修改yRot，就能控制自转和公转了，这里通过CStopWatch获取一个时间间隔，来生成一个动态的值 123static CStopWatch rotTimer;// 可以通过流失的时间获取一个动态的值float yRot = rotTimer.GetElapsedSeconds() * 60.0f; 完整代码见这里","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://zhengbomo.github.io/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://zhengbomo.github.io/tags/OpenGL/"}]},{"title":"【OpenGL案例4】球，环，圆柱，磁盘的绘制","slug":"opengl-demo4","date":"2020-07-20T04:55:22.000Z","updated":"2023-06-11T03:02:51.869Z","comments":true,"path":"2020-07-20/opengl-demo4/","link":"","permalink":"http://zhengbomo.github.io/2020-07-20/opengl-demo4/","excerpt":"在之前的案例中，我们通过定义三角形顶点绘制了一些几何图形，本案例使用OpenGL内置的图形绘制，查看GLTool.h，可以看到内置了下面图形","text":"在之前的案例中，我们通过定义三角形顶点绘制了一些几何图形，本案例使用OpenGL内置的图形绘制，查看GLTool.h，可以看到内置了下面图形 内置图形球12345//参数1：sphereBatch，三角形批次类对象//参数2：fRadius，球体半径//参数3：iSlices，从球体底部堆叠到顶部的三角形带的数量；其实球体是一圈一圈三角形带组成//参数4：iStacks，围绕球体一圈排列的三角形对数gltMakeSphere(GLTriangleBatch&amp; sphereBatch, GLfloat fRadius, GLint iSlices, GLint iStacks); 环123456//参数1：torusBatch，三角形批次类对象//参数2：majorRadius,甜甜圈中心到外边缘的半径//参数3：minorRadius,甜甜圈中心到内边缘的半径//参数4：numMajor,沿着主半径的三角形数量//参数5：numMinor,沿着内部较小半径的三角形数量gltMakeTorus(GLTriangleBatch&amp; torusBatch, GLfloat majorRadius, GLfloat minorRadius, GLint numMajor, GLint numMinor); 圆柱&#x2F;圆锥设置顶部和底部面的半径，相同为圆住，其中一个面的半径为0则为圆锥，半径不同类似一把中间镂空的伞 1234567//参数1：cylinderBatch，三角形批次类对象//参数2：baseRadius,底部半径//参数3：topRadius,头部半径//参数4：fLength,圆形长度//参数5：numSlices,围绕Z轴的三角形对的数量//参数6：numStacks,圆柱底部堆叠到顶部圆环的三角形数量void gltMakeCylinder(GLTriangleBatch&amp; cylinderBatch, GLfloat baseRadius, GLfloat topRadius, GLfloat fLength, GLint numSlices, GLint numStacks); 磁盘2D平面图形，有两个圆组成一个平面环 123456//参数1:diskBatch，三角形批次类对象//参数2:innerRadius,内圆半径//参数3:outerRadius,外圆半径//参数4:nSlices,圆盘围绕Z轴的三角形对的数量//参数5:nStacks,圆盘外网到内围的三角形数量void gltMakeDisk(GLTriangleBatch&amp; diskBatch, GLfloat innerRadius, GLfloat outerRadius, GLint nSlices, GLint nStacks); 立方体123//参数1:cubeBatch，立方体批次类对象//参数2:fRadius，每个方向到原点距离都为20个单位长度的立方体void gltMakeCube(GLBatch&amp; cubeBatch, GLfloat fRadius); 案例本案例基于案例3，原来的部分不做介绍，定义图形批次类 123456789101112// 球GLTriangleBatch sphereBatch;// 环GLTriangleBatch torusBatch;// 圆柱GLTriangleBatch cylinderBatch;// 锥GLTriangleBatch coneBatch;// 磁盘GLTriangleBatch diskBatch;// 立方体GLBatch cubeBatch; 生成批次类数据 123456789101112// 球gltMakeSphere(sphereBatch, 3.0, 10, 20);// 环面gltMakeTorus(torusBatch, 3.0f, 0.75f, 15, 15);// 圆柱gltMakeCylinder(cylinderBatch, 2.0f, 2.0f, 3.0f, 15, 2);// 锥gltMakeCylinder(coneBatch, 2.0f, 0.0f, 3.0f, 13, 2);// 磁盘gltMakeDisk(diskBatch, 1.5f, 3.0f, 13, 3);// 正立方体gltMakeCube(cubeBatch, 1); 在renderSence判断显示哪一个图形 1234567891011121314151617181920switch(nStep) &#123; case 0: drawWireFramedBatch(&amp;sphereBatch); break; case 1: drawWireFramedBatch(&amp;torusBatch); break; case 2: drawWireFramedBatch(&amp;cylinderBatch); break; case 3: drawWireFramedBatch(&amp;coneBatch); break; case 4: drawWireFramedBatch(&amp;diskBatch); break; case 5: drawWireFramedBatch(&amp;cubeBatch); break;&#125; 代码见这里","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://zhengbomo.github.io/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://zhengbomo.github.io/tags/OpenGL/"}]},{"title":"【OpenGL案例3】绘制金字塔、六边形、圆环","slug":"opengl-demo3","date":"2020-07-19T14:08:46.000Z","updated":"2020-07-19T14:08:46.000Z","comments":true,"path":"2020-07-19/opengl-demo3/","link":"","permalink":"http://zhengbomo.github.io/2020-07-19/opengl-demo3/","excerpt":"上节说到了不同的图元的装配方式，本节主要通过绘制金字塔，圆环，并使用透视投影，和矩阵变换来控制图形的显示","text":"上节说到了不同的图元的装配方式，本节主要通过绘制金字塔，圆环，并使用透视投影，和矩阵变换来控制图形的显示 基础知识OpenGL涉及到的基础变换主要有下面4种 变换 说明 视图变换 移动观察者的位置，观察者动，物体不动 模型变换 在场景中移动物体，观察者不动，物体动 投影变换 正投影，透视投影 视口变换 对窗口上最终输出进行缩放 其中对于同一个物体，使用视图变换和模型变换都能做到同样的效果，具体采用什么变换取决于实际情况 视图变换视图变换是应用到场景中的第一种变换，通过物体&#x2F;观察者在Z轴上的移动（默认是Z轴，也可以改为其他轴），确定场景中利于观察的位置。默认情况下，透视投影中的观察者位置处于原点（0，0，0），并沿着z轴负方向看向屏幕里面，一般通过moveForward方法来调整观察者位置，moveForward默认的朝向是-z轴，所以向屏幕里面移动传正数值，向屏幕外即+z轴，需要传负数值 123456789// 定义一个参考证GLFrame cameraFrame;// 向屏幕外（+z轴方向）移动15.0fcameraFrame.MoveForward(-15.0f);// 生成矩阵到mCamera，用于矩阵变换操作M3DMatrix44f mCamera;cameraFrame.GetCameraMatrix(mCamera); 模型变换模型变换，主要涉及三个函数，移动、旋转、缩放。有了这三个函数的组合，我们可以进行任意变换。 1234567891011// 平移，沿x/y/z三个方向平移，矩阵结果放在第一个参数里面void m3dTranslationMatrix44(M3DMatrix44f m, float x, float y, float z);// 旋转void m3dRotationMatrix44(M3DMatrix44f m, float angle, float x, float y, float z);// 缩放void m3dScaleMatrix44(M3DMatrix44f m, float xScale, float yScale, float zScale);// 矩阵叉乘，结果放在productvoid m3dMatrixMultiply44(M3DMatrix44f product, const M3DMatrix44f a, const M3DMatrix44f b); 翻转操作可以用旋转，也可以用缩放（缩放到-1） 投影变换通常也在窗口改变的时候设置 123456GLFrustum viewFrustum;// 设置透视投影viewFrustum.SetPerspective(35.0f, float(w) / float(h), 1.0f, 500.0f);// 加载投影矩阵到矩阵堆栈projectionMatrixprojectionMatrix.LoadMatrix(viewFrustum.GetProjectionMatrix()); 视口变换视口变换相关函数为，通常在窗口大小改变的时候修改 12// 修改glView视口glViewport (GLint x, GLint y, GLsizei width, GLsizei height); 这里需要注意的是，矩阵变换叉乘不满足交换律，变换顺序会导致结果不一致 绘制定义7个批次类，用于保存顶点 1234567GLBatch pointBatch;GLBatch lineBatch;GLBatch lineStripBatch;GLBatch lineLoopBatch;GLBatch triangleBatch;GLBatch triangleStripBatch;GLBatch triangleFanBatch; 在setupRC初始化顶点数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126// 定义三个点GLfloat vCoast[] = &#123; 3,3,0, 0,3,0, 3,0,0&#125;;// 画点pointBatch.Begin(GL_POINTS, 3);pointBatch.CopyVertexData3f(vCoast);pointBatch.End();// 画线lineBatch.Begin(GL_LINES, 3);lineBatch.CopyVertexData3f(vCoast);lineBatch.End();// 画连续线段lineStripBatch.Begin(GL_LINE_STRIP, 3);lineStripBatch.CopyVertexData3f(vCoast);lineStripBatch.End();// 画闭合线段lineLoopBatch.Begin(GL_LINE_LOOP, 3);lineLoopBatch.CopyVertexData3f(vCoast);lineLoopBatch.End();// 3个三角形，构成金字塔形状GLfloat vPyramid[12][3] = &#123; -2.0f, 0.0f, -2.0f, 2.0f, 0.0f, -2.0f, 0.0f, 4.0f, 0.0f, 2.0f, 0.0f, -2.0f, 2.0f, 0.0f, 2.0f, 0.0f, 4.0f, 0.0f, 2.0f, 0.0f, 2.0f, -2.0f, 0.0f, 2.0f, 0.0f, 4.0f, 0.0f, -2.0f, 0.0f, 2.0f, -2.0f, 0.0f, -2.0f, 0.0f, 4.0f, 0.0f&#125;;triangleBatch.Begin(GL_TRIANGLES, 12);triangleBatch.CopyVertexData3f(vPyramid);triangleBatch.End();// 三角形扇形--六边形GLfloat vPoints[100][3];int nVerts = 0;// 半径GLfloat r = 3.0f;// 原点(x,y,z) = (0,0,0);vPoints[nVerts][0] = 0.0f;vPoints[nVerts][1] = 0.0f;vPoints[nVerts][2] = 0.0f;// M3D_2PI 就是2Pi 的意思，就一个圆的意思。 绘制圆形for (GLfloat angle = 0; angle &lt; M3D_2PI; angle += M3D_2PI / 6.0f) &#123; // 数组下标自增（每自增1次就表示一个顶点） nVerts++; /* 弧长=半径*角度,这里的角度是弧度制,不是平时的角度制 既然知道了cos值,那么角度=arccos,求一个反三角函数就行了 */ // x点坐标 cos(angle) * 半径 vPoints[nVerts][0] = float(cos(angle)) * r; // y点坐标 sin(angle) * 半径 vPoints[nVerts][1] = float(sin(angle)) * r; // z点的坐标 vPoints[nVerts][2] = -0.5f;&#125;// 结束扇形 前面一共绘制7个顶点（包括圆心）// 添加闭合的终点// 课程添加演示：屏蔽177-180行代码，并把绘制节点改为7.则三角形扇形是无法闭合的。nVerts++;vPoints[nVerts][0] = r;vPoints[nVerts][1] = 0;vPoints[nVerts][2] = 0.0f;// 加载！GL_TRIANGLE_FAN 以一个圆心为中心呈扇形排列，共用相邻顶点的一组三角形triangleFanBatch.Begin(GL_TRIANGLE_FAN, 8);triangleFanBatch.CopyVertexData3f(vPoints);triangleFanBatch.End();// 三角形条带，一个小环或圆柱段// 顶点下标int iCounter = 0;// 半径GLfloat radius = 3.0f;// 从0度~360度，以0.3弧度为步长for (GLfloat angle = 0.0f; angle &lt;= (2.0f*M3D_PI); angle += 0.3f) &#123; //或许圆形的顶点的X,Y GLfloat x = radius * sin(angle); GLfloat y = radius * cos(angle); //绘制2个三角形（他们的x,y顶点一样，只是z点不一样） vPoints[iCounter][0] = x; vPoints[iCounter][1] = y; vPoints[iCounter][2] = -0.5; iCounter++; vPoints[iCounter][0] = x; vPoints[iCounter][1] = y; vPoints[iCounter][2] = 0.5; iCounter++;&#125;//结束循环，在循环位置生成2个三角形vPoints[iCounter][0] = vPoints[0][0];vPoints[iCounter][1] = vPoints[0][1];vPoints[iCounter][2] = -0.5;iCounter++;vPoints[iCounter][0] = vPoints[1][0];vPoints[iCounter][1] = vPoints[1][1];vPoints[iCounter][2] = 0.5;iCounter++;// GL_TRIANGLE_STRIP 共用一个条带（strip）上的顶点的一组三角形triangleStripBatch.Begin(GL_TRIANGLE_STRIP, iCounter);triangleStripBatch.CopyVertexData3f(vPoints);triangleStripBatch.End(); 然后在renderSence里面，把对应的批次类draw出来就可以了 123456789// 画点glPointSize(4.0f);pointBatch.Draw();glPointSize(1.0f);// 画三角形glLineWidth(2.0f);lineLoopBatch.Draw();glLineWidth(1.0f); 矩阵堆栈本案例涉及到3个矩阵，视图矩阵（修改观察者位置），模型矩阵（旋转），投影矩阵（透视投影） 这里我们定义两个矩阵堆栈，来计算 12345// 矩阵堆栈，用于设置投影矩阵GLMatrixStack projectionMatrix;// 矩阵堆栈，用于设置视图矩阵，模型矩阵，GLMatrixStack modelViewMatrix; 为了方便计算，我们定义一个变换管道transformPipeline，用于合并2个矩阵堆栈（投影矩阵堆栈projectionMatrix和模型视图矩阵堆栈modelViewMatrix） 12345// 几何变换的管道GLGeometryTransform transformPipeline;// 设置变换管线以使用两个矩阵堆栈transformPipeline.SetMatrixStacks(modelViewMatrix, projectionMatrix); 对于投影矩阵，直接在changeSize的时候配置就可以 1234567// 透视投影GLFrustum viewFrustum;// 设置透视投影viewFrustum.SetPerspective(35.0f, float(w) / float(h), 1.0f, 500.0f);// 重新加载投影矩阵到矩阵堆栈projectionMatrixprojectionMatrix.LoadMatrix(viewFrustum.GetProjectionMatrix()); 接下来我们在renderSence配置模型视图矩阵 12345678910111213141516171819// 加载一个单元矩阵到栈顶modelViewMatrix.LoadIdentity();// 复制一份栈顶矩阵到栈顶modelViewMatrix.PushMatrix();// 获得视图矩阵M3DMatrix44f mCamera;cameraFrame.GetCameraMatrix(mCamera);// 与栈顶矩阵叉乘并覆盖栈顶矩阵modelViewMatrix.MultMatrix(mCamera);// 获得模型矩阵M3DMatrix44f mObjectFrame;objectFrame.GetMatrix(mObjectFrame);// 与栈顶矩阵叉乘并覆盖栈顶矩阵modelViewMatrix.MultMatrix(mObjectFrame); 最终通过变换管道，生成矩阵传递给着色器 12345// 生成最终的矩阵M3DMatrix44f *fMatrix = transformPipeline.GetModelViewProjectionMatrix()// 传给平面着色器处理，vBlack为填充颜色shaderManager.UseStockShader(GLT_SHADER_FLAT, fMatrix, vBlack); 对于几何图形除了直接填充颜色，还需要绘制边框（glPolygonMode） 12345678910111213141516171819202122232425262728// 开启多边形偏移glPolygonOffset(-1.0f, -1.0f);glEnable(GL_POLYGON_OFFSET_LINE);// 开启反锯齿glEnable(GL_LINE_SMOOTH);// 开启混合glEnable(GL_BLEND);// 混合方法glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);// 绘制线框几何黑色版 三种模式，实心，边框，点，可以作用在正面，背面，或者两面//通过调用glPolygonMode将多边形正面或者背面设为线框模式，实现线框渲染glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);//设置线条宽度glLineWidth(2.5f);shaderManager.UseStockShader(GLT_SHADER_FLAT, transformPipeline.GetModelViewProjectionMatrix(), vBlack);pBatch-&gt;Draw();// 复原原本的设置//通过调用glPolygonMode将多边形正面或者背面设为全部填充模式glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);glDisable(GL_POLYGON_OFFSET_LINE);glLineWidth(1.0f);glDisable(GL_BLEND);glDisable(GL_LINE_SMOOTH); 关于矩阵堆栈的操作 矩阵堆栈API 说明 GLMatrixStack::LoadIdentity(void) 在栈顶加载&#x2F;覆盖一个单元矩阵 GLMatrixStack::LoadMatrix(const M3DMatrix44f m) 在栈顶加载&#x2F;覆盖成矩阵m GLMatrixStack::MultMatrix(const M3DMatrix44f m) 矩阵m与栈顶矩阵叉乘，结果覆盖栈顶矩阵 GLMatrixStack::GetMatrix(void) 获取栈顶矩阵 GLMatrixStack::PushMatrix(void) 拷贝栈顶矩阵入栈 GLMatrixStack::PushMatrix(const M3DMatrix44f m) 把矩阵m入栈 GLMatrixStack::PopMatrix(void) 出栈，移出栈顶矩阵 完整代码在这里","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://zhengbomo.github.io/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://zhengbomo.github.io/tags/OpenGL/"}]},{"title":"OpenGL渲染架构","slug":"opengl-render-architecture","date":"2020-07-19T06:16:13.000Z","updated":"2020-07-19T06:16:13.000Z","comments":true,"path":"2020-07-19/opengl-render-architecture/","link":"","permalink":"http://zhengbomo.github.io/2020-07-19/opengl-render-architecture/","excerpt":"本节主要是了解OpenGL是如何把我们的数据（顶点数据和纹理）传递到GPU的，GPU又是如何处理这些数据的","text":"本节主要是了解OpenGL是如何把我们的数据（顶点数据和纹理）传递到GPU的，GPU又是如何处理这些数据的 先来看一张架构图 Client与Server这里的端不同于我们平常开发的客户端服务端 客户端：通常指在CPU存储的代码，负责发送OpenGL命令，比如OpenGLAPI，底层的C&#x2F;C++代码，运行在CPU上服务端：负责接收OpenGL命令并调用GPU芯片执行相应的操作，运行在GPU上 服务器和客户端在功能上也是异步的。客户端不断的把数据块和命令块组合在⼀起输送到缓冲区，然后缓冲区就会发送到服务器执行 数据通道从上面架构图可以看出，从client到server传递的数据有三种 Attributes：属性 Uniforms：渲染矩阵 TextureData：纹理数据 Attributes属性会从客户端内存中复制存储在图形硬件中的一个缓冲区（显存）上，然后会被传递到顶点着色器Vertex Shader，无法直接传递到片元着色器Fragment Shader（但可间接传递到片元着色器），数据有下面类型（这些属性通常是经常变化的） 顶点数据：四维向量（x, y, z, w） 纹理坐标 (图片映射坐标)，实际是通过Vertex Shader传递给Fragment Shader 颜色数据 光照法线 UniformUniform通过既可以传递到顶点着色器，也可以传递到片元着色器，Uniform中传递的通常是比较统一的批次数据，通常用来传递一些不经常发生变动的数据，例如变换矩阵 Texture DataTexture Data同Uniform一样，可以将数据传递到顶点着色器和片元着色器，正如名字一样，主要传递纹理数据，由于顶点着色器主要是处理顶点数据的，我们将纹理数据传过去并没有多大的意义。而纹理的处理的逻辑主要是在片元着色器中进行的。用于对光栅化后的图像填充颜色 着色器• 着色器是使用GLSL编写的程序，看起来与C语言非常类似。着色器必须从源代码中编译和链接在一起。最终准备就绪的着色器程序• 顶点着色器 处理从客户机输入的数据、应用变换、进行其他的类型的数学运算来计算关照效果、位移、颜色值等等。（例如对于三个顶点的三角形渲染，顶点着色器将执行3次，也就是为了每个顶点执行一次）在目前的硬件上有多个执行单元同时运行，处理是并发的• 图元装配：在顶点着色器确定完所有顶点的位置后，根据传入的配置确定图元形状，然后会对三角形逐个片段进行了光栅化处理• 片元着色器 光栅化后的每个片段通过执行片元着色器进行颜色填充 最终会输出我们将屏幕上变成我们最终看到的颜色 设置顶点数据和其他参数。 在顶点着色器中进行运算得到裁剪坐标。 细分着色器、几何着色器，不可自定义，跳过。 图元设置，根据设置构成点、线、三角形。 裁剪，裁剪掉超出显示区域的部分。 光栅化, 将图源栅格化为一个个的像素点。 片元着色器，将对应的栅格(像素)填充为具体的颜色。 渲染图像","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://zhengbomo.github.io/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://zhengbomo.github.io/tags/OpenGL/"}]},{"title":"OpenGL投影、图元和存储着色器","slug":"primitive-shader","date":"2020-07-18T13:01:31.000Z","updated":"2020-07-18T13:01:31.000Z","comments":true,"path":"2020-07-18/primitive-shader/","link":"","permalink":"http://zhengbomo.github.io/2020-07-18/primitive-shader/","excerpt":"投影方式OpenGL有两种投影方式 投影方式 说明 函数 正投影 相同的物体远近看起来都一样大 GLFrustum::SetPerspective(float fFov, float fAspect, float fNear, float fFar) \b透视投影 近大远小 GLFrustum::SetOrthographic(GLfloat xMin, GLfloat xMax, GLfloat yMin, GLfloat yMax, GLfloat zMin, GLfloat zMax)","text":"投影方式OpenGL有两种投影方式 投影方式 说明 函数 正投影 相同的物体远近看起来都一样大 GLFrustum::SetPerspective(float fFov, float fAspect, float fNear, float fFar) \b透视投影 近大远小 GLFrustum::SetOrthographic(GLfloat xMin, GLfloat xMax, GLfloat yMin, GLfloat yMax, GLfloat zMin, GLfloat zMax) 123456789#include &quot;GLFrustum.h&quot;// 投影矩阵GLFrustum viewFrustum;// 设置透视投影viewFrustum.SetPerspective(35.0f, float(w) / float(h), 1.0f, 500.0f);// 获取投影矩阵M3DMatrix44f *projectionMatrix = viewFrustum.GetProjectionMatrix(); 图元装配方式在OpenGL中，相同的顶点可以有不同的装配方式，如下图 图元 描述 GL_POINTS 每个顶点在屏幕上都是单独点 GL_LINES 每⼀对顶点定义⼀个线段 GL_LINE_STRIP 一个从第⼀个顶点依次经过每⼀个后续顶点而绘制的线条 GL_LINE_LOOP 和GL_LINE_STRIP相同，但是最后⼀个顶点和第⼀个顶点连接起来了 GL_TRIANGLES 每3个顶点定义⼀个新的三角形 GL_TRIANGLE_STRIP 共⽤一个条带(strip)上的顶点的一组三⻆形 GL_TRIANGLE_FAN 以⼀个圆点为中⼼呈扇形排列，共⽤相邻顶点的⼀组三⻆形 其中GL_TRIANGLE_STRIP和GL_TRIANGLE_FAN共享三角形的一条边，在绘制大量三角形的时候，可以节省存储空间和提高性能 如 123456789101112131415161718192021222324GLfloat vCoast[] = &#123; 3,3,0, 0,3,0, 3,0,0&#125;;// 三个点pointBatch.Begin(GL_POINTS, 3);pointBatch.CopyVertexData3f(vCoast);pointBatch.End();// 一条线lineBatch.Begin(GL_LINES, 3);lineBatch.CopyVertexData3f(vCoast);lineBatch.End();// 闭合三角形线段lineLoopBatch.Begin(GL_LINE_LOOP, 3);lineLoopBatch.CopyVertexData3f(vCoast);lineLoopBatch.End();// 闭合三角形，可以填充颜色triangleBatch.Begin(GL_TRIANGLES, 3);triangleBatch.CopyVertexData3f(vCoast);triangleBatch.End(); 存储着色器&#x2F;固定管线着色器在使用存储着色器之前需要先进行初始化 12GLShaderManager shaderManager;shaderManager.InitializeStockShaders(); OpenGL内置了很多存储着色器可以使用 单元着色器使⽤场景：绘制默认OpenGL 坐标系(-1,1)下图形。 图形所有片段都会以⼀种颜⾊填充。 1234// 参数1: 存储着⾊器种类-单元着⾊器// 参数2: 颜⾊值GLShaderManager::UserStockShader(GLT_SHADER_IDENTITY, GLfloat vColor[4]); 平面着色器使⽤场景：在绘制图形时, 可以应⽤矩阵变换(模型&#x2F;投影变化)。 123456// 参数1: 存储着⾊器种类-平⾯着⾊器// 参数2: 允许变化的4*4矩阵// 参数3: 颜⾊色值GLShaderManager::UserStockShader(GLT_SHADER_FLAT, GLfloat mvp[16], GLfloat vColor[4]); 上⾊着⾊器使⽤场景：在绘制图形时, 可以应⽤变换(模型&#x2F;投影变化)。颜色将会平滑地插入到顶点之间，称为平滑着色。 1234// 参数1: 存储着⾊器种类-上⾊着⾊器// 参数2: 允许变化的4*4矩阵GLShaderManager::UserStockShader(GLT_SHADER_SHADED, GLfloat mvp[16]); 默认光源着色器使⽤场景：在绘制图形时, 可以应⽤变换(模型&#x2F;投影变化)。这种着⾊器会使绘制的图形产生阴影和光照的效果。 12345678// 参数1: 存储着⾊器种类-默认光源着⾊器// 参数2: 模型4*4矩阵// 参数3: 投影4*4矩阵// 参数4: 颜⾊值GLShaderManager::UserStockShader(GLT_SHADER_DEFAULT_LIGHT, GLfloat mvMatrix[16], GLfloat pMatrix[16], GLfloat vColor[4]); 点光源着⾊器使⽤场景：在绘制图形时, 可以应用变换(模型&#x2F;投影变化)。这种着⾊器会使绘制的图形产⽣阴影和光照的效果。它与默认光源着⾊器⾮常类似，区别只是光源位置可能是特定的。 12345678910// 参数1: 存储着⾊器种类-点光源着⾊器// 参数2: 模型4*4矩阵// 参数3: 投影4*4矩阵// 参数4: 点光源的位置// 参数5: 漫反射颜⾊值GLShaderManager::UserStockShader(GLT_SHADER_POINT_LIGHT_DIFF, GLfloat mvMatrix[16], GLfloat pMatrix[16], GLfloat vLightPos[3], GLfloat vColor[4]); 纹理替换矩阵着⾊器使⽤场景：在绘制图形时, 可以应⽤变换(模型&#x2F;投影变化)。这种着⾊器通过给定的模型视图投影矩阵，使⽤纹理单元来进⾏颜⾊填充。其中每个像素点的颜⾊是从纹理中获取。 123456// 参数1: 存储着⾊器种类-纹理替换矩阵着⾊器// 参数2: 模型4*4矩阵// 参数3: 纹理单元GLShaderManager::UserStockShader(GLT_SHADER_TEXTURE_REPLACE, GLfloat mvMatrix[16], GLint nTextureUnit); 纹理调整着⾊器使⽤场景：在绘制图形时, 可以应⽤变换(模型&#x2F;投影变化)。这种着⾊器通过给定的模型视图投影矩阵。着⾊器将⼀个基本⾊乘以⼀个取⾃纹理单元nTextureUnit 的纹理，将颜⾊与纹理进⾏颜⾊混合后才填充到⽚段中。 12345678// 参数1: 存储着⾊器种类-纹理调整着⾊器// 参数2: 模型4*4矩阵// 参数3: 颜⾊值// 参数4: 纹理单元GLShaderManager::UserStockShader(GLT_SHADER_TEXTURE_MODULATE, GLfloat mvMatrix[16], GLfloat vColor[4], GLint nTextureUnit); 纹理光源着⾊器使⽤用场景：在绘制图形时, 可以应⽤变换(模型&#x2F;投影变化)。这种着⾊器通过给定的模型视图投影矩阵，着⾊器将⼀个纹理通过漫反射照明计算进⾏调整(相乘)。 123456789101112// 参数1: 存储着⾊器种类-纹理光源着⾊器// 参数2: 模型4*4矩阵// 参数3: 投影4*4矩阵// 参数4: 点光源位置// 参数5: 颜⾊值// 参数6: 纹理单元GLShaderManager::UserStockShader(GLT_SHADER_TEXTURE_POINT_LIGHT_DIEF, GLfloat mvMatrix[16], GLfloat pMatrix[16], GLfloat vLightPos[3], GLfloat vBaseColor[4], GLint nTextureUnit); 综合案例图元绘制完整代码见这里","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://zhengbomo.github.io/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://zhengbomo.github.io/tags/OpenGL/"}]},{"title":"OpenGL正背面剔除和深度测试","slug":"opengl-face-culling","date":"2020-07-16T02:29:52.000Z","updated":"2020-07-16T02:29:52.000Z","comments":true,"path":"2020-07-16/opengl-face-culling/","link":"","permalink":"http://zhengbomo.github.io/2020-07-16/opengl-face-culling/","excerpt":"背景当我们在绘制3D图形的时候，由于观察者的角度问题，3D图形拥有多个面，假设所有的面是不透明的，在前面的面是可见的，而背后的面是不可见的，对于不可见的部分，不应该渲染出来，并且出于性能的考虑，应该丢弃（如下面正方体有6个面，而我们能看到的只有三个面），对于下面正方体，面比较少，影响不大，但对于一些复杂的3D图形，影响就比较大了，这种问题称为隐藏面消除/找出可见面（Hidden surface elimination&#x2F;Visible surface detemination）","text":"背景当我们在绘制3D图形的时候，由于观察者的角度问题，3D图形拥有多个面，假设所有的面是不透明的，在前面的面是可见的，而背后的面是不可见的，对于不可见的部分，不应该渲染出来，并且出于性能的考虑，应该丢弃（如下面正方体有6个面，而我们能看到的只有三个面），对于下面正方体，面比较少，影响不大，但对于一些复杂的3D图形，影响就比较大了，这种问题称为隐藏面消除/找出可见面（Hidden surface elimination&#x2F;Visible surface detemination） 解决方案油画算法对于2D的图形，通常采用的是油画算法，远的物体先绘制，近的物体覆盖远的物体 对于3D图形，由于有深度的影响，无法简单分辨物体的远近，如下图，相互交叉的三角形，油画算法将无法处理 正背面剔除（Face Culling）在OpenGL中所有的面都是三角形组成，而所有的平面都有两个面（正面和背面），我们在一个时刻只能看到一个正面。而看不到的背面，OpenGL会检查所有正面朝向观察者的面，并渲染它们，从而丢弃背面朝向的⾯面 在OpenGL规定 正面: 按照逆时针顶点连接顺序的三角形面背面: 按照顺时针顶点连接顺序的三⻆形面 从图中可以看出 左边三角形面相对于观察者是顺时针，所以面向观察者的是背面，右边的三角形面是逆时针，所以面向观察者的是正面，所有右边的三角形面被渲染，而左边的三角形面不会被渲染，如果观察者在左边，则情况会反过来，左边的三角形面被渲染，而右边的三角形面被丢弃。三角形的正面还是背面，是根据观察者的观察方向而变动的。 案例我们通过画一个甜甜圈来看下开启和关闭正背面剔除的区别 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &quot;GLTools.h&quot;#include &quot;GLMatrixStack.h&quot;#include &quot;GLFrame.h&quot;#include &quot;GLFrustum.h&quot;#include &quot;GLGeometryTransform.h&quot;#include &lt;math.h&gt;#ifdef __APPLE__#include &lt;glut/glut.h&gt;#else#define FREEGLUT_STATIC#include &lt;GL/glut.h&gt;#endif////设置角色帧，作为相机GLFrame viewFrame;//使用GLFrustum类来设置透视投影GLFrustum viewFrustum;GLTriangleBatch torusBatch;GLMatrixStack modelViewMatix;GLMatrixStack projectionMatrix;GLGeometryTransform transformPipeline;GLShaderManager shaderManager;// 标记：是否背面剔除int iCull = 1;// 渲染场景void renderScene() &#123; // 1.清除窗口和深度缓冲区 glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // 开启/关闭正背面剔除功能 if (iCull) &#123; glEnable(GL_CULL_FACE); glFrontFace(GL_CCW); glCullFace(GL_BACK); &#125; else &#123; glDisable(GL_CULL_FACE); &#125; // 2.把摄像机矩阵压入模型矩阵中 modelViewMatix.PushMatrix(viewFrame); // 3.设置绘图颜色 GLfloat vRed[] = &#123; 1.0f, 0.0f, 0.0f, 1.0f &#125;; // 使用默认光源着色器 // 通过光源、阴影效果跟提现立体效果 // 参数1：GLT_SHADER_DEFAULT_LIGHT 默认光源着色器 // 参数2：模型视图矩阵 // 参数3：投影矩阵 // 参数4：基本颜色值 shaderManager.UseStockShader(GLT_SHADER_DEFAULT_LIGHT, transformPipeline.GetModelViewMatrix(), transformPipeline.GetProjectionMatrix(), vRed); // 5.绘制 torusBatch.Draw(); // 6.出栈 绘制完成恢复 modelViewMatix.PopMatrix(); // 7.交换缓存区 glutSwapBuffers();&#125;void setupRC() &#123; //1.设置背景颜色 glClearColor(0.3f, 0.3f, 0.3f, 1.0f ); //2.初始化着色器管理器 shaderManager.InitializeStockShaders(); //3.将相机向后移动7个单元：肉眼到物体之间的距离 viewFrame.MoveForward(5); //4.创建一个甜甜圈 //void gltMakeTorus(GLTriangleBatch&amp; torusBatch, GLfloat majorRadius, GLfloat minorRadius, GLint numMajor, GLint numMinor); //参数1：GLTriangleBatch 容器帮助类 //参数2：外边缘半径 //参数3：内边缘半径 //参数4、5：主半径和从半径的细分单元数量 gltMakeTorus(torusBatch, 1.0f, 0.3f, 52, 26); //5.点的大小(方便点填充时,肉眼观察) glPointSize(1.0f);&#125;// 通过键盘↑↓←→修改旋转方向，控制Camera的移动，从而改变视口void specialKeys(int key, int x, int y) &#123; //1.判断方向 if(key == GLUT_KEY_UP) //2.根据方向调整观察者位置 viewFrame.RotateWorld(m3dDegToRad(-5.0), 1.0f, 0.0f, 0.0f); if(key == GLUT_KEY_DOWN) viewFrame.RotateWorld(m3dDegToRad(5.0), 1.0f, 0.0f, 0.0f); if(key == GLUT_KEY_LEFT) viewFrame.RotateWorld(m3dDegToRad(-5.0), 0.0f, 1.0f, 0.0f); if(key == GLUT_KEY_RIGHT) viewFrame.RotateWorld(m3dDegToRad(5.0), 0.0f, 1.0f, 0.0f); // 重新刷新 glutPostRedisplay();&#125;/// 窗口改变void changeSize(int w, int h) &#123; //1.防止h变为0 if(h == 0) &#123; h = 1; &#125; //2.设置视口窗口尺寸 glViewport(0, 0, w, h); //3.setPerspective函数的参数是一个从顶点方向看去的视场角度（用角度值表示） // 设置透视模式，初始化其透视矩阵 viewFrustum.SetPerspective(35.0f, float(w)/float(h), 1.0f, 100.0f); //4.把透视矩阵加载到透视矩阵对阵中 projectionMatrix.LoadMatrix(viewFrustum.GetProjectionMatrix()); //5.初始化渲染管线 transformPipeline.SetMatrixStacks(modelViewMatix, projectionMatrix);&#125;int main(int argc, char* argv[]) &#123; gltSetWorkingDirectory(argv[0]); glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA | GLUT_DEPTH | GLUT_STENCIL); glutInitWindowSize(800, 600); glutCreateWindow(&quot;Geometry Test Program&quot;); glutReshapeFunc(changeSize); glutSpecialFunc(specialKeys); glutDisplayFunc(renderScene); GLenum err = glewInit(); if (GLEW_OK != err) &#123; fprintf(stderr, &quot;GLEW Error: %s\\n&quot;, glewGetErrorString(err)); return 1; &#125; setupRC(); glutMainLoop(); return 0;&#125; 如果不开启正背面剔除，背面的黑色面也会显示出来 在旋转到中间的过程时遇到下面情况 深度测试出现上面缺口的原因是由于，在同一个位置，出现了两个正面，甜甜圈的内环和外环，都有一个正面，OpenGL不知道显示哪一个面，就出现了上面的问题，把内环的面显示出来了，覆盖了外环的面，解决问题之前，先来理解几个概念 深度深度是指OpenGL坐标系中，像素点的Z坐标距观察者的距离 如果观察者在Z轴的正方向，Z值越大则越靠近观察者 如果观察者在Z轴的负方向，Z值越小则越靠近观察者 深度缓冲区（Depth Buffer）深度缓存区是指一块专门内存区域，存储在显存中，用于存储屏幕上所绘制图形的每个像素点的深度值，深度越大，离观察者越远 深度测试在绘制物体的时候，像素点的深度会和之前的深度值做比较，如果 新值 &gt; 旧值，则会被丢弃不绘制，反之，新值会更新到深度缓冲区，新的颜色值同样会更新到颜色缓冲区，这个过程称为深度测试，确保所有绘制的点都是距离观察者最近的 开启和关闭深度测试 123456// 在RenderScene清空完缓冲区后设置// 开启深度测试glEnable(GL_DEPTH_TEST);// 关闭深度测试glDisable(GL_DEPTH_TEST); 相比于正背面剔除，深度测试不仅可以解决正背面显示问题，还能解决上面隐藏面消除的问题 ZFighting闪烁深度测试很好的解决了3D图形层次显示的问题，但是还存在一个误差的问题，开启深度测试后，由于深度缓冲区精度有限制，导致深度值相差很小时，OpenGL出现无法判断的情况，导致出现画面交错闪现的现象，这个问题成为ZFighting闪烁，如下图 其问题产生的主要原因是由于图形靠的太近，导致无法区分出图层先后次序，针对该问题，OpenGL提供了一种多边形偏移（Polygon Offset）方案 12// 开启多边形偏移glEnable(GL_POLYGON_OFFSET_FILL); 多边形偏移枚举值 对应光栅化模式 GL_POLYGON_OFFSET_POINT GL_POINT GL_POLYGON_OFFSET_LINE GL_LINE GL_POLYGON_OFFSET_FILL GL_FILL 使用步骤 123456// 1. 开启多边形偏移glEnable(GL_POLYGON_OFFSET_FILL);// 2. 指定偏移量glPolygonOffset (GLfloat factor, GLfloat units);，参数一般填 -1 和 -1glPolygonOffset (GLfloat factor, GLfloat units);// 3. 关闭多边形偏移glDisable(GL_POLYGON_OFFSET_FILL) 预防ZFighting闪烁 避免两个物体靠的太近：在绘制时，插入一个小偏移 将近裁剪面（设置透视投影时设置）设置的离观察者远一些：提高裁剪范围内的精确度 使用更高位数的深度缓冲区：提高深度缓冲区的精确度","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://zhengbomo.github.io/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://zhengbomo.github.io/tags/OpenGL/"}]},{"title":"iOS离屏渲染原理和优化","slug":"ios-offscreen-render","date":"2020-07-14T02:07:11.000Z","updated":"2020-07-14T02:07:11.000Z","comments":true,"path":"2020-07-14/ios-offscreen-render/","link":"","permalink":"http://zhengbomo.github.io/2020-07-14/ios-offscreen-render/","excerpt":"几乎做iOS开发的人都知道，设置圆角会触发离屏渲染，那么什么情况下设置圆角不会触发离屏渲染呢，为什么会触发离屏渲染。","text":"几乎做iOS开发的人都知道，设置圆角会触发离屏渲染，那么什么情况下设置圆角不会触发离屏渲染呢，为什么会触发离屏渲染。 油画算法计算机图层的叠加绘制大概遵循油画算法，在这种算法下会按层绘制，首先绘制距离较远的场景，然后用绘制距离较近的场景覆盖较远的部分，如下图。 这样就不会导致远的物体挡住近的物体，但是有个局限，就是无法在后面一层渲染完成后，再回去修改前面图层，因为前面的图层已经被覆盖了 离屏渲染对于有前后依赖的图层（如全局剪切，阴影等），油画算法无法满足我们的需求，对于有前后依赖的图层，我们可以再另开辟一个空间，用于临时渲染，渲染完成后再渲染到当前的缓冲区上，这个临时渲染，就是离屏渲染，由于需要开辟一个新的内存空间，并且共享同一个上下文，所以还需要做上下文切换（状态切换），并且渲染完成后还要进行拷贝操作 开辟临时缓存空间 上下文切换，上下文对象比较大，切换操作会带来一定的性能消耗 内存拷贝 额外的渲染（没有进一步考证） 上面4项带来的开销会很大，并且每一帧渲染都需要执行，如果屏幕上触发离屏渲染的操作过多，会导致GPU渲染时间过长造成卡顿，应该避免触发离屏渲染 iOS圆角问题官方文档关于layer.cornerRadius的描述 layer.cornerRadius只作用backgroundColor和border，不会作用于content，支持动画 离屏渲染是GPU无法按油画算法一次性渲染完我们的视图才会触发，我们先来看几个iOS的例子，模拟器打开Color Off-screen Rendered 123456789101112131415161718192021222324252627282930313233343536373839// 1. UIImageViewlet imageView = UIImageView(frame: CGRect(x: 50, y: 100, width: 300, height: 200))self.view.addSubview(imageView)imageView.image = UIImage.init(named: &quot;test.jpg&quot;)// image + cornerRadius + masksToBounds 不会触发离屏渲染imageView.layer.cornerRadius = 10imageView.layer.masksToBounds = true// 触发离屏渲染imageView.backgroundColor = UIColor.green// 添加一个空的UIView不会触发离屏渲染// imageView.addSubview(UIView(frame: CGRect(x: 0, y: 0, width: 10, height: 10)))// 2. UIButtonlet button = UIButton(type: .custom)button.frame = CGRect(x: 50, y: 300 + 50, width: 300, height: 50)self.view.addSubview(button)button.setTitle(&quot;Test&quot;, for: .normal)button.setTitleColor(UIColor.blue, for: .normal)button.layer.cornerRadius = 10button.layer.masksToBounds = true// 触发离屏渲染button.backgroundColor = UIColor.green// 触发离屏渲染button.setBackgroundImage(UIImage(named: &quot;test.jpg&quot;), for: .normal)// 3. UIViewlet view = UIView(frame: CGRect(x: 50, y: 400 + 50, width: 300, height: 50))self.view.addSubview(view)view.backgroundColor = UIColor.redview.layer.cornerRadius = 10view.layer.masksToBounds = true// label如果被渲染，则会触发渲染，如果text为空不会被渲染let label = UILabel(frame: CGRect(x: 10, y: 10, width: 1, height: 1))label.text = &quot;1&quot;view.addSubview(label) 如果设置了cornerRadius+masksToBounds（裁切），并且用于渲染的图层大于1，就会触发离屏渲染，其中如果设置backgroundColor，背景颜色相当于一个单独一个图层，subviews的图层也算，UILabel如果text为空（subviews为空，backgroundColor为空），则不会生成渲染图层 所以设置了cornerRadius+masksToBounds的 UIImageView设置图片不会触发离屏渲染 UIView设置了背景颜色，但不添加subview，不会触发离屏渲染 UILabel设置了文字，并且设置了backgroundColor，会触发离屏渲染 UIButton只设置文字和背景，会触发离屏渲染 优化圆角问题基于上面的问题，我们可以有几个优化方向 避免使用裁切(masksToBounds)操作，如果我们能确保View里面的内容不会溢出，就可以不用masksToBounds 即使要用到裁切的操作，尽量放到子view里面，不要在上层view使用masksToBounds，因为裁切需要对所有的layer和subview所有图层都进行裁切，这样离屏渲染会需要更大的空间，裁切更多的图层，应该只对必要的view&#x2F;layer进行裁切 提前切好需要的圆角，避免渲染的时候再切 其他触发离屏渲染的情况 使用了遮罩的 layer (layer.mask) 需要进行裁剪的 layer (layer.masksToBounds &#x2F; view.clipsToBounds) 设置了组透明度为 YES，并且透明度不为 1 的layer (layer.allowsGroupOpacity &#x2F; layer.opacity) 添加了投影的 layer (layer.shadow)，但如果设置了shadowPath，则系统已经知道如何绘制阴影了，不会触发离屏渲染 采用了光栅化的 layer (layer.shouldRasterize)，光栅化也可以优化离屏渲染问题 绘制了文字的 layer (UILabel, CATextLayer, CoreText等) 毛玻璃在iOS系统中，毛玻璃效果应用的非常广泛，从上面分析也可以知道，这个肯定会触发离屏渲染的，图层之间存在依赖，下面是UIBlurEffect的处理过程 在GPU的渲染过程如下图 GPU在渲染完Content之后，会另外开辟一个Off-screen buffer，执行下面步骤，最后再做合并处理，最后再拷贝回On-screen buffer上","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"}]},{"title":"【OpenGL案例2】正方形键位控制","slug":"opengl-triangle-demo2","date":"2020-07-12T11:40:12.000Z","updated":"2020-07-12T11:40:12.000Z","comments":true,"path":"2020-07-12/opengl-triangle-demo2/","link":"","permalink":"http://zhengbomo.github.io/2020-07-12/opengl-triangle-demo2/","excerpt":"上一篇完成了三角形的绘制，今天来添加一个变换控制，通过键盘的↑↓←→控制图形的移动","text":"上一篇完成了三角形的绘制，今天来添加一个变换控制，通过键盘的↑↓←→控制图形的移动 画正方形基于原来的工程，把三角形改为正方形，GL_TRIANGLES修改为GL_TRIANGLE_FAN 123456789101112131415161718192021// 正方形边长GLfloat blockSize = 0.2f;// 正方形的4个点坐标GLfloat vVerts[] = &#123; -blockSize,-blockSize,0.0f, blockSize,-blockSize,0.0f, blockSize,blockSize,0.0f, -blockSize,blockSize,0.0f&#125;;...// 三角形顶点改为正方形，图元装配改为GL_TRIANGLE_FANvoid setupRC() &#123; ... // 修改为GL_TRIANGLE_FAN ，4个顶点构成四边形 triangleBatch.Begin(GL_TRIANGLE_FAN, 4); triangleBatch.CopyVertexData3f(vVerts); triangleBatch.End();&#125; 平移变换修改坐标平移变换可以直接修改正方形的4个顶点，然后重新刷新 123456789101112131415161718// x轴步长GLfloat xStepSize = 0.025f;// y轴步长GLfloat yStepSize = 0.025f;// 重新生成顶点GLfloat vVerts[] = &#123; -blockSize + xStepSize, -blockSize + yStepSize, 0.0f, blockSize + xStepSize, -blockSize + yStepSize, 0.0f, blockSize + xStepSize, blockSize + yStepSize, 0.0f, -blockSize + xStepSize, blockSize + yStepSize, 0.0f&#125;;// 新的顶点重新设置到批次类中triangleBatch.CopyVertexData3f(vVerts);// 触发重新绘制glutPostRedisplay(); 矩阵变换上面直接通过修改坐标的方式过于麻烦，对于复杂的图形做变换会非常麻烦，而推荐使用矩阵变换，基于平面着色器，可以作用于任何的图形，不需要手动计算坐标，不仅可以做平移，还能做旋转缩放等 renderScene操作流程 清理特定缓存区 根据平移距离生成平移矩阵 如果有多个矩阵变换，通过叉乘得到最终矩阵 将矩阵结果交给存储着色器（平面着色器）中绘制 12345678910111213141516171819202122232425262728293031323334353637// x轴平移距离GLfloat xPos = 0.1f;// y轴平移距离GLfloat yPos = 0.1f;// 旋转(旋转5度)GLfloat rotate = 5.0f;void renderScene(void) &#123; // 清空缓冲区 glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT|GL_STENCIL_BUFFER_BIT); // 定义2个矩阵（平移矩阵，旋转矩阵） M3DMatrix44f mTransfromMatrix, mRotationMartix; // 平移(xPos, yPos) m3dTranslationMatrix44(mTransfromMatrix, xPos, yPos, 0.0f); // 旋转(rotate) m3dRotationMatrix44(mRotationMartix, m3dDegToRad(rotate), 0.0f, 0.0f, 1.0f); // 将旋转和移动的矩阵结果 合并到mFinalTransform （矩阵相乘） M3DMatrix44f mFinalTransform; m3dMatrixMultiply44(mFinalTransform, mTransfromMatrix, mRotationMartix); // 正方形填充颜色 GLfloat vRed[] = &#123;1.0f,0.0f,0.0f,0.0f&#125;; //将矩阵结果 提交给固定着色器（平面着色器）中绘制 shaderManager.UseStockShader(GLT_SHADER_FLAT, mFinalTransform, vRed); // 提交顶点到着色器绘制 triangleBatch.Draw(); //执行交换缓存区 glutSwapBuffers();&#125; 键盘控制GLUT提供了键盘监听事件 12// 注册特殊函数glutSpecialFunc(onSpecialKeys); 实现上下左右键的监听 12345678910111213141516171819202122232425262728293031void SpecialKeys(int key, int x, int y)&#123; if (key == GLUT_KEY_UP) &#123; yPos += stepSize; &#125; if (key == GLUT_KEY_DOWN) &#123; yPos -= stepSize; &#125; if (key == GLUT_KEY_LEFT) &#123; xPos -= stepSize; &#125; if (key == GLUT_KEY_RIGHT) &#123; xPos += stepSize; &#125; // 边缘检测 if (xPos &lt; (-1.0f + blockSize)) &#123; xPos = -1.0f + blockSize; &#125; if (xPos &gt; (1.0f - blockSize)) &#123; xPos = 1.0f - blockSize; &#125; if (yPos &lt; (-1.0f + blockSize)) &#123; yPos = -1.0f + blockSize; &#125; if (yPos &gt; (1.0f - blockSize)) &#123; yPos = 1.0f - blockSize; &#125; // 重新绘制 glutPostRedisplay();&#125; 完整代码见这里","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://zhengbomo.github.io/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://zhengbomo.github.io/tags/OpenGL/"}]},{"title":"【OpenGL案例1】绘制一个三角形","slug":"opengl-triangle-demo","date":"2020-07-11T13:42:13.000Z","updated":"2020-07-11T13:42:13.000Z","comments":true,"path":"2020-07-11/opengl-triangle-demo/","link":"","permalink":"http://zhengbomo.github.io/2020-07-11/opengl-triangle-demo/","excerpt":"通过使用OpenGL绘制一个三角形，了解OpenGL的一些常用API和绘制流程，这里使用了GLUT（OpenGL Utility Toolkit）的API，GLUT是OpenGL官方提供的OpenGL工具箱，封装了一些有用的工具，用于辅助操作OpenGL","text":"通过使用OpenGL绘制一个三角形，了解OpenGL的一些常用API和绘制流程，这里使用了GLUT（OpenGL Utility Toolkit）的API，GLUT是OpenGL官方提供的OpenGL工具箱，封装了一些有用的工具，用于辅助操作OpenGL 工具API本案例也使用GLUT工具进行绘制，使用最基本的固定着色器来绘制，本案例会用到下面几个头文件 头文件 说明 GLShaderManager.h 着色器管理类，用于创建和管理着色器，还提供一组内置的存储着色器（固定管线着色器） GLTools.h 包含大部分类似C语⾔的独⽴函数 GLUT.h OpenGL工具箱 相关函数这里会注册两个函数用于绘制 renderSence: 类似于iOS的类似于drawRect，每次View需要重新绘制的时候，会被调用 changeSize: 窗口大小变化的时候被调用，通常用于调整glview的视口 定义两个变量用于管理着色器和顶点数据 12345678#include &quot;GLShaderManager.h&quot;#include &quot;GLTools.h&quot;#include &lt;GLUT/GLUT.h&gt;// 定义一个，着色管理器GLShaderManager shaderManager;// 简单的批次容器，用于将顶点数据提交给着色器使用GLBatch triangleBatch; main程序启动的时候，我们需要做一些初始化操作 初始化glutInit 初始化双缓冲区，颜色模式，深度，模板 设置窗口信息（大小，标题） 注册生命周期函数：renderSence和changeSize 测试驱动可用性: 通过glewInit结果判断 初始化渲染数据setupRC 开启事件循环 12345678910111213141516171819202122232425262728293031323334353637int main(int argc,char *argv[]) &#123; //初始化GLUT库,这个函数只是传说命令参数并且初始化glut库 glutInit(&amp;argc, argv); /* 初始化双缓冲窗口，其中标志GLUT_DOUBLE、GLUT_RGBA、GLUT_DEPTH、GLUT_STENCIL分别指 双缓冲窗口、RGBA颜色模式、深度测试、模板缓冲区 --GLUT_DOUBLE`：双缓存窗口，是指绘图命令实际上是离屏缓存区执行的，然后迅速转换成窗口视图，这种方式，经常用来生成动画效果； --GLUT_DEPTH`：标志将一个深度缓存区分配为显示的一部分，因此我们能够执行深度测试； --GLUT_STENCIL`：确保我们也会有一个可用的模板缓存区。 深度、模板测试后面会细致讲到 */ glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGBA|GLUT_DEPTH|GLUT_STENCIL); //GLUT窗口大小、窗口标题 glutInitWindowSize(800, 600); glutCreateWindow(&quot;Triangle&quot;); // 注册窗口改变事件 glutReshapeFunc(changeSize); // 注册显示函数，当需要重新绘制的时候，会调用 glutDisplayFunc(renderScene); // 初始化一个GLEW库，测试是否报错，确保OpenGL API对程序完全可用。 GLenum status = glewInit(); if (GLEW_OK != status) &#123; printf(&quot;GLEW Error:%s\\n&quot;,glewGetErrorString(status)); return 1; &#125; // 准备我们需要渲染的数据 setupRC(); // 开启事件循环，相当于iOS的runloop glutMainLoop(); return 0;&#125; setupRC我们要画一个三角形，可以在这里做一些准备工作 设置清屏颜色 初始化着色器 初始化顶点数据 12345678910111213141516171819void setupRC() &#123; // 设置清屏颜色（背景颜色，白色） glClearColor(1.0f, 1.0f, 1.0f, 1.0f); // 没有着色器，在OpenGL 核心框架中是无法进行任何渲染的。这里初始化一个渲染管理器，在renderSence会用到。这里使用固定管线着色器 shaderManager.InitializeStockShaders(); // 三角形顶点 GLfloat vVerts[] = &#123; -0.5f,0.0f,0.0f, 0.5f,0.0f,0.0f, 0.0f,0.5f,0.0f &#125;; // 将顶点数据传递到三角形批次类中 triangleBatch.Begin(GL_TRIANGLES, 3); triangleBatch.CopyVertexData3f(vVerts); triangleBatch.End();&#125; 这里triangleBatch在Begin的时候设置了一个图元装配方式为GL_TRIANGLES，在OpenGL中，相同的顶点可以有不同的装配方式，如下图 图元 描述 GL_POINTS 每个顶点在屏幕上都是单独点 GL_LINES 每⼀对顶点定义⼀个线段 GL_LINE_STRIP 一个从第⼀个顶点依次经过每⼀个后续顶点而绘制的线条 GL_LINE_LOOP 和GL_LINE_STRIP相同，但是最后⼀个顶点和第⼀个顶点连接起来了 GL_TRIANGLES 每3个顶点定义⼀个新的三角形 GL_TRIANGLE_STRIP 共⽤一个条带(strip)上的顶点的一组三⻆形 GL_TRIANGLE_FAN 以⼀个圆点为中⼼呈扇形排列，共⽤相邻顶点的⼀组三⻆形 renderSence准备好数据之后，就可以开始绘制了，核心代码在之前注册的renderSence里面 清空缓冲区（颜色缓冲区，深度缓冲区，模板缓冲区），避免脏数据 使用着色器填充颜色 批次类将顶点数据提交到着色器上绘制 12345678910111213141516void RenderScene(void) &#123; // 1.清除一个或者一组特定的缓存区，如果后面需要用到这些缓冲区，就需要清空，不然会出现之前使用的脏数据（如深度缓冲区，颜色缓冲区，模板缓冲区等） glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT|GL_STENCIL_BUFFER_BIT); // 2.设置一个颜色用来填充三角形 GLfloat vRed[] = &#123;1.0, 0.0, 0.0, 1.0f&#125;; // 3. 使用单元着色器，来对图形进行着色，即GLT_SHADER_IDENTITY着色器，这个着色器只是使用指定颜色以默认笛卡尔坐标第在屏幕上渲染几何图形 shaderManager.UseStockShader(GLT_SHADER_IDENTITY, vRed); // 4. 提交顶点数据到着色器，进行绘制 triangleBatch.Draw(); // 在开始的设置openGL 窗口的时候，我们指定要一个双缓冲区的渲染环境。这就意味着将在后台缓冲区进行渲染，渲染结束后交换给前台。 glutSwapBuffers();&#125; changeSize当窗口大小改变的时候，我们需要重新调整视口大小 1234void changeSize(int w,int h) &#123; // x,y 参数代表窗口中视图的左下角坐标，而宽度、高度是像素为表示，通常x,y 都是为0 glViewport(0, 0, w, h);&#125; 运行 完整demo在这里","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://zhengbomo.github.io/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://zhengbomo.github.io/tags/OpenGL/"}]},{"title":"iOS图像渲染原理解析","slug":"ios-render","date":"2020-07-10T13:33:03.000Z","updated":"2020-07-10T13:33:03.000Z","comments":true,"path":"2020-07-10/ios-render/","link":"","permalink":"http://zhengbomo.github.io/2020-07-10/ios-render/","excerpt":"CPU和GPU 从图中结构可以看出 CPU的处理单元少，由控制器和缓存单元，擅长处理复杂的逻辑以及数据结构，CPU中的并行其实是通过时间切片完成的。任务之间依赖性高，擅长逻辑控制 GPU是由许多计算单元组成，每个计算单元可以独立工作，任务之间依赖性低，擅长浮点运算，擅长并发计算","text":"CPU和GPU 从图中结构可以看出 CPU的处理单元少，由控制器和缓存单元，擅长处理复杂的逻辑以及数据结构，CPU中的并行其实是通过时间切片完成的。任务之间依赖性高，擅长逻辑控制 GPU是由许多计算单元组成，每个计算单元可以独立工作，任务之间依赖性低，擅长浮点运算，擅长并发计算 计算机渲染原理⾼级光栅扫描显示系统结构 屏幕扫描视频控制器/显示控制器从帧缓冲区中读取图像信息（位图），经过数模转换（数字信号处-&gt;模拟型号）后通过逐行扫描把图像显示到显示器上的 撕裂问题显示一个完整画面是需要一定时间的，视频控制器在显示图像的过程中，如果这时候帧缓冲区的数据被刷新了，就会造成撕裂的问题，上面部分显示前面一帧的数据，下面部分为新的数据 双缓冲区和垂直同步为了解决撕裂，苹果引入了垂直同步（VSync） + 双缓存区（DoubleBuffering）来解决撕裂的问题（苹果使用的就是这个策略） 垂直同步Vsync：每隔1&#x2F;60s就会发出一个信号，让GPU开始渲染图像，而这个时间间隔足够视频控制器显示图像了，App启动后，会在Runloop注册对应的CFRunLoopSource，通过mach_port，接受来自系统的Vsync事件（实际上是由硬件发出的，每秒钟发60次），CADisplayLink也是同样的原理 双缓存区 DoubleBuffering，使用两个帧缓冲区，视频控制器使用的帧缓冲区和GPU使用的分开，避免视频控制器正在使用的缓冲区被修改，避免撕裂问题，在GPU把帧数据写到帧缓冲区后，会和视频控制器使用的帧缓冲区进行交换，然后等待下一帧的渲染 掉帧上面解决了撕裂的问题，但是还有一个掉帧的问题，如下图 当CPU和GPU渲染图像的时间过长，在下一个垂直同步信号来的时候，GPU并没有处理完一帧的数据，帧缓冲区也就没有交换，视频控制器就会显示原来缓冲区的内容 三缓冲区从上图可以看出，CPU和GPU是在垂直同步信号到来的时候才开始渲染的工作，为了减少掉帧的情况，引入了三缓冲区 A：显示到屏幕B：提前渲染号C：正在渲染 其实相当于预加载，充分利用CPU和GPU的空闲时间，提前渲染好一帧B（同时也会带来画面延迟，当然1帧的延迟是可以接受的），多留出了一帧的时间，即使在渲染C的时候出现了一次掉帧，依然能刘畅渲染，这种情况大大减小了掉帧的可能 但如果渲染C的时间过长（掉多帧），依然会带来掉帧的问题，三缓冲区本质上并不解决掉帧的问题，只是缓解 为了解决掉帧的问题，我们只能尽可能优化我们的代码，减少CPU和GPU的渲染时间 iOS的渲染框架渲染框架 可以看到在iOS中的CoreGraphics, CoreAnimation, CoreImage都是通过OpenGL&#x2F;Metal进行渲染的，我们的App也可以使用OpenGL&#x2F;Metal来操作GPU进行渲染 CoreAnimation 渲染流⽔线 CoreAnimation会在Runloop注册一个Observer监听触摸事件，当点击事件到来的时候，Runloop会被唤醒处理相关的业务逻辑（UIView的创建，修改，添加动画等） 最终会在CALayer通过CATransaction提交到RenderServer中，RenderServer会对图片进行解码，并等待下一个VSync的到来 VSync信号到来后，RenderService会通过OpenGL&#x2F;Metal做一些绘制操作，然后把处理完的数据（纹理，顶点，着色器等）提交给GPU GPU通过下面渲染流程程（顶点数据-&gt;顶点着⾊器-&gt;⽚元着⾊器），渲染到帧缓冲区，然后交换帧缓冲区（双缓冲区） 下一个VSync信号到来的时候，视频控制器读取帧缓冲区的数据显示到屏幕上 如果此处有动画，CoreAnimation会通过DisplayLink等机制多次触发相关流程 渲染流程 CPU阶段 布局（Frame）: layoutSubviews, addSubview 显示（Core Graphics）: drawRect, 绘制字符串 准备（QuartzCore&#x2F;Core Animation）：图片decode 提交：通过IPC提交(打包好的layers以及动画属性)给OpenGL&#x2F;Metal，递归提交subview的layers OpenGL ES/Metal阶段，主要是对图层进行取色，采样，生成纹理，绑定数据，生成前后帧缓存，为GPU渲染做准备 生成(Generate) 绑定(Bind) 缓存数据(Buffer Data) 启用(Enable) 设置指针(Set Pointers) 绘图(Draw) 清除(Delete) GPU阶段 接收提交的纹理（Texture）和顶点描述（三角形） 应用变换（transform） 合并渲染（离屏渲染等） 参考 iOS界面渲染流程分析","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"},{"name":"OpenGL","slug":"OpenGL","permalink":"http://zhengbomo.github.io/tags/OpenGL/"}]},{"title":"理解flutter中的Key","slug":"flutter-key","date":"2020-07-04T01:22:15.000Z","updated":"2023-06-11T03:02:51.868Z","comments":true,"path":"2020-07-04/flutter-key/","link":"","permalink":"http://zhengbomo.github.io/2020-07-04/flutter-key/","excerpt":"我们知道，flutter有三颗树，widget树在每次setState的时候都会重建，而element树不会，而是会通过diff算法，计算出哪些element需要重建，哪些element可以重用，我们通过一个例子来开始","text":"我们知道，flutter有三颗树，widget树在每次setState的时候都会重建，而element树不会，而是会通过diff算法，计算出哪些element需要重建，哪些element可以重用，我们通过一个例子来开始 例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import &#x27;dart:math&#x27;;import &#x27;package:flutter/material.dart&#x27;;class HomePage extends StatefulWidget &#123; @override _HomePageState createState() =&gt; _HomePageState();&#125;final _random = Random();class _HomePageState extends State&lt;HomePage&gt; &#123; var _items = [ ListItem(title: &quot;aaa&quot;), ListItem(title: &quot;bbb&quot;), ListItem(title: &quot;ccc&quot;), ]; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(&quot;key demo&quot;), ), body: Row( mainAxisAlignment: MainAxisAlignment.center, children: _items, ), floatingActionButton: FloatingActionButton( child: Icon(Icons.add), onPressed: () &#123; // 删除第一个元素 _items.removeAt(0); setState(() &#123;&#125;); &#125;, ), ); &#125;&#125;/// 定义一个itemclass ListItem extends StatelessWidget &#123; final String title; // color放在widget final Color color = Color.fromARGB( 255, _random.nextInt(256), _random.nextInt(256), _random.nextInt(256)); ListItem(&#123;this.title&#125;); @override Widget build(BuildContext context) &#123; return Container( alignment: Alignment.center, child: Text( this.title, style: TextStyle(color: Colors.white, fontSize: 20), ), color: this.color, width: 100, height: 100, ); &#125;&#125; 运行正常，接下来我们把ListItem换成stateful 123456789101112131415161718192021222324252627class ListItem extends StatefulWidget &#123; final String title; ListItem(&#123;this.title&#125;); @override _ListItemState createState() =&gt; _ListItemState();&#125;class _ListItemState extends State&lt;ListItem&gt; &#123; // color放在state final Color color = Color.fromARGB( 255, _random.nextInt(256), _random.nextInt(256), _random.nextInt(256)); @override Widget build(BuildContext context) &#123; return Container( alignment: Alignment.center, child: Text( widget.title, style: TextStyle(color: Colors.white, fontSize: 20), ), color: this.color, width: 100, height: 100, ); &#125;&#125; 从上图可以看出，颜色和文字混了，这是由于element树判断增量更新重用element导致的 当widget重建的时候，element通过对比新旧两个widget是否需要更新，从而判断是否重用，默认的逻辑是对比runtimeType和key，我们上面的例子中显然会返回true（我们没有定义key），则表示可以element可以直接使用新的widget 1234static bool canUpdate(Widget oldWidget, Widget newWidget) &#123; return oldWidget.runtimeType == newWidget.runtimeType &amp;&amp; oldWidget.key == newWidget.key;&#125; 由于颜色是state持有的，没有变化，所以蓝色的element，直接使用了灰色的widget，而最后一个绿色的element，没有用到，会被释放 通过canUpdate方法可以看到，我们可以设置key来标识element是否可以直接更新widget，flutter中的key有两种 LocalKey GlobalKey LocalKeyLocalKey有下面三种，其成员key用于比较，使用起来类似 ValueKey: 使用一个泛型数据作为key ObjectKey: 使用一个对象作为key UniqueKey: 自动生成key，并且保证唯一，比较少用 123456789101112131415// 在StatefulWidget构造方法添加参数key，并传给superclass ListItem extends StatefulWidget &#123; final String title; ListItem(&#123;this.title, Key key&#125;) : super(key: key); @override _ListItemState createState() =&gt; _ListItemState();&#125;// 使用ListItem的时候，传入keyvar _items = [ ListItem(title: &quot;aaa&quot;, key: ValueKey&lt;String&gt;(&quot;aaa&quot;)), ListItem(title: &quot;bbb&quot;, key: ValueKey&lt;String&gt;(&quot;bbb&quot;)), ListItem(title: &quot;ccc&quot;, key: ValueKey&lt;String&gt;(&quot;ccc&quot;)),]; 这样在判断的时候不同的ListItem会在canUpdate方法就会返回false，就不会重用了 通常我们在自定义StatefulWidget的时候，需要在构造函数添加可选参数key GlobalKeyGlobalKey可以获取到context（element），widget，和state，通常用于在父widget操作子widget 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import &#x27;package:flutter/material.dart&#x27;;class HomePage extends StatelessWidget &#123; final GlobalKey&lt;_TestWidgetState&gt; _globalKey = GlobalKey(); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(&quot;global key&quot;), ), body: Center( child: TestWidget( key: _globalKey, )), floatingActionButton: FloatingActionButton( child: Icon(Icons.add), onPressed: () &#123; // 直接操作子widget的state _globalKey.currentState.increseCount(); &#125;, ), ); &#125;&#125;class TestWidget extends StatefulWidget &#123; TestWidget(&#123;Key key&#125;) : super(key: key); @override _TestWidgetState createState() =&gt; _TestWidgetState();&#125;class _TestWidgetState extends State&lt;TestWidget&gt; &#123; int _count = 0; increseCount() &#123; setState(() &#123; _count = _count + 1; &#125;); &#125; @override Widget build(BuildContext context) &#123; return Text(&quot;$_count&quot;); &#125;&#125;","categories":[{"name":"flutter","slug":"flutter","permalink":"http://zhengbomo.github.io/categories/flutter/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"http://zhengbomo.github.io/tags/flutter/"},{"name":"key","slug":"key","permalink":"http://zhengbomo.github.io/tags/key/"}]},{"title":"OpenGL名词解释","slug":"opengl-words","date":"2020-07-01T12:27:18.000Z","updated":"2023-06-11T03:02:51.868Z","comments":true,"path":"2020-07-01/opengl-words/","link":"","permalink":"http://zhengbomo.github.io/2020-07-01/opengl-words/","excerpt":"为了更好的学习 OpenGL，我们需要对部分专业属于有一些基本认识，本文介绍在计算机图形学常用的一些专业名词","text":"为了更好的学习 OpenGL，我们需要对部分专业属于有一些基本认识，本文介绍在计算机图形学常用的一些专业名词 图形APIOpenGL（Open Graphics Library）是⼀个跨编程语⾔、跨平台的编程图形程序接⼝，它将计算机的资源抽象称为⼀个OpenGL的对象，对这些资源的操作抽象为⼀个个的OpenGL指令 OpenGL ES（OpenGL for Embedded Systems）是OpenGL的API子集，针对⼿机、PDA和游戏主机等嵌⼊式设备⽽设计，去除了许多不必要和性能较低的API接⼝ DirectX是Windows平台的多媒体处理工具，包含图形API，功能比较多，按性质分类，可以分为四⼤部分，显示部分、声⾳部分、输⼊部分和⽹络部分 Metal是Apple为游戏开发者推出了新的平台技术，苹果宣称该技术能够为 3D 图像提⾼ 10 倍的渲染性能，是Apple为了解决3D渲染⽽推出的框架 图形API的作用图形API用于实现图形的底层渲染，最终输出到显示屏上，例如，图形从点线面，再到3D图形，最终渲染称屏幕上看到的2D图像这个过程 ⽐如在游戏开发中,对于游戏场景&#x2F;游戏⼈物的渲染 ⽐如在⾳视频开发中,对于视频解码后的数据渲染 ⽐如在地图引擎,对于地图上的数据渲染 ⽐如在动画中,实现动画的绘制 ⽐如在视频处理中,对于视频加上滤镜效果 OpenGL &#x2F;OpenGL ES&#x2F; Metal 在任何项⽬中解决问题的本质就是利⽤GPU芯⽚来⾼效渲染图形图像，开发者可以通过这些图形API间接利用GPU OpenGL只是协议层，而具体的实现是由硬件厂商完成的，不同厂商实现上有差异，通常都是高度优化过的 OpenGL上下⽂（Context）在使用OpenGL操作之前，需要先创建一个OpenGL上下文，这是一个状态机，保存了各种用于描述OpenGL如何运行的状态，例如拍照的时候开启滤镜等，上下文是OpenGL所有操作的基础 OpenGL API是面向过程的，本质上是对OpenGL上下文状态机的某个状态或对象进行操作 应用程序中可以创建多个不同的上下文，他们分别在各自的线程中使用。上下文之间共享纹理，缓冲区等资源，采用这中方案更为高效，因为它避免了反复切换上下文，或者大量修改渲染状态所造成的较大的开销。 iOS中的CoreGraphics里面的API就与OpenGL的API有些类似，面向过程 假设当我们想告诉OpenGL去画线段而不是三角形的时候，我们通过改变一些上下文变量来改变OpenGL状态，从而告诉OpenGL如何去绘图。一旦我们改变了OpenGL的状态为绘制线段，下一个绘制命令就会画出线段而不是三角形。 上下文OpenGL指令执⾏的基础，所有绘制操作都需要通过上下文进行 OpenGL上下文对象切换操作开销大 OpenGL的函数虽然是面向过程的，但可以把相关的调用封装为面向过程的图形API。 OpenGL状态机状态机描述了⼀个对象在其⽣命周期内的各种状态变化，和响应事件，体现在代码中就是上下文 有状态，能保存当前的状态 有输⼊和输出，根据输⼊的内容和⾃⼰的原先状态，修改⾃⼰当前状态，并且可以有对应输出 能关闭，当进⼊特殊状态（停机状态）的时候，就不再接收输⼊，停⽌⼯作 渲染（Rendering）将图形&#x2F;图像数据转换成3D空间图像操作，从图元到图像的过程 图元图元可以理解为组成图形的基本单元，比如点、线、三角形。 我们可以通过一系列函数或顶点数据帮助我们实现多种多样的图形 在OpenGL ES有三种图元：点，线，三角形，其他所有图形都是由这三种图形组合而成的 顶点数组和顶点缓冲区（VertexArray &amp; VertexBuffer）顶点数组用于描述图形的轮廓（如三个顶点可以描述一个三角形），图元是由顶点组成的，顶点数组通常存放在显存上（性能更高），而这部分内存称为顶点缓冲区 管线在OpenGL下渲染图形,就会有经历⼀个⼀个节点步骤，⽽这样的操作可以理解管线。管线是⼀个抽象的概念，之所以称之为管线是因为显卡在处理数据的时候是按照⼀个固定的顺序来的，⽽且严格按照这个顺序。就像⽔从⼀根管⼦的⼀端流到另⼀端，这个顺序固定的，不能修改 固定管线在早期的OpenGL版本中，封装了很多API，用于完成特定的功能，例如光照，坐标变换，裁切等，这些API被称为固定管线，而对于一些特殊需求的场景，固定管线无法实现，这部分可以通过可编程管线来实现 固定管线在实际开发中用的少，大多已经废弃，基本都是通过编程来实现需求 着⾊器程序（Shader）将固定渲染管线架构变为可编程渲染管线 OpenGL在实际调⽤绘制函数之前，还需要指定⼀个由shader编译成的着⾊器程序。常⻅的着⾊器主要有 顶点着⾊器（VertexShader） ⽚段着⾊器&#x2F;像素着⾊器（FragmentShader&#x2F;PixelShader） ⼏何着⾊器（GeometryShader） 曲⾯细分着⾊器（TessellationShader）。 OpenGL ES只⽀持了顶点着⾊器和⽚段着⾊器两个着⾊器 着色器程序处理流程 OpenGL在处理shader时，和其他编译器⼀样。通过编译、链接等步骤，⽣成了着⾊器程序（glProgram），着⾊器程序同时包含了顶点着⾊器和⽚段着⾊器的运算逻辑 在OpenGL进⾏绘制的时候，⾸先由顶点着⾊器对传⼊的顶点数据进⾏运算。再通过图元装配，将顶点转换为图元 然后进⾏光栅化，将图元这种⽮量图形，转换为栅格化数据 将栅格化数据传⼊⽚段着⾊器中进⾏运算。⽚段着⾊器会对栅格化数据中的每⼀个像素进⾏运算，并决定像素的颜⾊ 顶点着⾊器（VertexShader） ⼀般⽤来处理图形每个顶点变换(旋转&#x2F;平移&#x2F;投影等)，顶点坐标由⾃身坐标系转换到归⼀化坐标系的运算 顶点着⾊器是OpenGL中⽤于计算顶点属性的程序。顶点着⾊器是逐顶点运算的程序，这个过程是并⾏的，并且顶点着⾊器运算过程中⽆法访问其他顶点的数据 过程 确定位置 缩放&#x2F;平移&#x2F;旋转位置换算 3D图形数据-&gt;2D(投影换算) ⽚段着⾊器&#x2F;片元着色器（FragmentShader） ⼀般⽤来处理图形中每个像素点颜⾊计算和填充 ⽚段着⾊器是OpenGL中⽤于计算⽚段（像素）颜⾊的程序。⽚段着⾊器是逐像素运算的程序，也就是说每个像素都会执⾏⼀次⽚段着⾊器，也是并⾏的 GLSL（OpenGL Shading Language）GLSL是OpenGL着⾊语⾔，是⽤来在OpenGL中着⾊编程的语⾔，运行在GPU上，代替了固定的渲染管线的⼀部分，⽐如：视图转换、投影转换等。GLSL（GL Shading Language）的着⾊器代码分成2个部分： Vertex Shader（顶点着⾊器） Fragment Shader（⽚断着⾊器&#x2F;片元着色器） 光栅化（Rasterization）栅格化或者像素化，就是把矢量图形转化成像素点的过程，该过程包含了两部分的工作 决定窗口坐标中的哪些整型栅格区域被基本图元占用 分配一个颜色值和一个深度值到各个区域。光栅化过程产生的是片元。 纹理（Texture）纹理可以理解为图⽚，在OpenGL习惯叫纹理 混合（Blending）不同图层进行颜色混合，例如组透明度（例如将两个图层（透明度0.2的红色图层和透明度0.5的绿色图层）混合叠加在一起，这个过程就叫做混合），OpenGL提供的默认的混合算法混合算法，如果需要更加复杂的混合算法，⼀般可以通过像素着⾊器进⾏实现，当然性能会⽐原⽣的混合算法差⼀些 变换矩阵（Transformation）用于对图形进行平移，缩放，旋转变换操作时使用 投影矩阵（Projection）⽤于将3D坐标转换为⼆维屏幕坐标时使用 渲染上屏&#x2F;交换缓冲区(SwapBuffer) 渲染缓冲区⼀般映射的是系统的资源⽐如窗⼝。如果将图像直接渲染到窗⼝对应的渲染缓冲区，则可以将图像显示到屏幕上。 但是，如果每个窗⼝只有⼀个缓冲区，那么在绘制过程中屏幕进⾏了刷新，窗⼝可能显示出不完整的图像，前后两次绘制重叠 为了解决这个问题，常规的OpenGL程序⾄少都会有两个缓冲区。显示在屏幕上的称为屏幕缓冲区，没有显示的称为离屏缓冲区。在⼀个缓冲区渲染完成之后，通过将屏幕缓冲区和离屏缓冲区交换，实现图像在屏幕上的显示，就是双缓冲 由于显示器的刷新⼀般是逐⾏进⾏的，因此为了防⽌交换缓冲区的时候屏幕上下区域的图像分属于两个不同的帧，因此交换⼀般会等待显示器刷新完成的信号，在显示器两次刷新的间隔中进⾏交换，这个信号就被称为垂直同步信号（VSync），这个技术被称为垂直同步 使⽤了双缓冲区和垂直同步技术之后，由于总是要等待缓冲区交换之后再进⾏下⼀帧的渲染，使得帧率⽆法完全达到硬件允许的最⾼⽔平。为了解决这个问题，引⼊了三缓冲区技术，在等待垂直同步时，来回交替渲染两个离屏的缓冲区，⽽垂直同步发⽣时，屏幕缓冲区和最近渲染完成的离屏缓冲区交换，实现充分利⽤硬件性能的⽬的","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://zhengbomo.github.io/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://zhengbomo.github.io/tags/OpenGL/"}]},{"title":"flutter仿微信聊天交互","slug":"flutter-chat-listview","date":"2020-06-30T00:16:15.000Z","updated":"2020-06-30T00:16:15.000Z","comments":true,"path":"2020-06-30/flutter-chat-listview/","link":"","permalink":"http://zhengbomo.github.io/2020-06-30/flutter-chat-listview/","excerpt":"最近在做一个聊天的页面，参考微信的聊天页面，对ListView有下面几个需求 使用列表Widget，例如：ListView, CustomScrollView等 支持scrollToEnd，当键盘，表情面板，工具面板弹出时，消息滑动到底部 支持获取位置用于跳转getCurrentIndexInfo，用于保持加载数据时候的位置不变 支持jumpToIndex和scrollToIndex，避免手动计算位置 滑动位置要准确，没有误差 滑动到底部不会出现bounce 由于键盘上移的时候scrollToEnd","text":"最近在做一个聊天的页面，参考微信的聊天页面，对ListView有下面几个需求 使用列表Widget，例如：ListView, CustomScrollView等 支持scrollToEnd，当键盘，表情面板，工具面板弹出时，消息滑动到底部 支持获取位置用于跳转getCurrentIndexInfo，用于保持加载数据时候的位置不变 支持jumpToIndex和scrollToIndex，避免手动计算位置 滑动位置要准确，没有误差 滑动到底部不会出现bounce 由于键盘上移的时候scrollToEnd scrollToEnd以ListView为例，网上推荐的做法是 12345678/// 滑动到底部void _scrollToEnd() &#123; final offset = _scrollController.position.maxScrollExtent; _scrollController.animateTo(offset, duration: Duration(milliseconds: 250), curve: Curves.easeInOut );&#125; 但上面做法存在一个问题，就是误差，当内容是高度可变的时候就会有误差，如下面例子 1234567891011121314151617181920212223242526272829303132final _random = Random();class _TestPageState extends State&lt;TestPage&gt; &#123; List&lt;double&gt; _items = List.generate(180, (index) =&gt; _random.nextInt(100) + 100.0); ScrollController _scrollController = ScrollController(); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(&quot;scrollToEnd&quot;), actions: &lt;Widget&gt;[ IconButton( icon: Icon(Icons.add), onPressed: _scrollToEnd, ), ], ), body: ListView.builder( controller: _scrollController, itemBuilder: (c, i) &#123; return Container( margin: EdgeInsets.all(8), height: _items[i], color: Colors.orange, child: Text(&quot;$i&quot;), ); &#125;, itemCount: _items.length), ); &#125;&#125; 存在问题从截图中可以看到，maxScrollExtent有时候偏小，有时候偏大，如果是偏大的情况，scrollView在scroll到屏幕外后再反弹（bounce的效果），这是由于ListView在渲染的时候，没出现在屏幕的Widget是不会被渲染的，这个时候还不能确定所有Widget的实际高度，ScrollView会根据当前渲染的Widget估算其他Widget的高度，所以带来误差，而如果widget是等高的，则不会有误差问题 如果能scrollToIndex应该可以解决问题，直接滑动到某一项 scrollToIndex自带的ScrollController不支持scrollToIndex，找到下面2个第三方库，支持scrollToIndex，两个库都可以精确滑动到对应的位置 scroll_to_index: 通过分段滑动，边滑动边计算，在滑动的过程中可以得到widget的高度，达到scrollToIndex的目的 scrollable_positioned_list 对于滚动列表进行extendCache，缓存多两个屏幕的widget 为了计算位置，我们知道滚动到第0项，位置肯定是准的，也就是offset=0，scrollable_positioned_list用一个辅助的列表做滚动位置，让滚动的目标为0，这样就可以避免计算的误差 保持缓存区间所有Widget的位置信息，当目标位置在当前列表的缓存区间的时候，直接scrollToOffset，否则，使用辅助列表配合滚动，两个列表都只缓存开始和结束位置的widget，而不需要计算中间的widget，当列表增大时，不会带来太大的性能消耗 存在问题 scroll_to_index: 由于是采用多次滚动的方式，对于数据量大的话滑动会持续时间比较长，而且看起来非常不顺滑，抖动厉害，性能消耗比较大 scrollable_positioned_list: 当滑动到底部（最后一个项）的时候，他会把index项滑动到0的位置再回弹，会出现bounce bounce问题基于上面问题，考虑对scrollable_positioned_list滑动之前添加溢出检查，避免溢出造成bounce，具体代码见这里 scrollable_positioned_list默认使用相对位置alignment，这里改为offset 12345678910111213141516171819202122232425262728293031323334// 这里去掉了alignment，改用offsetvoid _jumpTo(&#123;@required int index, double offset&#125;) &#123; cancelScrollCallback?.call(); final controller = _showFrontList ? frontScrollController : backScrollController; final lastTarget = _showFrontList ? frontTarget : backTarget; // 方向 final direction = index &gt; lastTarget ? 1 : -1; // 更新index setState(() &#123; if (lastTarget != index) &#123; if (_showFrontList) &#123; frontTarget = index; &#125; else &#123; backTarget = index; &#125; &#125; &#125;); // 加上偏移量offset var jumpOffset = 0 + offset; if (direction == -1) &#123; controller.jumpTo(jumpOffset); &#125; else &#123; controller.jumpTo(jumpOffset); // 渲染后如果发现溢出，马上修正 WidgetsBinding.instance.addPostFrameCallback((timeStamp) &#123; var offset = min(jumpOffset, controller.position.maxScrollExtent); if (controller.offset != offset) &#123; controller.jumpTo(offset); &#125; &#125;); &#125;&#125; 对于scrollToIndex 12345678910111213141516171819202122232425262728293031323334353637383940414243444546...if (itemPosition != null) &#123; // 不用切换列表 final localScrollAmount = itemPosition.itemLeadingEdge * startingScrollController.position.viewportDimension; var animateOffset = startingScrollController.offset + localScrollAmount - offset; // 添加溢出check animateOffset = min(animateOffset, startingScrollController.position.maxScrollExtent); await startingScrollController.animateTo(animateOffset, duration: duration, curve: curve);&#125; else &#123; // 需要切换两个列表 ... startAnimationCallback = () &#123; SchedulerBinding.instance.addPostFrameCallback((_) async &#123; frontOpacity.parent = _opacityAnimation(startingListDisplay).animate( AnimationController(vsync: this, duration: duration)..forward()); startAnimationCallback = () &#123;&#125;; var endJump = -direction * (_screenScrollCount * startingScrollController.position.viewportDimension - offset); var startScroll = startingScrollController.offset + direction * scrollAmount; endingScrollController.jumpTo(endJump); // 修正位置，避免溢出 var endScroll = min( 0.0 + offset, endingScrollController.position.maxScrollExtent); endScroll = max(endScroll, endingScrollController.position.minScrollExtent); endCompleter.complete(endingScrollController.animateTo(endScroll, duration: duration, curve: curve)); startCompleter.complete(startingScrollController .animateTo(startScroll, duration: duration, curve: curve)); cancelScrollCallback = () =&gt; _cancelScroll(startingListDisplay); &#125;); &#125;; ...&#125; 获取index位置当列表滑动到顶部的时候，需要加载上一页的聊天数据，我们希望加载数据后刷新页面，用户所在的位置不变（不要跳动），可以保留当前位置，在刷新后更新位置 1234567891011121314151617181920212223242526272829// 第一个为index，第二个为offsetList&lt;dynamic&gt; _getCurrentIndexInfo(bool wholeVisible) &#123; final controller = _showFrontList ? frontScrollController : backScrollController; final notifier = _showFrontList ? frontItemPositionNotifier : backItemPositionNotifier; /// 获取viewport上元素的Position信息 var visibleItems = notifier.itemPositions.value.where((i) &#123; if (wholeVisible) &#123; return i.itemLeadingEdge &gt;= 0 &amp;&amp; i.itemTrailingEdge &lt;= 1; &#125; else &#123; return i.itemTrailingEdge &gt; 0 &amp;&amp; i.itemLeadingEdge &lt; 1; &#125; &#125;); /// 取最小index ItemPosition firstVisibleItem = visibleItems.fold(null, (v, i) &#123; if (v == null) &#123; return i; &#125; else if (i.index &lt; v.index) &#123; return i; &#125; else &#123; return v; &#125; &#125;); // 计算偏移量 var offset = controller.position.viewportDimension * firstVisibleItem.itemLeadingEdge; return [firstVisibleItem.index, offset];&#125; 键盘处理键盘弹出的时候，我们希望ChatBar是动画上移的，并且listview需要scrollToEnd，Scaffold有个属性resizeToAvoidBottomInset用于控制键盘弹出时的内容区域，但是没有动画，直接变化看起来非常突兀，这里关掉了这个属性，我们自己来控制键盘弹出时的UI变化 1234Scaffold( resizeToAvoidBottomInset: false, ...) 如果使用动画修改ListView的高度，则无法和scrollToEnd配合起来，应为scrollToEnd无法根据动画一致滚动，这样性能上会比较差，这里采用占位的方式，键盘弹出的时候，不修改ListView的高度，而是在ListView底部添加一个占位item，修改这个占位item高度（不需要动画），然后scrollToEnd，这个滚动可以做到平滑，另外ChatBar键盘弹出时添加上动画即可 仿写微信项目在这里","categories":[{"name":"flutter","slug":"flutter","permalink":"http://zhengbomo.github.io/categories/flutter/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"http://zhengbomo.github.io/tags/flutter/"}]},{"title":"iOS性能优化","slug":"ios-performance","date":"2020-06-19T00:37:40.000Z","updated":"2020-06-19T00:37:40.000Z","comments":true,"path":"2020-06-19/ios-performance/","link":"","permalink":"http://zhengbomo.github.io/2020-06-19/ios-performance/","excerpt":"性能优化是一个开发者不可避开的话题，本文讨论iOS的性能体现在以下几个方面 CPU占用率 内存占用率 卡顿监控&#x2F;FPS GPU离屏渲染 耗电监控 启动时间","text":"性能优化是一个开发者不可避开的话题，本文讨论iOS的性能体现在以下几个方面 CPU占用率 内存占用率 卡顿监控&#x2F;FPS GPU离屏渲染 耗电监控 启动时间 CPU占用率CPU占用率是测试性能的其中一个指标，CPU作为手机最重要的组成部分，所有计算都是通过CPU进行，手机上耗电最大的应该就是CPU了，如果我们的App设计不当，会出现 界面卡顿 电量消耗过快 手机发热发烫 Xcode可以直接看到App的内存占用，我们也可以通过系统方法获取到CPU占用率 1234567891011121314151617181920212223242526272829303132333435363738394041424344#import &lt;mach/task.h&gt;#import &lt;mach/vm_map.h&gt;#import &lt;mach/mach_init.h&gt;#import &lt;mach/thread_act.h&gt;#import &lt;mach/thread_info.h&gt;...+ (double)getCpuUsage &#123; kern_return_t kr; thread_array_t threadList; // 保存当前Mach task的线程列表 mach_msg_type_number_t threadCount; // 保存当前Mach task的线程个数 thread_info_data_t threadInfo; // 保存单个线程的信息列表 mach_msg_type_number_t threadInfoCount; // 保存当前线程的信息列表大小 thread_basic_info_t threadBasicInfo; // 线程的基本信息 // 通过“task_threads”API调用获取指定 task 的线程列表 // mach_task_self_，表示获取当前的 Mach task kr = task_threads(mach_task_self(), &amp;threadList, &amp;threadCount); if (kr != KERN_SUCCESS) &#123; return -1; &#125; double cpuUsage = 0; for (int i = 0; i &lt; threadCount; i++) &#123; threadInfoCount = THREAD_INFO_MAX; // 通过“thread_info”API调用来查询指定线程的信息 // flavor参数传的是THREAD_BASIC_INFO，使用这个类型会返回线程的基本信息， // 定义在 thread_basic_info_t 结构体，包含了用户和系统的运行时间、运行状态和调度优先级等 kr = thread_info(threadList[i], THREAD_BASIC_INFO, (thread_info_t)threadInfo, &amp;threadInfoCount); if (kr != KERN_SUCCESS) &#123; return -1; &#125; threadBasicInfo = (thread_basic_info_t)threadInfo; if (!(threadBasicInfo-&gt;flags &amp; TH_FLAGS_IDLE)) &#123; cpuUsage += threadBasicInfo-&gt;cpu_usage; &#125; &#125; // 回收内存，防止内存泄漏 vm_deallocate(mach_task_self(), (vm_offset_t)threadList, threadCount * sizeof(thread_t)); return cpuUsage / (double)TH_USAGE_SCALE * 100.0;&#125; 内存占用率常见的内存问题是内存泄露，内存只增不减，严重时，造成OOM被系统杀掉，在iOS开发中常见的是循环引用，对于大内存的对象（例如图片）在不需要的时候应该及时释放，避免内存长期占用，内存泄露还可能带来一些业务上的问题 123456789+ (double)getMemoryUsage &#123; task_vm_info_data_t vmInfo; mach_msg_type_number_t count = TASK_VM_INFO_COUNT; if(task_info(mach_task_self(), TASK_VM_INFO, (task_info_t) &amp;vmInfo, &amp;count) == KERN_SUCCESS) &#123; return (double)vmInfo.phys_footprint / (1024 * 1024); &#125; else &#123; return -1.0; &#125;&#125; 卡顿屏幕控制器，根据屏幕刷新率，每隔一段时间就会发送一个屏幕垂直信号VSync，在VSync到来的时候 CPU计算图层树布局，图片解码，文字渲染，然后交给GPU GPU渲染图层树，然后放到屏幕缓冲区上 下一个VSync到来的时候，如果CPU或GPU消耗的时间过长，GPU还来不及渲染到缓冲区中，视频控制器从屏幕缓冲区读不到数据，就会导致掉帧卡顿 FPSFPS是卡顿的监控指标，FPS如果能稳定在50-60帧，基本可以认为是流畅的，通常我们通过CADisplayLink来监听页面刷新率，可以参考这里 1234// 每秒回调一次let fps = FPS &#123; fps in print(&quot;当前帧率为\\(fps)fps&quot;)&#125; RunloopFPS只是一个宏观的指标，而对于开发者来说，除了知道FPS，我们是希望定位到卡顿的位置，这个时候我们可以通过监听Runloop事件循环来实现，当发现卡顿的时候，获取主线程的调用堆栈，能获得卡顿的函数 卡顿监控还可以通过监听Runloop事件来实现，具体可以参考这里 12345// 开启监控FluencyMonitor.shared.start()// 关闭监控FluencyMonitor.shared.stop() 出现卡顿时输出 12345678910111213141516171819202122230 libsystem_c.dylib 0x00007fff51aed510 usleep + 531 Demo 0x000000010fab7479 Demo.ViewController.tableView(_: __C.UITableView, cellForRowAt: Foundation.IndexPath) -&gt; __C.UITableViewCell + 11932 Demo 0x000000010fab7545 @objc Demo.ViewController.tableView(_: __C.UITableView, cellForRowAt: Foundation.IndexPath) -&gt; __C.UITableViewCell + 1653 UIKitCore 0x00007fff48ea3f1a -[UITableView _createPreparedCellForGlobalRow:withIndexPath:willDisplay:] + 8674 UIKitCore 0x00007fff48e6d5a6 -[UITableView _updateVisibleCellsNow:] + 30105 UIKitCore 0x00007fff48e8d2d2 -[UITableView layoutSubviews] + 1946 UIKitCore 0x00007fff49193678 -[UIView(CALayerDelegate) layoutSublayersOfLayer:] + 24787 QuartzCore 0x00007fff2b4c6398 -[CALayer layoutSublayers] + 2558 QuartzCore 0x00007fff2b4cc523 _ZN2CA5Layer16layout_if_neededEPNS_11TransactionE + 5239 QuartzCore 0x00007fff2b4d7bba _ZN2CA5Layer28layout_and_display_if_neededEPNS_11TransactionE + 8010 QuartzCore 0x00007fff2b420c04 _ZN2CA7Context18commit_transactionEPNS_11TransactionEd + 32411 QuartzCore 0x00007fff2b4545ef _ZN2CA11Transaction6commitEv + 64912 QuartzCore 0x00007fff2b381645 _ZN2CA7Display11DisplayLink14dispatch_itemsEyyy + 92113 QuartzCore 0x00007fff2b4588f0 _ZL22display_timer_callbackP12__CFMachPortPvlS1_ + 29914 CoreFoundation 0x00007fff23d6187d __CFMachPortPerform + 15715 CoreFoundation 0x00007fff23da14e9 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__ + 4116 CoreFoundation 0x00007fff23da0ae8 __CFRunLoopDoSource1 + 47217 CoreFoundation 0x00007fff23d9b514 __CFRunLoopRun + 222818 CoreFoundation 0x00007fff23d9a944 CFRunLoopRunSpecific + 40419 GraphicsServices 0x00007fff38ba6c1a GSEventRunModal + 13920 UIKitCore 0x00007fff48c8b9ec UIApplicationMain + 160521 Demo 0x000000010fabaf4b main + 7522 libdyld.dylib 0x00007fff51a231fd start + 1 离屏渲染（Offscreen Rrendering）这里只讨论GPU上的离屏渲染 离屏渲染是屏幕缓冲区外的渲染 GPU渲染图层是一层一层渲染的，下面的图层先渲染，上面的图层后渲染 GPU渲染图层时，当上面的图层渲染时，不能再去修改下面图层的 所以当遇到superlayer依赖sublayer的时候，例如阴影（依赖sublayer的形状），就无法直接渲染到屏幕缓冲区，这个时候，GPU就会在内存中另外开辟一个缓冲区，用于渲染阴影，渲染完成后再放回到屏幕缓冲区，这个渲染操作称为离屏渲染 GPU渲染的时候，只有一个上下文，当出现离屏渲染的时候，需要进行上下文的切换，由于上下文对象比较大，这个成本会比较高，开辟内存空间也需要消耗性能，离屏渲染多了就会导致每一帧渲染时间过长，造成卡顿 由于物理限制，某些场景下离屏渲染是不可避免，我们可以通过一些手段避免 在iOS上，下面操作会导致离屏渲染 圆角（masksToBounds+cornerRadius），在iOS9之后，UIImageView使用masksToBounds+cornerRadius不会触发离屏渲染，其他View仍然会，避免两个属性组合使用，例如图片在内存中切好后再放到View上，对于不需要背景透明的地方，可以放一张图片罩着实现圆角 光栅化（shouldRasterize）：会触发离屏渲染，并且会缓存结果，避免每一帧都触发离屏渲染，可以用于优化离屏渲染 遮罩（masks）：尽量减少使用 阴影（shadow）：如果设置了shadowPath，则不会触发离屏渲染 抗锯齿（allowsEdgeAntialiasing）：默认关闭抗锯齿，开启会触发离屏渲染 组透明度（allowsGroupOpacity）: 默认开启，可以关闭来避免离屏渲染 卡顿优化卡顿优化方向主要是减少CPU和GPU的处理时间 CPU优化 使用CALayer代替UIView，不用响应事件的View设置isUserInteractionEnabled = true 不要频繁地修改UIView的位置，和变换属性，比如frame、bounds、transform等 对于复杂的布局，尽量提前计算好布局，并且使用缓存，集中计算，不要频繁改动 Autolayout会比直接设置frame消耗更多的CPU资源，对于复杂的布局，使用frame替代autolayout 图片的size最好刚好跟UIImageView的size保持一致，或者不要差太多 减少一下线程的最大并发数量 尽量把耗时的操作放到子线程（文本处理，图片编解码） GPU优化 尽量减少视图数量和嵌套层次 GPU能处理的最大纹理尺寸是4096x4096，一旦超过这个尺寸，就会占用CPU资源进行处理，所以纹理尽量不要超过这个尺寸 尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张图片显示 减少透明的视图（alpha&lt;1），不透明的就设置opaque为yes，减少颜色混合操作 尽量避免出现离屏渲染 耗电优化 优化代码逻辑，减少不必要的计算 减少使用定时器 I&#x2F;O 避免频繁的I&#x2F;O操作，考虑批量操作 数据量比较大的局部读写，建议使用数据库，数据库对局部读写有专门的优化 对于读写比较大的文件数据的时候，可以考虑使用dispatch_io，使用GCD异步并行读写，速度更快 网络 大文件使用断点续传，减少重复传输 及时cancel掉不使用的网络请求（如当离开ViewController的时候，cancel在ViewController中产生的异步请求） 使用缓存，避免重复请求 压缩数据 定位 如果只是需要快速确定用户位置，用CLLocationManager.requestLocation方法。定位完成后，会自动让定位硬件断电 如果不是导航应用，尽量不要实时更新位置，定位完毕就关掉定位服务 尽量降低定位精度，比如尽量不要使用精度最高的kCLLocationAccuracyBest 需要后台定位时，尽量设置pausesLocationUpdatesAutomatically = true，系统会根据情况自动暂停位置更新 硬件检测优化用户移动、摇晃、倾斜设备时，会产生动作(motion)事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件 做到用到的时候才申请，用完就关闭 启动优化iOS应用的启动可以分为三个阶段 dyld: 加载可执行文件，递归加载依赖库，符号绑定 减少动态库 去掉不用的类，方法和分类，减少数量 Swift优先使用Struct（结构体分配在栈上，不需要动态管理内存，性能优） runtime: 初始化OC的类，category，load方法，C++静态初始化器，__attribute__((constructor)) 减少load方法 main 只初始化必要的方法，能延后执行的延后执行，按需加载 二进制重排 参考链接 https://zhuanlan.zhihu.com/p/72653360","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"}]},{"title":"Flutter禁用水波纹","slug":"flutter-disable-ripple","date":"2020-06-12T14:49:19.000Z","updated":"2020-06-12T14:49:19.000Z","comments":true,"path":"2020-06-12/flutter-disable-ripple/","link":"","permalink":"http://zhengbomo.github.io/2020-06-12/flutter-disable-ripple/","excerpt":"在做Flutter开发的时候，通常我们都使用MaterialApp来开发，最典型的样式就是点击会有水波纹效果，但有时候我们不希望有水波纹效果，例如在iOS上，使用TextFiled的时候禁用水波纹效果，让体验看起来更像原生","text":"在做Flutter开发的时候，通常我们都使用MaterialApp来开发，最典型的样式就是点击会有水波纹效果，但有时候我们不希望有水波纹效果，例如在iOS上，使用TextFiled的时候禁用水波纹效果，让体验看起来更像原生 搜索了一番，没有特别好的方法，基本上是修改splashColor，感觉不够彻底，于是从源码入手看下，我们知道水波纹效果的Widget为InkWell 1234InkWell( onTap: () &#123;&#125;, child: Text(&quot;button&quot;)) InkWell继承自InkResponse，在_InkResponseState中的方法_handleTapDown可以看到，在点击的时候会开启splash 123456void _handleTapDown(TapDownDetails details) &#123; _startSplash(details: details); if (widget.onTapDown != null) &#123; widget.onTapDown(details); &#125;&#125; 在_startSplash创建了InteractiveInkFeature对象splash 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455void _startSplash(&#123;TapDownDetails details, BuildContext context&#125;) &#123; assert(details != null || context != null); Offset globalPosition; if (context != null) &#123; final RenderBox referenceBox = context.findRenderObject() as RenderBox; assert(referenceBox.hasSize, &#x27;InkResponse must be done with layout before starting a splash.&#x27;); globalPosition = referenceBox.localToGlobal(referenceBox.paintBounds.center); &#125; else &#123; globalPosition = details.globalPosition; &#125; final InteractiveInkFeature splash = _createInkFeature(globalPosition); _splashes ??= HashSet&lt;InteractiveInkFeature&gt;(); _splashes.add(splash); _currentSplash = splash; updateKeepAlive(); updateHighlight(_HighlightType.pressed, value: true);&#125;InteractiveInkFeature _createInkFeature(Offset globalPosition) &#123; final MaterialInkController inkController = Material.of(context); final RenderBox referenceBox = context.findRenderObject() as RenderBox; final Offset position = referenceBox.globalToLocal(globalPosition); final Color color = widget.splashColor ?? Theme.of(context).splashColor; final RectCallback rectCallback = widget.containedInkWell ? widget.getRectCallback(referenceBox) : null; final BorderRadius borderRadius = widget.borderRadius; final ShapeBorder customBorder = widget.customBorder; InteractiveInkFeature splash; void onRemoved() &#123; if (_splashes != null) &#123; assert(_splashes.contains(splash)); _splashes.remove(splash); if (_currentSplash == splash) _currentSplash = null; updateKeepAlive(); &#125; // else we&#x27;re probably in deactivate() &#125; splash = (widget.splashFactory ?? Theme.of(context).splashFactory).create( controller: inkController, referenceBox: referenceBox, position: position, color: color, containedInkWell: widget.containedInkWell, rectCallback: rectCallback, radius: widget.radius, borderRadius: borderRadius, customBorder: customBorder, onRemoved: onRemoved, textDirection: Directionality.of(context), ); return splash; &#125; 该类为抽象类，看名字像是水波纹的实现，主要逻辑就在这里面，InkResponse通过自身属性或从主题中取到Theme.of(context).splashFactory，然后创建InteractiveInkFeature，我们把主题中的factory换成自己实现一个没有水波纹的InteractiveInkFeature对象，就可以间接的关闭掉水波纹的效果了 123456789101112131415161718192021222324import &#x27;package:flutter/material.dart&#x27;;// 空水纹实现工厂class NoSplashFactory extends InteractiveInkFeatureFactory &#123; @override InteractiveInkFeature create(&#123;required MaterialInkController controller, required RenderBox referenceBox, required Offset position, required Color color, required TextDirection textDirection, bool containedInkWell = false, RectCallback? rectCallback, BorderRadius? borderRadius, ShapeBorder? customBorder, double? radius, VoidCallback? onRemoved&#125;) &#123; return _NoInteractiveInkFeature(controller: controller, referenceBox: referenceBox, color: color, onRemoved: onRemoved); &#125;&#125;// // InkFeature空实现class _NoInteractiveInkFeature extends InteractiveInkFeature &#123; @override void paintFeature(Canvas canvas, Matrix4 transform) &#123; &#125; _NoInteractiveInkFeature(&#123; required MaterialInkController controller, required RenderBox referenceBox, required Color color, VoidCallback? onRemoved, &#125;) : super(controller: controller, referenceBox: referenceBox, color: color, onRemoved: onRemoved);&#125; 把widget包到Theme中 123456789Theme( data: ThemeData( splashFactory: Shares.noInkFeatureFactory ), child: FlatButton( child: Text(&quot;点击了&quot;), onPressed: () &#123;&#125;, ),) 默认还有点击背景，如果需要把点击的背景也去掉，highlightedColor设置为透明即可 1234ThemeData( splashFactory: Shares.noInkFeatureFactory, highlightColor: Colors.transparent,) 放到NavigationBottomTabBar 1234567891011121314Scaffold( bottomNavigationBar: Theme( data: ThemeData( // 去掉水波纹效果 splashFactory: Shares.noInkFeatureFactory, // 去掉点击效果 highlightColor: Colors.transparent, ), child: BottomNavigationBar( ... ) ) ...)","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://zhengbomo.github.io/categories/Flutter/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"http://zhengbomo.github.io/tags/flutter/"}]},{"title":"Flutter异步编程","slug":"flutter-thread","date":"2020-06-10T00:54:11.000Z","updated":"2023-06-11T03:02:51.867Z","comments":true,"path":"2020-06-10/flutter-thread/","link":"","permalink":"http://zhengbomo.github.io/2020-06-10/flutter-thread/","excerpt":"Flutter是基于Dart语言，而Dart是单线程语言，通常情况下，任务都在主线程（这里的主线程不同于Native的主线程）里面执行","text":"Flutter是基于Dart语言，而Dart是单线程语言，通常情况下，任务都在主线程（这里的主线程不同于Native的主线程）里面执行 事件循环（event loop）和iOS的Runloop类似，Dart中的线程也使用事件循环和消息队列的方式执行任务，在Dart中，线程叫做isolate，而这个更像是进程的概念（不同的isolate不共享状态，不存在锁的问题，并且通过port进行通信） 应用程序启动后，执行main函数，然后会开始运行main isolate，每个isolate都有两个事件队列，分别是event queue和microtask queue，有点类似iOS中的sourcd0, source1，micro queue优先级高于event queue，只有microtask queu为空时，才会执行event queue event queue: 负责处理I&#x2F;O事件，手势，Timer，绘制，其他外部事件（如通过Future添加的事件） microtask queue: 负责处理优先级更高的事件 由于microtask queue会优先执行，为了避免渲染，和手势处理的延迟，对于复杂的计算，不应该放在microtask queue里面，应该放到event queue，而对于相对比较耗时的计算，应该考虑放到其他isolate运行（多线程），避免界面卡顿 12345678910111213141516171819void testFuture() async &#123; // 将任务放到事件队列，默认使用异步 Future(()&#123; print(&quot;Future event 1&quot;); &#125;); // 同步执行，不会放入队列 Future.sync(() &#123; print(&quot;Future sync microtask event 2&quot;); &#125;); // 将任务放到微任务队列 Future.microtask(()&#123; print(&quot;microtask event&quot;); &#125;);&#125;testFuture();// 执行完成testFuture后，event1和micro event会被放到队列里面print(&quot;testFuture()执行完了&quot;);// 执行完了之后，开始从队列取出任务执行 上面代码输出 1234Future sync microtask event 2testFuture()执行完了microtask eventFuture event 1 Futureawait, asyncawait和async用于等待Future完成，并且不会阻塞当前执行 await: 作用于Future对象，用于异步等待Future&lt;T&gt;完成，并且返回T async: 作用于方法，与await配合使用，用于声明方法需要等待 123456789101112131415161718Future&lt;String&gt; dataReqeust() &#123; return Future&lt;String&gt;(() &#123; print(&quot;request begin&quot;); print(&quot;request end&quot;); return &quot;data&quot;; &#125;);&#125;Future&lt;String&gt; loadData() async &#123; var data = await dataReqeust(); return data; &#125;void main() async &#123; var data = await loadData(); print(data); print(&quot;testFuture()执行完了&quot;);&#125; 输出 1234request beginrequest enddatatestFuture()执行完了 由于Dart是单线程的，如果创建一个耗时的Future，则可能会导致后面的任务延后执行 async和await的本质是协程(coroutine)的语法糖，协程可以让单线程支持异步调度的，减少进程调度带来的开销 then, catchError, whenComplete then: 在Future执行完成后立即调用 catchError: 在Future执行过程中，出现异常时调用（throw error） whenComplete: 当Future完成（包括抛出异常）都会走到这个方法 上面三个方法都会返回一个Future，Dart会把任务放到回调队列里面，返回值又可以视为一个新的Future当调用上面三个方法，这时候Dart会把方法注册到zone中的回调方法里面，而如果这时候Future已经执行完了，那么方法会被放到microtask queu里面） 123456789101112131415161718192021222324252627282930313233void testFuture() async &#123; Future x1 = Future(() &#123; // throw &quot;error&quot;; return 10; &#125;); x1.then((value) &#123; // 如果x1没有抛出异常，会先走到这里 print(&#x27;2&#x27;); &#125;).then((v) &#123; // 在上一个then执行完后，走到这里 print(&#x27;3&#x27;); &#125;).catchError((e) &#123; // 在x1抛出异常时，走到这里 print(&quot;4&quot;); &#125;).whenComplete(()&#123; // 当then3或catchError执行完后走到这里 print(&quot;5&quot;); &#125;).then((v) &#123; // whenComplete执行完后走到这里 print(&#x27;6&#x27;); throw &quot;error2&quot;; &#125;).catchError((e) &#123; // 当上一个then抛出异常的时，走到这里 print(&quot;7&quot;); &#125;); // 执行 print(&#x27;1&#x27;);&#125;void main() &#123; testFuture(); print(&quot;testFuture()执行完了&quot;);&#125; 输出 12345671testFuture()执行完了23567 结合microtask queue 1234567891011121314151617181920void testFuture() async &#123; Future x1 = Future(() =&gt; null); x1.then((value) &#123; print(&#x27;6&#x27;); Future.microtask(() =&gt; print(&#x27;7&#x27;)); &#125;).then((value) =&gt; print(&#x27;8&#x27;)); Future x = Future(() =&gt; print(&#x27;1&#x27;)); x.then((value) &#123; print(&#x27;4&#x27;); Future(() =&gt; print(&#x27;9&#x27;)); &#125;).then((value) =&gt; print(&#x27;10&#x27;)); Future(() =&gt; print(&#x27;2&#x27;)); Future.microtask(() =&gt; print(&#x27;3&#x27;)); print(&#x27;5&#x27;);&#125;testFuture();print(&quot;testFuture()执行完了&quot;); 输出 12345678910115testFuture()执行完了3687141029 IsolateIsolate是dart的进程模型，有独立的存储空间，独立的运行环境，不像线程可以直接共享内存状态，基于port通信，除了main isolate，其他isolate不支持UI相关的操作，通常用于计算密集型的任务，这里说的进程指的是在Dart环境下的进程，不是平台的进程，从平台的角度来看还是线程 12345678910111213141516171819202122232425262728293031323334import &#x27;dart:isolate&#x27;;// 子进程任务void func(List&lt;dynamic&gt; argument) &#123; SendPort send = argument[0]; int value = argument[1]; print(&#x27;进入子进程任务!!，收到参数 $value&#x27;); // 向端口发送数据 send.send(1000);&#125;void testIsolate() async &#123; // 创建端口 ReceivePort port = ReceivePort(); // 参数 int value = 10; //创建isolate Isolate iso = await Isolate.spawn(func, [port.sendPort, value]); port.listen((message) &#123; print(&quot;收到子进程的消息：$message&quot;); // 关闭端口 port.close(); // 杀死iso进程 iso.kill(); &#125;);&#125;void main() &#123; testIsolate();&#125; dart提供了一个方法compute封装了一个方法，可以使用Future很方便的执行，内部是对isolate的封装 123456789101112131415161718192021222324import &#x27;package:flutter/foundation.dart&#x27;;int func2(int v) &#123; print(&quot;子进程收到参数：$v&quot;); print(&quot;子进程执行耗时操作&quot;); var sum = 0; for (int i = 0; i &lt; 9999999; i++) &#123; sum = i; &#125; return sum;&#125;void computeTest() async &#123; print(&#x27;外部代码1&#x27;); // 这里需要使用外部方法，不能使用匿名函数，不能使用闭包 var result = await compute(func2, 10); print(&quot;执行完成：$result&quot;); print(&#x27;外部代码2&#x27;);&#125;void main() async &#123; computeTest();&#125; 输出 12345flutter: 外部代码1flutter: 子进程收到参数：10flutter: 子进程执行耗时操作flutter: 执行完成：9999998flutter: 外部代码2 参考链接 深入理解Flutter多线程","categories":[{"name":"flutter","slug":"flutter","permalink":"http://zhengbomo.github.io/categories/flutter/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"http://zhengbomo.github.io/tags/flutter/"}]},{"title":"flutter_boost混编实践","slug":"flutter-boost-integration","date":"2020-06-07T02:15:43.000Z","updated":"2020-06-07T02:15:43.000Z","comments":true,"path":"2020-06-07/flutter-boost-integration/","link":"","permalink":"http://zhengbomo.github.io/2020-06-07/flutter-boost-integration/","excerpt":"基于现有的项目接入flutter，官方提供的一个比较完整的接入方案，但是存在一个问题，由于FlutterEngine很重，而多个FlutterViewController共享一个Engine，并且同一时间下，一个engine只能与一个viewcontroller绑定，在管理起来，特别是对于多层跳转（native-&gt;flutter-&gt;native-&gt;flutter）非常麻烦，而如果创建多个FlutterEngine，就会带来很大的开销，导致内存暴涨，而flutter_boost提供了像WebView的方式操作FlutterViewController，可以存在多个FlutterViewController，这里基于一个现有的demo继承flutter_boost并解决侧滑手势冲突的问题","text":"基于现有的项目接入flutter，官方提供的一个比较完整的接入方案，但是存在一个问题，由于FlutterEngine很重，而多个FlutterViewController共享一个Engine，并且同一时间下，一个engine只能与一个viewcontroller绑定，在管理起来，特别是对于多层跳转（native-&gt;flutter-&gt;native-&gt;flutter）非常麻烦，而如果创建多个FlutterEngine，就会带来很大的开销，导致内存暴涨，而flutter_boost提供了像WebView的方式操作FlutterViewController，可以存在多个FlutterViewController，这里基于一个现有的demo继承flutter_boost并解决侧滑手势冲突的问题 环境配置官方的流程的教程很详细，这里简单说明 创建flutter模块（这里取为my_flutter） 12cd some/path/flutter create --template module my_flutter 从原来的项目的Podfile添加引用 1234567891011121314151617181920source &#x27;https://github.com/CocoaPods/Specs.git&#x27;platform:ios,&#x27;10.0&#x27;# 不用动态库，动态库多了影响启动速度# use_frameworks!use_modular_headers!inhibit_all_warnings!# 加上flutter脚本flutter_application_path = &#x27;../my_flutter&#x27;load File.join(flutter_application_path, &#x27;.ios&#x27;, &#x27;Flutter&#x27;, &#x27;podhelper.rb&#x27;)target &#x27;Demo&#x27; do # 其他native用到的第三方库 pod &#x27;SnapKit&#x27; # flutter pod install_all_flutter_pods(flutter_application_path)end 先运行flutter pub get，再运行pod（最好先运行一下my_flutter） 12345cd /path/to/flutter_moduleflutter pub getcd /path/to/iosprojectpod install 接下来就可以直接在Xcode运行了 当然还有其他的接入方式，笔者认为这个方式比较简单，具体可以参考官方教程 开始接入为了更方便的管理FlutterEngine和FlutterViewController，这里使用flutter_boost来管理 为了方便管理，我们对FLBFlutterViewContainer进行封装 1234567class FlutterVC: FLBFlutterViewContainer &#123; override func loadView() &#123; super.loadView() // 隐藏navigationbar self.navigationController?.navigationBar.isHidden = true &#125;&#125; 实现flutter到本地的路由（NavigationHelper为帮助类，具体见后面源码链接） 123456789101112131415161718192021222324252627282930313233343536373839404142class PlatformRouterImp: NSObject, FLBPlatform &#123; // 从flutter传过来的push页面需求 // await FlutterBoost.singleton.open(&quot;nativePage&quot;, urlParams: &#123;&quot;a&quot;: 1&#125;, exts: &#123;&quot;b&quot;: 2&#125;); func open(_ url: String, urlParams: [AnyHashable : Any], exts: [AnyHashable : Any], completion: @escaping (Bool) -&gt; Void) &#123; switch url &#123; case &quot;nativePage&quot;: // 跳转到本地页面 let vc = HomeVC() NavigationHelper.nav2VC(vc) completion(true); default: completion(false); &#125; &#125; func present(_ url: String, urlParams: [AnyHashable : Any], exts: [AnyHashable : Any], completion: @escaping (Bool) -&gt; Void) &#123; switch url &#123; case &quot;nativeFlutterPage&quot;: // 创建新的FlutterVC let vc = FlutterVC(); vc.setName(&quot;home&quot;, params: urlParams); let navVC = UINavigationController(rootViewController: vc) NavigationHelper.presentVC(navVC) completion(true); default: completion(false); &#125; &#125; func close(_ uid: String, result: [AnyHashable : Any], exts: [AnyHashable : Any], completion: @escaping (Bool) -&gt; Void) &#123; let topVC = NavigationHelper.getTopVC() let presentVC = topVC.presentingViewController // 判断是否时present if let _ = presentVC &#123; topVC.dismiss(animated: true, completion: &#123; [unowned topVC] in topVC.removeFromParent() &#125;) &#125; else &#123; topVC.navigationController?.popViewController(animated: true) &#125; &#125;&#125; 初始化，可以放在application:didFinishLaunchingWithOptions:，定义一个名为myflutter_method_channel的MethodChannel，用于通信 1234567891011121314151617181920// 用于处理flutter发送的页面跳转消息let router = PlatformRouterImp.init();FlutterBoostPlugin.sharedInstance().startFlutter(with: router, onStart: &#123; (engine) in // 配置channel，用于通信 let batteryChannel = FlutterMethodChannel(name: &quot;myflutter_method_channel&quot;, binaryMessenger: engine.binaryMessenger) batteryChannel.setMethodCallHandler(&#123; (call: FlutterMethodCall, result: @escaping FlutterResult) -&gt; Void in switch call.method &#123; case &quot;alert&quot;: // native弹窗 let vc = UIAlertController(title: &quot;测试弹窗&quot;, message: &quot;弹窗内容&quot;, preferredStyle: .alert) vc.addAction(UIAlertAction(title: &quot;取消&quot;, style: .cancel, handler: nil)) NavigationHelper.getTopVC().present(vc, animated: true, completion: nil) result(true) default: result(false) &#125; &#125;)&#125;) 在Dart初始化flutter_boost 12345678910111213141516171819202122232425262728293031323334353637void main() &#123; runApp(MyApp());&#125;class MyApp extends StatefulWidget &#123; @override _MyAppState createState() =&gt; _MyAppState();&#125;class _MyAppState extends State&lt;MyApp&gt; &#123; @override void initState() &#123; // 注册Page，用于native跳转 FlutterBoost.singleton.registerPageBuilders(&lt;String, PageBuilder&gt;&#123; &#x27;home&#x27;: (String pageName, Map params, String uniqueId) &#123; return HomePage(); &#125;, &quot;me&quot;: (String pageName, Map params, String uniqueId) &#123; return MePage(); &#125; &#125;); super.initState(); &#125; @override Widget build(BuildContext context) &#123; return MaterialApp( title: &#x27;Demo&#x27;, theme: ThemeData( primarySwatch: Colors.blue, ), // 使用FlutterBoost作为builder builder: FlutterBoost.init(), home: HomePage(), ); &#125;&#125; flutter给native发消息 1234567try &#123; // 给native发消息 final bool result = await method_channel.invokeMethod(&quot;alert&quot;, &lt;String, dynamic&gt;&#123; &quot;a&quot;: 1 &#125;); print(result);&#125; on Exception catch (e) &#123; print(e);&#125; native给flutter发消息 1FlutterBoostPlugin.sharedInstance().sendEvent(&quot;showToast&quot;, arguments: [&quot;message&quot;: &quot;native消息&quot;]); flutter 监听消息 1234567891011// 监听消息，返回值是个匿名方法，可以取消监听_listenCancelable = FlutterBoost.singleton.channel.addEventListener(&#x27;showToast&#x27;, (name, arguments) async &#123; var msg = arguments[&quot;message&quot;]; if (msg != null) &#123; await _hudKey.currentState.showAndDismiss(ProgressHudType.success, msg); &#125; return null;&#125;);// 取消监听_listenCancelable.call() flutter给native发消息 12345678910111213141516171819private var cancelable: FLBVoidCallback?...// 监听flutter发来的消息cancelable = FlutterBoostPlugin.sharedInstance().addEventListener(&#123; [weak self] (name, arguments) in guard let self = self else &#123; return &#125; if let arguments = arguments, let msg = arguments[&quot;message&quot;] as? String &#123; let vc = UIAlertController(title: &quot;tip&quot;, message: msg, preferredStyle: .alert) vc.addAction(UIAlertAction(title: &quot;cancel&quot;, style: .default, handler: nil)) self.present(vc, animated: true, completion: nil) &#125;&#125;, forName: &quot;alert&quot;);...// 取消监听cancelable?() flutter发送消息 1FlutterBoost.singleton.channel.sendEvent(&quot;alert&quot;, &#123;&quot;message&quot;: &quot;flutter消息&quot;&#125;); flutter给native发消息交互也可以使用FlutterMethodChannel 兼容侧滑返回iOS的UINavigationController默认支持侧滑返回，flutter的MaterialApp在iOS上也支持侧滑返回，由于flutter运行在FlutterViewController上，所以默认情况下侧滑走的是UINavigationController，为了让侧滑可以衔接起来，我们需要 当MaterialApp的只有一个页面的时候，使用native侧滑 当MaterialApp有不止一个页面的时候，禁用native的侧滑操作 我们在MaterialApp添加一个observer 123456789101112131415161718192021222324import &#x27;package:flutter/material.dart&#x27;;// native通信channelconst method_channel = const MethodChannel(&#x27;myflutter_method_channel&#x27;);class MyNavigatorObserver extends NavigatorObserver &#123; // 在push和pop的时候，更新native的侧滑操作 @override void didPush(Route&lt;dynamic&gt; route, Route&lt;dynamic&gt; previousRoute) &#123; method_channel.invokeMethod(&quot;flutter_page_changed&quot;, &#123; &#x27;type&#x27;: &#x27;push&#x27;, &#x27;canPop&#x27;: route.navigator.canPop() &#125;); &#125; @override void didPop(Route&lt;dynamic&gt; route, Route&lt;dynamic&gt; previousRoute) &#123; method_channel.invokeMethod(&quot;flutter_page_changed&quot;, &#123; &#x27;type&#x27;: &#x27;pop&#x27;, &#x27;canPop&#x27;: route.navigator.canPop() &#125;); &#125;&#125; 由于flutter_boost会接管MeterialApp自带的observer，并且提供了对应的方法（设置在MaterialApp会无效） 12// 添加navigationObserver，用于控制返回操作FlutterBoost.singleton.addBoostNavigatorObserver(myObserver); 在FlutterVC添加popGestureRecognizerEnabled用于设置native侧滑功能 1234567class FlutterVC: FLBFlutterViewContainer &#123; var popGestureRecognizerEnabled = true &#123; didSet &#123; self.navigationController?.interactivePopGestureRecognizer?.isEnabled = popGestureRecognizerEnabled &#125; &#125;&#125; 由于UINavigationController是多个viewController共用的，所以在本地页面跳转的时候，也需要更新popGestureRecognizerEnabled 12345678910111213141516171819202122232425262728293031protocol PopGestureEnable &#123; var popGestureRecognizerEnabled: Bool &#123; get set &#125;&#125;class FlutterVC: FLBFlutterViewContainer, PopGestureEnable &#123; var popGestureRecognizerEnabled = true &#123; didSet &#123; self.navigationController?.interactivePopGestureRecognizer?.isEnabled = popGestureRecognizerEnabled &#125; &#125; // 由于navigationController是多个viewController共享的，所以在页面跳转的时候，也需要进行更新 override func viewDidAppear(_ animated: Bool) &#123; super.viewDidAppear(animated) self.navigationController?.interactivePopGestureRecognizer?.isEnabled = self.popGestureRecognizerEnabled &#125;&#125;class ViewController: UIViewController, PopGestureEnable&#123; var popGestureRecognizerEnabled = true &#123; didSet &#123; self.navigationController?.interactivePopGestureRecognizer?.isEnabled = popGestureRecognizerEnabled &#125; &#125; override func viewDidAppear(_ animated: Bool) &#123; super.viewDidAppear(animated) // 页面显示的时候更新一下 self.navigationController?.interactivePopGestureRecognizer?.isEnabled = self.popGestureRecognizerEnabled &#125;&#125; 添加消息handle 1234567891011121314151617181920// 配置channellet batteryChannel = FlutterMethodChannel(name: &quot;myflutter_method_channel&quot;, binaryMessenger: engine.binaryMessenger)batteryChannel.setMethodCallHandler(&#123; (call: FlutterMethodCall, result: @escaping FlutterResult) -&gt; Void in switch call.method &#123; case &quot;flutter_page_changed&quot;: // 修改native页面的侧滑 if let argument = call.arguments as? [String: Any], let canPop = argument[&quot;canPop&quot;] as? Bool &#123; // 取出最上面的Controller if let vc = NavigationHelper.getTopVC() as? FlutterVC &#123; // 修改侧滑enabled vc.popGestureRecognizerEnabled = !canPop &#125; &#125; result(nil) default: break; &#125;&#125;) 代码在这里: https://github.com/zhengbomo/flutter_boost_demo","categories":[{"name":"flutter","slug":"flutter","permalink":"http://zhengbomo.github.io/categories/flutter/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"http://zhengbomo.github.io/tags/flutter/"}]},{"title":"Swift性能优化（一）","slug":"swift-performance","date":"2020-06-01T13:31:37.000Z","updated":"2020-06-01T13:31:37.000Z","comments":true,"path":"2020-06-01/swift-performance/","link":"","permalink":"http://zhengbomo.github.io/2020-06-01/swift-performance/","excerpt":"最近学习了Swift底层原理相关的视频和文章，收获颇丰，趁热打铁，记录和总结对Swift的理解，对于Swift性能优化主要从下面三个方面入手","text":"最近学习了Swift底层原理相关的视频和文章，收获颇丰，趁热打铁，记录和总结对Swift的理解，对于Swift性能优化主要从下面三个方面入手 内存分配 引用计数 方法派发方式 内存分配在程序运行过程中，我们控制的内存主要有两个下面两个区域（DATA段也能修改，但对性能影响不大） 栈(Stack)：由操作系统管理，通常用来执行函数，存放局部变量和临时变量 对于在栈上分配内存和释放只是堆栈指针的移动（入栈和出栈），并且不需要增加额外的数据 堆(Heap): 由开发者自行管理内存的生命周期，通常用于存放类对象 对于在堆上分配内存，需要更高级的数据结构 申请内存的时候需要搜索堆空间，寻找合适的闲置内存块 需要添加额外的数据用于管理内存（如引用计数） 对于引用计数的操作需要具备原子性（线程安全） 堆上的内存还存在线程安全的问题 Swift 中的数据类型可以分成两种：值类型（Struct, Enum）、引用类型（Class）。两者的内存分配区域是不同的，值类型默认分配在栈区，引用类型默认分配在堆区 栈分配 堆分配 优化在值类型和引用类型的选择上，应该更多使用值类型，对于调用频繁的方法，应该减少在堆创建对象，如下 1234567891011121314enum Color &#123; case blue, green, gray &#125;enum Orientation &#123; case left, right &#125;enum Tail &#123; case none, tail, bubble &#125;var cache = [String: UIImage]()/// 创建聊天气泡func makeBalloon(_ color: Color, orientation: Orientation, tail: Tail) -&gt; UIImage &#123; let key = &quot;\\(color):\\(orientation):\\(tail)&quot; if let image = cache[key] &#123; return image &#125; ...&#125; 上面key由于是动态创建的，会被分配到堆上，考虑用结构体包装，可以避免频繁在堆创建对象 123456789101112131415struct Attribute: Hashable &#123; var color: Color var orientation: Orientation var tail: Tail&#125;var cache = [Attribute: UIImage]()func makeBalloon(_ color: Color, orientation: Orientation, tail: Tail) -&gt; UIImage &#123; let key = Attribute(color: color, orientation:orientation, tail:tail) if let image = cache[key] &#123; return image &#125; ...&#125; 小结对于需要频繁分配内存的需求，应尽量使用 Struct&#x2F;Enum 代替 Class。因为栈区的内存分配速度更快，更安全。 引用计数上面例子可以看到，class Point在堆分配时候，会额外分配两个字段，第一个是函数表，用来实现多态，另一个就是引用计数，用于内存管理，上面的Point类可以看成下面代码 1234567891011121314class Point &#123; var refCount: Int var x, y: Double func draw() &#123;&#125;&#125;let point1 = Point(x: 0, y: 0) // 引用计数=1let point2 = point1retain(point2) // 引用计数+1point2.x = 5// use point1release(point1) // 引用计数-1// use point2release(point2) // 引用计数-1，引用计数==0，释放Point在堆中的内存 引用计数是间接的管理内存，当引用计数为0时，Swift会将对应的内存释放 引用计数的操作是高频率的 引用计数的操作具备原子性（考虑线程安全），会带来一定的开销 虽然栈上的内存分配会比堆上块，但是有时候，使用栈会增加引用计数的操作（栈上的结构体使用了类对象，类对象在堆上分配），从而影响性能，如下 123456789101112131415struct Label &#123; var text: String var font: UIFont&#125;let label1 = Label(text: &quot;Hi&quot;, font: font)let label2 = label1retain(label2.text._storeage)retain(label2.font)// use label1release(label1.text._storeage)release(label1.font)// use label2release(label2.text._storeage)release(label2.font) 上面可以看到，每次label拷贝的时候，都会带来所有引用变量retain（上面例子是2个，如果多的话影响会更大），可以考虑改成class 123456789class Label &#123; var text: String var font: UIFont init(text: String, font: UIFont) &#123; self.text = text self.font = font &#125;&#125; 再看下面一个例子 12345678910111213struct Attachment &#123; let fileURL: URL let uuid: String let mimeType: String init?(fileURL: URL, uuid: String, mimeType: String) &#123; guard mimeType.isMimeType else &#123; return nil &#125; self.fileURL = fileURL self.uuid = uuid self.mimeType = mimeType &#125;&#125; 同样是struct包含多个class，优化代码如下，把引用类型改成值类型，提高性能同时，语义更明确 1234567891011121314151617181920struct Attachment &#123; let fileURL: URL // uuid改成UUID值类型 let uuid: UUID // mimeType改成结构体 let mimeType: MimeType init?(fileURL: URL, uuid: UUID, mimeType: String) &#123; guard let mimeType = MimeType(rawValue: mimeType) else &#123; return nil &#125; self.fileURL = fileURL self.uuid = uuid self.mimeType = mimeType &#125;&#125;enum MimeType : String &#123; case jpeg = &quot;image/jpeg&quot; case png = &quot;image/png&quot; case gif = &quot;image/gif&quot; &#125; 小结如果结构体中包含多个引用对象，在结构体传递的过程中，会对引用对象进行retain/release 可以考虑把引用类型转换成值类型（枚举&#x2F;结构体），减少struct中的class数量 也可以考虑把struct改成class来提高性能 当然也要根据具体场景判断是否要进行优化 派发方式Swift的函数派发有 直接派发 全局方法 使用static和final修饰的类和方法 使用private修饰的属性和方法会隐式添加final 值类型(struct, enum)的方法 extension里面没有用@objc修饰的方法 函数表派发 使用protocol调用的方法 class的实例方法 使用 消息派发 class中使用dynamic修饰的方法 继承自OC对象的方法 性能：直接派发 &gt; 函数表派发 &gt; 消息派发 除了上面派发方式，Swift会根据情况对小函数进行Inline优化 12345func drawAPoint(_ param: Point) &#123; param.draw()&#125; let point = Point(x: 0, y: 0) drawAPoint(point) 会被优化成 12let point = Point(x: 0, y: 0) point.draw() Witness Table我们知道，结构体也能实现协议，对于实现相同协议的不同的结构体，放到同一个数组中，内存是怎么分布的 1234567891011121314protocol Drawable &#123; func draw() &#125; struct Point : Drawable &#123; var x, y: Double func draw() &#123; ... &#125; &#125; struct Line : Drawable &#123; var x1, y1, x2, y2: Double func draw() &#123; ... &#125; &#125; var drawables: [Drawable] for d in drawables &#123; d.draw() &#125; 数组的内存是连续的，而结构体又存放在栈中，并且结构体的大小可能不一样，这不是矛盾了吗 显然不可能像上面一样存储，在Swift中提供了一个叫The Existential Container的容器用来包装Protocol类型，该容器有5个字节，该容器结构如下 valueBuffer: 占用3个字节 vwt: 占用1个字节，存放The Value Witness Table (VWT)，用于访问vwt，例如释放内存 Swfit会为每个实现了Protocol的结构体，实现下面方法，用于把包装并管理数据的声明周期 allocate:: 由于valueBuffer只有3个字节，当结构体数据超过3个字节时，就需要在堆上申请内存，allocate用于申请内存 copy:: 把结构体的数据拷贝到valueBuffer中，或把堆空间的地址复制到valueBuffer第一个字节 destruct:: 用于销毁数据 deallocate:: 回收内存 pwt: 占用1个字节，存放The Protocol Witness Table（PWT），方法表 protocol方法表，每一个实现protocol的结构体都有一个pwt表，在运行时通过pwt找到实例的方法 The Existential Container对应的结构体如下 12345struct ExistContDrawable &#123; var valueBuffer: (Int, Int, Int) var vwt: ValueWitnessTable var pwt: DrawableProtocolWitnessTable&#125; 我们看下一下面代码 12345func drawACopy(_ local: Drawable) &#123; local.draw()&#125;let val: Drawable = Point()drawACopy(val) Swift会把drawACopy方法改成下面形式 1234567891011121314func drawACopy(_ val: ExistContDrawable) &#123; var local = ExistContDrawable() let vwt = val.vwt let pwt = val.pwt local.type = type local.pwt = pwt // 拷贝数据（如果小于3个字节，直接拷贝到栈上的valueBuffer，如果超过3个字节，会在堆申请空间） vwt.allocateBufferAndCopyValue(&amp;local, val) // 通过pwt调用方法 // projectBuffer返回数据的地址（栈或堆） pwt.draw(vwt.projectBuffer(&amp;local)) // 释放资源 vwt.destructAndDeallocateBuffer(temp)&#125; 总结： vwt: 解决结构体内存空间不一致问题 pwt: 解决动态派发的问题（多态） Protocol属性12345678910struct Pair &#123; init(_ f: Drawable, _ s: Drawable) &#123; first = f ; second = s &#125; var first: Drawable var second: Drawable &#125; var pair = Pair(Line(), Point()) pair的内存布局如下 在Swift使用Protocol的时候，很多时候都是使用The Existential Container Protocol 泛型小结出于性能的考虑，我们尽量 使用final来修饰不会被重载的方法，如果class不会被重载，可以设置为final 使用private来修饰不会被外部访问到的属性和方法 从而提高函数的派发性能 引用 Understanding Swift Performance 未完待续~","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://zhengbomo.github.io/tags/Swift/"}]},{"title":"Swift方法派发机制","slug":"swift-method-dispatch","date":"2020-05-23T11:02:12.000Z","updated":"2020-05-23T11:02:12.000Z","comments":true,"path":"2020-05-23/swift-method-dispatch/","link":"","permalink":"http://zhengbomo.github.io/2020-05-23/swift-method-dispatch/","excerpt":"方法派发机制是程序判断如何去调用函数或方法的机制，每次调用方法时都会触发，了解派发机制的工作原理，对于写出高性能的代码来说非常重要，派发机制也能解释一些Swift中的奇怪的现象，和Objective-C中的黑魔法","text":"方法派发机制是程序判断如何去调用函数或方法的机制，每次调用方法时都会触发，了解派发机制的工作原理，对于写出高性能的代码来说非常重要，派发机制也能解释一些Swift中的奇怪的现象，和Objective-C中的黑魔法 静态派发 vs 动态派发根据函数调用能否在编译时或运行时确定，可以将派发机制分成两种类型： 静态派发：在编译期的时候，编译器就知道要为某个方法调用某种实现。因此, 编译器可以执行某些优化，甚至在可能的情况下，可以将某些代码转换成inline函数，从而使整体执行速度异常快。 动态派发：一定量的运行时开销为代价，提高了语言的灵活性。在动态派发机制下，对于每个方法的调用，编译器必须在方法列表(witness table或virtial table)中查找执行方法的实现，如在运行时判断选择父类的实现，还是子类的实现。由于对象的内存都是在运行时分配的，因此只能在运行时执行检查。 编译型语言有通常有三种基本的函数派发方式: 直接派发（Direct Dispatch） 编译后就确定了方法的调用地址（也叫静态派发），汇编代码中，直接跳到方法的地址执行，生成的汇编指令最少，速度最快 例如C语言，C++默认也是直接派发 由于缺乏动态性，无法实现多态 函数表派发（Table Dispatch） 在运行时通过一个函数表查找需要执行的方法，多一次查表的过程，速度比直接派发慢 C++的虚函数（Virtual Table），维护一个虚函数表，对象创建的时候会保存虚表的指针，调用方法之前，从对象中取出虚表地址，根据编译时的方法偏移量从虚表取出方法的地址，跳到方法的地址执行 消息派发（Message Dispatch） Objective-C: 方法调用包装成消息，发给运行时（相当于中间人），运行时会找到类对象，类对象会保存类的数据信息，其中就包含方法列表（类方法在元类对象存储），或通过父类查找，直到命中执行，如果没找到方法，抛出异常，运行时提供了很多动态的方法用于改变消息派发的行为，相比函数表派发有很强的动态性，由于运行时支持的功能很多，方法查找的过程比较长，性能比较低 性能：直接派发 &gt; 函数表派发 &gt; 消息机制派发 函数表派发和消息派发属于动态派发 Swift支持上面三种函数派发方式，Swift编译器会根据不同的情况选择不同的派发方式，基于性能考虑优先选择性能高的派发方式 Swift方法派发机制这里先只讨论纯Swift对象（非继承自NSObject），继承自OC类的比较特殊，放到后面讨论 直接派发在Swift中，下面方法会被编译为直接派发，在ARM64上调用方法会被编译为bl 函数地址 全局函数 使用static声明的所有方法 使用final声明的所有方法，使用final声明的类里面的所有方法 1234567891011121314class ParentClass &#123; func method1() &#123;&#125; func method2() &#123;&#125;&#125;final class ChildClass: ParentClass &#123; override func method2() &#123; &#125; func method3() &#123;&#125;&#125;let obj = ChildClass()// 下面调用都是直接派发obj.method1()obj.method2()obj.method3() 使用private声明的方法和属性，会隐式final声明 值类型的方法，struct和enum都是值类型 extension中没有使用@objc修饰的实例方法 函数表派发只有引用类型才支持函数表派发，在Swift中，类的方法默认使用函数派发的方式，Swift的函数表叫witness table（其他语言叫virtual table） 每个子类都有它自己的表结构 对于类中每个重写的方法，都有不同的函数指针 当子类添加新方法时，这些方法指针会添加在表数组的末尾 最后，编译器在运行时使用此表来查找调用函数的实现 1234567891011class ParentClass &#123; func method1() &#123;&#125; func method2() &#123;&#125;&#125;class ChildClass: ParentClass &#123; override func method2() &#123;&#125; func method3() &#123;&#125;&#125;let obj = ChildClass()obj.method2() obj对象调用method2的过程 读取对象0xB00的函数表. 读取函数指针的索引，在这里method2的索引是1(偏移量)，也就是0xB00 + 1 跳到0x222 消息派发Swift支持和OC混编，支持有限的runtime运行时（主要是为了和OC混编），对了纯Swift类，为了可以给OC调用，可以在方法前面加上dynamic来支持消息派发（注意@objc只是用于把方法暴露给ObjectiveC） 123class ParentClass &#123; dynamic func method2() &#123;&#125;&#125; 当消息被派发时，运行时会顺着继承关系向上查找被调用的方法，为了能够提升消息派发的性能，一般都会将查找进行缓存 协议Protocol协议所指向的对象，只有在运行时才能确定类型，Swift对于协议默认都使用函数表派发，协议可以为struct提供多态的支持 1234567891011121314151617protocol Drawable &#123; func draw()&#125;struct Line: Drawable &#123; func draw() &#123;&#125;&#125;struct Point: Drawable &#123; func draw() &#123;&#125;&#125;let drawable1: Drawable = Line()let drawable2: Drawable = Point()drawable1.draw() // 使用函数表派发drawable1.draw() // 使用函数表派发 NSObject类这里指继承自NSObject的类（包括UIView, UIButton等） 对于普通的实例方法，使用函数表派发 对于使用@objc声明的方法，会暴露给ObjectiveC，还是使用函数表派发 对于override的OC方法，使用消息派发 对于extension方法，默认使用直接派发 使用dynamic修饰的方法使用消息派发 12345678910111213141516171819202122232425262728293031323334class MyButton: UIButton &#123; // 直接派发 final func method1() &#123;&#125; // 直接派发 static func method2() &#123;&#125; // 函数表派发 func method3() &#123;&#125; // 函数表派发 @objc func method4() &#123;&#125; // 消息派发派发 @objc dynamic func method5() &#123;&#125; // 消息派发 override func layoutSubviews() &#123; super.layoutSubviews() &#125;&#125;extension MyButton &#123; // 直接派发 func method6() &#123;&#125; // 消息派发 @objc func method7() &#123;&#125; // 直接派发 dynamic func method8() &#123;&#125;&#125; 以上基于XCode11+Swift5测试，讨论的是未被编译器优化的情况，编译器会根据方法的使用情况做优化，函数表派发可能被优化成直接派发，部分方法会被优化城inline形式 引用 Understanding Swift Performance","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://zhengbomo.github.io/tags/Swift/"}]},{"title":"fishhook源码学习","slug":"fishhook-learn","date":"2020-05-14T11:20:18.000Z","updated":"2020-05-14T11:20:18.000Z","comments":true,"path":"2020-05-14/fishhook-learn/","link":"","permalink":"http://zhengbomo.github.io/2020-05-14/fishhook-learn/","excerpt":"首先是知识储备 Mach-O文件格式，用于定位懒绑定的函数地址 Mach-O懒加载机制，运行时绑定自定义地址","text":"首先是知识储备 Mach-O文件格式，用于定位懒绑定的函数地址 Mach-O懒加载机制，运行时绑定自定义地址 懒加载例子先看个例子 12345int main(int argc, char * argv[]) &#123; printf(&quot;111&quot;); printf(&quot;222&quot;); return 1;&#125; 调试查看汇编为 123456789101112131415161718192021Test`main: 0x10486bf24 &lt;+0&gt;: sub sp, sp, #0x30 ; =0x30 0x10486bf28 &lt;+4&gt;: stp x29, x30, [sp, #0x20] 0x10486bf2c &lt;+8&gt;: add x29, sp, #0x20 ; =0x20 0x10486bf30 &lt;+12&gt;: stur wzr, [x29, #-0x4] 0x10486bf34 &lt;+16&gt;: stur w0, [x29, #-0x8] 0x10486bf38 &lt;+20&gt;: str x1, [sp, #0x10] 0x10486bf3c &lt;+24&gt;: adrp x0, 0 0x10486bf40 &lt;+28&gt;: add x0, x0, #0xfa4 ; =0xfa4-&gt; 0x10486bf44 &lt;+32&gt;: bl 0x10486bf74 ; symbol stub for: printf 0x10486bf48 &lt;+36&gt;: adrp x8, 0 0x10486bf4c &lt;+40&gt;: add x8, x8, #0xfad ; =0xfad 0x10486bf50 &lt;+44&gt;: str w0, [sp, #0xc] 0x10486bf54 &lt;+48&gt;: mov x0, x8 0x10486bf58 &lt;+52&gt;: bl 0x10486bf74 ; symbol stub for: printf 0x10486bf5c &lt;+56&gt;: mov w9, #0x1 0x10486bf60 &lt;+60&gt;: str w0, [sp, #0x8] 0x10486bf64 &lt;+64&gt;: mov x0, x9 0x10486bf68 &lt;+68&gt;: ldp x29, x30, [sp, #0x20] 0x10486bf6c &lt;+72&gt;: add sp, sp, #0x30 ; =0x30 0x10486bf70 &lt;+76&gt;: ret 进入 0x10486bf74 方法（用si命令） 1234Test`printf: 0x10486bf74 &lt;+0&gt;: nop 0x10486bf78 &lt;+4&gt;: ldr x16, #0x4088 ; (void *)0x0000000102a43fa8-&gt; 0x10486bf7c &lt;+8&gt;: br x16 这段代码对应MachO文件中__DATA段的__stubs，MachOView没有显示出汇编代码（文件偏移地址&#x3D;内存偏移地址 - ASLR - PAGESIZE） 第一次会跳到0x0000000102a43fa8这个地址，去掉ASLR为0x0000000100007fa8，这个值存放在对应__DATA段的__la_symbol_ptr，fishhook也是修改这里的值，达到替换方法的目的 0x0000000100007fa8地址对应代码__TEXT段__stub_helper里面，第一次会执行这里进行符号绑定 绑定完成后，会修改内存中__DATA段的__la_symbol_ptr里面的值 下面是第二次执行printf，x16的值以及是0x000000019d06df5c了，这个就是真实的printf地址 1234Test`printf:-&gt; 0x10486bf74 &lt;+0&gt;: nop 0x10486bf78 &lt;+4&gt;: ldr x16, #0x4088 ; (void *)0x000000019d06df5c: printf 0x10486bf7c &lt;+8&gt;: br x16 fishhook源码分析fishhook就是利用了MachO对于符号（如：printf）在运行时才做真实地址的绑定（__DATA段__la_symbol_ptr或__nl_symbol_ptr），找到对应的符号占位地址修改为我们自己的函数地址 fishhook.c源码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220// 用于重绑定符号的链表项struct rebindings_entry &#123; struct rebinding *rebindings; size_t rebindings_nel; struct rebindings_entry *next;&#125;;// 用于存放所有要重绑定符号的列表，链表结构static struct rebindings_entry *_rebindings_head;// 重绑定符号int rebind_symbols(struct rebinding rebindings[], size_t rebindings_nel) &#123; // 把rebindings放进链表_rebindings_head的头部，原来的head会被放到next int retval = prepend_rebindings(&amp;_rebindings_head, rebindings, rebindings_nel); if (retval &lt; 0) &#123; return retval; &#125; // 判断是否是第一次调用（第一次的话next为空） if (!_rebindings_head-&gt;next) &#123; // 第一次调用的话，注册加载动态库的回调，加载完后会回调_rebind_symbols_for_image _dyld_register_func_for_add_image(_rebind_symbols_for_image); &#125; else &#123; // 已经加载完成动态库，遍历所有的动态库 uint32_t c = _dyld_image_count(); for (uint32_t i = 0; i &lt; c; i++) &#123; // 符号绑定，传入动态库header和ASLR偏移量 _rebind_symbols_for_image(_dyld_get_image_header(i), _dyld_get_image_vmaddr_slide(i)); &#125; &#125; return retval;&#125;// 把rebindings放到链表rebindings_head的头部static int prepend_rebindings(struct rebindings_entry **rebindings_head, struct rebinding rebindings[], size_t nel) &#123; struct rebindings_entry *new_entry = malloc(sizeof(struct rebindings_entry)); if (!new_entry) &#123; return -1; &#125; new_entry-&gt;rebindings = malloc(sizeof(struct rebinding) * nel); if (!new_entry-&gt;rebindings) &#123; free(new_entry); return -1; &#125; memcpy(new_entry-&gt;rebindings, rebindings, sizeof(struct rebinding) * nel); new_entry-&gt;rebindings_nel = nel; new_entry-&gt;next = *rebindings_head; *rebindings_head = new_entry; return 0;&#125;// 绑定动态库符号static void _rebind_symbols_for_image(const struct mach_header *header, intptr_t slide) &#123; rebind_symbols_for_image(_rebindings_head, header, slide);&#125;// 绑定动态库符号，主要方法static void rebind_symbols_for_image(struct rebindings_entry *rebindings, const struct mach_header *header, intptr_t slide) &#123; Dl_info info; // 获取 mach_header 这个符号的信息，将信息放到 info 中 if (dladdr(header, &amp;info) == 0) &#123; return; &#125; segment_command_t *cur_seg_cmd; segment_command_t *linkedit_segment = NULL; struct symtab_command* symtab_cmd = NULL; struct dysymtab_command* dysymtab_cmd = NULL; // 遍历loadCommand，找到__LINKEDIT，LC_SYMTAB, LC_DYSYMTAB uintptr_t cur = (uintptr_t)header + sizeof(mach_header_t); for (uint i = 0; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123; cur_seg_cmd = (segment_command_t *)cur; if (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123; if (strcmp(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == 0) &#123; linkedit_segment = cur_seg_cmd; &#125; &#125; else if (cur_seg_cmd-&gt;cmd == LC_SYMTAB) &#123; symtab_cmd = (struct symtab_command*)cur_seg_cmd; &#125; else if (cur_seg_cmd-&gt;cmd == LC_DYSYMTAB) &#123; dysymtab_cmd = (struct dysymtab_command*)cur_seg_cmd; &#125; &#125; // 判空 if (!symtab_cmd || !dysymtab_cmd || !linkedit_segment || !dysymtab_cmd-&gt;nindirectsyms) &#123; return; &#125; // 定位 “符号表”，“字符串表”，“重定向表” 实际内存地址 // 代码段在内存的起始位置（ASLR偏移+PAGEZERO）(PAGEZERO = vmaddr - fileoff) uintptr_t linkedit_base = (uintptr_t)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff; // 符号表的地址 = 基址 + 符号表偏移量 nlist_t *symtab = (nlist_t *)(linkedit_base + symtab_cmd-&gt;symoff); // 字符串表的地址 = 基址 + 字符串表偏移量 char *strtab = (char *)(linkedit_base + symtab_cmd-&gt;stroff); // 动态符号表地址 = 基址 + 动态符号表偏移量 uint32_t *indirect_symtab = (uint32_t *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff); // 为了重新遍历loadCommand，重新设置cur cur = (uintptr_t)header + sizeof(mach_header_t); // 再次遍历LoadCommand for (uint i = 0; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123; cur_seg_cmd = (segment_command_t *)cur; if (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123; // 找到__DATA段和__DATA_CONST段 if (strcmp(cur_seg_cmd-&gt;segname, SEG_DATA) != 0 &amp;&amp; strcmp(cur_seg_cmd-&gt;segname, SEG_DATA_CONST) != 0) &#123; continue; &#125; for (uint j = 0; j &lt; cur_seg_cmd-&gt;nsects; j++) &#123; section_t *sect = (section_t *)(cur + sizeof(segment_command_t)) + j; // 对__nl_symbol_ptr以及__la_symbol_ptr进行rebind if ((sect-&gt;flags &amp; SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS) &#123; perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab); &#125; if ((sect-&gt;flags &amp; SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS) &#123; perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab); &#125; &#125; &#125; &#125;&#125;// 重新绑定符号static void perform_rebinding_with_section(struct rebindings_entry *rebindings, section_t *section, intptr_t slide, nlist_t *symtab, char *strtab, uint32_t *indirect_symtab) &#123; // 是否是__DATA_CONST常量区 const bool isDataConst = strcmp(section-&gt;segname, SEG_DATA_CONST) == 0; // `nl_symbol_ptr`和`la_symbol_ptr`section中的`reserved1`字段指明对应的`indirect symbol table`起始的index //动态符号表中第一个解析的符号的起始地址 uint32_t *indirect_symbol_indices = indirect_symtab + section-&gt;reserved1; // indirect_symbol_bindings是 `__la_symbol_ptr` or `__nl_symbol_ptr` 表 // 它的首地址 = slide(基础偏移地址) + Section的内存相对地址 (memory address of this section) void **indirect_symbol_bindings = (void **)((uintptr_t)slide + section-&gt;addr); // 内存保护设置 vm_prot_t oldProtection = VM_PROT_READ; if (isDataConst) &#123; oldProtection = get_protection(rebindings); // 修改内存属性为可读写（__DATA_CONST段默认是只读的），便于我们修改函数地址等数据 mprotect(indirect_symbol_bindings, section-&gt;size, PROT_READ | PROT_WRITE); &#125; // 遍历表 for (uint i = 0; i &lt; section-&gt;size / sizeof(void *); i++) &#123; // 符号表Index：根据动态符号表获取 uint32_t symtab_index = indirect_symbol_indices[i]; // 如果是 abs 或者 是 本地 则跳过 (因为不是动态库的外部符号) if (symtab_index == INDIRECT_SYMBOL_ABS || symtab_index == INDIRECT_SYMBOL_LOCAL || symtab_index == (INDIRECT_SYMBOL_LOCAL | INDIRECT_SYMBOL_ABS)) &#123; continue; &#125; // 字符串表偏移量 uint32_t strtab_offset = symtab[symtab_index].n_un.n_strx; // 通过字符串表偏移量获取符号对应的字符串（符号的名字） char *symbol_name = strtab + strtab_offset; bool symbol_name_longer_than_1 = symbol_name[0] &amp;&amp; symbol_name[1]; // 获取第一个元素 struct rebindings_entry *cur = rebindings; // 遍历所有需要hook的符号表 while (cur) &#123; for (uint j = 0; j &lt; cur-&gt;rebindings_nel; j++) &#123; // 判断符号名是否相同 if (symbol_name_longer_than_1 &amp;&amp; strcmp(&amp;symbol_name[1], cur-&gt;rebindings[j].name) == 0) &#123; // 备份原来的符号地址 if (cur-&gt;rebindings[j].replaced != NULL &amp;&amp; indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) &#123; *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i]; &#125; // 并且将hook函数的新函数地址 更新到 `__nl_symbol_ptr`或者`__la_symbol_ptr` 中 indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement; // 结束该内层的遍历, 查找下一个符号 goto symbol_loop; &#125; &#125; cur = cur-&gt;next; &#125; symbol_loop:; &#125; // 恢复原来的内存权限改写 if (isDataConst) &#123; int protection = 0; if (oldProtection &amp; VM_PROT_READ) &#123; protection |= PROT_READ; &#125; if (oldProtection &amp; VM_PROT_WRITE) &#123; protection |= PROT_WRITE; &#125; if (oldProtection &amp; VM_PROT_EXECUTE) &#123; protection |= PROT_EXEC; &#125; mprotect(indirect_symbol_bindings, section-&gt;size, protection); &#125;&#125; 整个过程 获取LoadCommand的地址和数量 遍历LoadCommand，获取到__LINKEDIT，LC_SYMTAB, LC_DYSYMTAB信息 根据LoadCommand的段偏移量和ASLR偏移量，算出符号表，动态符号表，字符串表的内存地址 遍历LoadCommand，找出__DATA段和__DATA_CONST段，遍历S_LAZY_SYMBOL_POINTERS和S_NON_LAZY_SYMBOL_POINTERS段信息 如果是__DATA_CONST，则需要修改内存权限为可读写 遍历上面两个段，过滤abs和本地符号，找到匹配符号的，保存原来的地址，替换为新的符号地址 通过__la_symbol_ptr的reserved1字段找到第一个需要动态绑定的符号在Dynamic Symbol Table中的位置 Dynamic Symbol Table中获取到Symbol Table的Index 在Symbol Table获取String Table的偏移量，得到符号名 找到匹配的符号名，替换对应的段信息 恢复__DATA_CONST内存权限为只读","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"}]},{"title":"《操作系统》内存管理（三）","slug":"os-learn-memory","date":"2020-05-05T14:50:53.000Z","updated":"2020-05-05T14:50:53.000Z","comments":true,"path":"2020-05-05/os-learn-memory/","link":"","permalink":"http://zhengbomo.github.io/2020-05-05/os-learn-memory/","excerpt":"CPU速度快，存储器成本高，硬盘速度低，存储成本低，内存处于中间，缓和速度矛盾","text":"CPU速度快，存储器成本高，硬盘速度低，存储成本低，内存处于中间，缓和速度矛盾 程序的编译和运行过程 编译 链接（三种方式） 静态链接: 装入时动态链接 运行时动态链接 装入: 使用逻辑地址编译链接后的程序，装载到内存中后，需要映射到物理地址 绝对装入：编译时产生绝对地址（物理地址） 可重定位装入：程序使用逻辑地址，程序装入内存的时候进行地址转换，转换为绝对地址 动态运行时装入：程序使用逻辑地址，程序装入内存的时候使用的也是逻辑地址，通过CPU重定位寄存器修复逻辑地址到物理地址，现代操作系统采用这种方式 内存管理操作系统对内存管理通常需要实现下面四个需求 内存空间的分配和回收两种方式 连续分配管理方式 单一连续分配 固定分区分配 动态分区分配 首次适应：从头查找，找出第一个满足的内存块 最佳适应：空闲内存排序，取出最小适应的内存块 最坏适应：空闲内存排序，取出最大适应的内存块 临近适应：每次从上一次结束位置开始查找，规则和首次适应一样 非连续分配管理方式 基本分页存储管理: 将物理内存分页，将进程分页，各页面离散放到内存快中（如iOS A9处理器之后的内存分页大小为16K），每页有一个编号，从0开始，程序加载到内存中时，会被拆分程多个页加载，然后分别加载到内存中的不同的页 基本分段存储管理: 分段思想和分页类似，一个程序可以被分为多个段，每个段在内存中占据连续的空间，各个段之间可以不相邻内存地址空间根据模块进行划分，每个段都有段名，每个段从0开始编址 段页式存储管理: 先分段后分页 基本分页存储管理 页表: 记录页面和时机内存块之间的映射关系 逻辑地址：页号和页面偏移量 优点：不会产生外部碎片，只会产生少量的页内碎片缺点：不方便按逻辑模块实现信息的共享和保护 基本分段存储管理 段表：存放段内存的映射表（段号，段长，基址），与页表类似 逻辑地址: 段号和段内地址 段表寄存器：段表始址和段表长度 分段对用户可见，分页对用户不可见 分段比分页更容易实现信息的共享和保护（如只读内存，可读写内存） 优点：很方便按逻辑模块实现信息的共享和保护缺点：如果段长过长，分配大的连续的内存空间很不方便，段式分配会产生外部内存碎片 段页式管理 逻辑地址: 段号，页号，页面偏移量 段表寄存器：段表始址和段表长度 内存保护不同进程的地址空间应该互相独立，各进程应该在自己的内存空间内运行，不会越界访问 设置上下限寄存器，用于检查地址是否越界 采用重定位寄存器(存放进程起始物理地址)和界地址寄存器进行越界检查（存放进程最大逻辑地址） 内存空间的扩充 内存紧张时，根据一定的策略把某些进程的内存空间换到外存，把需要的数据从外存加载到内存 通常磁盘文件为文件区和对换区，对换区采用连续存储，文件区采用随机存储，对换区的存取效率比文件区高，换初的内存放到对换区 覆盖技术: 内存不够时，覆盖不用的内存 交换技术: 内存不够的时候，内外存交换 虚拟存储技术: 后面说明 内存空间扩充对程序是透明 地址转换基本地址变换机构（地址转换） 逻辑地址：包含页号和页内偏移量） 页表寄存器：存放页表起始地址和页表长度，用于做地址越界检查 通过PCB页表得到物理页号&#x2F;物理页偏移量 根据逻辑偏移量和物理页偏移量算出真实物理地址 访问内存单元 现代操作系统：编写程序的时候应该只关注指令和数据的逻辑地址，而逻辑地址到物理地址的转换（也称为地址重定位）应该由操作系统完成 快表为了提高地址变换速度，操作系统在高速缓存维护了一份页表的副本，对应内存中的页表称为慢表，快表只存放一部分慢表，快表其实是对页表做了缓存，加快了访问速度，引入快表后的地址变换过程如下 高速缓存: 速度介于寄存器和内存之间，通常位于CPU内部 多级页表 问题一：单级页表存在的问题：页表必须连续存放，页表很大的时候，占用空间大 问题二：部分页面经常使用，部分页面很少使用甚至不用，没必要加载整个页表到内存中 把分页的思想应用于页表上，建立一张页目录表用于存放页表的页号，多级页表的逻辑地址就由一级页号，二级页号，三级页号…页内偏移量组成 虚拟内存传统的存储管理方式存在两个缺点: 一次性: 作业一次性全部调入内存 驻留性: 作业在运行期间常驻内存 局部性原理 时间局部性：现在访问的指令在不久后很可能再次访问 空间局部性：现在访问的内存单元不久后很可能再次访问 虚拟内存：程序装入内存时，将要用到的内存部分装入内存，暂时没用到部分留在外存，就可以让程序运行了，内存不够用的时候，将暂时用不到的内存信息换出到外存，用户看起来”可以”使用比实际物理内存更大的内存，该特性是是通过操作系统在逻辑上虚拟的 多次性：无需再作业运行时，一次性全部装入内存，而是允许被多次调入内存 对换性：作业运行时无需一致常驻内存，而式允许作业换入换出 虚拟性：逻辑上扩充了内存容量，宏观上，使用内存大于实际内存 请求分页管理方式基于离散分配的内存管理方式上，操作系统需要提供下面功能 请求调页/段: 当访问的信息不在内存时候，由操作系统将所需的信息从外存加载到内存 页面/段置换: 当内存空间不够时，由操作系统将部分不用的数据放到外存中 实现 页表机制: 新增4个状态 状态位(是否已调入内存) 访问字段(访问次数,用于置换) 修改位(是否被修改过) 外存地址(页面在外存的位置) 缺页中断 当访问的页不在内存中，会产生一个缺页中断，操作系统会阻塞该进程，并保留CPU现场，然后将页面加载到内存中（如果内存用完了，需要考虑置换），然后恢复CPU现场，再继续该进程 缺页中断属于内中断 一条指令执行期间，可能产生多次缺页中断 地址变换: 从逻辑地址到物理地址的转换 页面置换算法当内存不足时候，置换策略 最佳置换算法(OPT): 根据以后不使用&#x2F;最长时间不实用的页面置换页面，无法实现 先进先出置换算法(FIFO) 最近最久未使用算法(LRU)：LRU算法实现起来比较麻烦，需要寄存器和栈，性能高 时钟置换算法(CLOCK): 用比较小的开销接近LRU的性能 改进型时钟置换算法：CLOCK算法添加修改位 页面分配策略 驻留集：请求分页存储管理中给进程分配的物理块的集合，或者说进程使用的物理内存的集合，通常再虚拟存储技术中，驻留集比进程总大小要小，驻留集太小，会发生缺页 工作集：在一定时间间隔内，进程实际访问的页面的集合，通常驻留集不能小于工作集 抖动（颠簸）现象: 进程频繁访问的页面数大于可用的物理内存页面数，分配给进程的物理快不够，也就是频繁缺页导致置换操作频繁 页面分配 固定分配: 系统为进程分配的物理页面固定不变，不够用&#x2F;缺页的时候会发生置换 可变分配 置换策略 局部置换: 当发生缺页时，只置换当前进程的内存 全局置换: 当发生缺页时，可置换其他进程的内存","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://zhengbomo.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://zhengbomo.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"《操作系统》进程管理（二）","slug":"os-learn-process","date":"2020-04-30T15:09:04.000Z","updated":"2020-04-30T15:09:04.000Z","comments":true,"path":"2020-04-30/os-learn-process/","link":"","permalink":"http://zhengbomo.github.io/2020-04-30/os-learn-process/","excerpt":"概念程序：是静态的，存放在磁盘的一系列可执行的指令集合进程：是动态的，程序加载到内存运行的一次执行过程","text":"概念程序：是静态的，存放在磁盘的一系列可执行的指令集合进程：是动态的，程序加载到内存运行的一次执行过程 组成 进程控制块(PCB): 操作系统用于管理进程所需要的相关信息，通常包含 进程描述信息 进程标识符PID 用户标识符UID 资源相关信息 I&#x2F;O设备使用 文件使用情况 内存分配情况 运行相关信息 CPU，磁盘使用，网络流量等） 进程状态信息（就绪态&#x2F;阻塞态&#x2F;运行态） 处理机相关信息 PSW，PC等寄存器等信息（用于进程切换保留现场） 程序段：用于CPU执行的指令集合，只读 数据段：用户存放程序运行过程中的产生的数据，可读写 特性 动态性 并发性 独立性 异步性 结构性 状态 就绪态：具备运行的条件，等待CPU运行 运行态：正在被CPU执行 阻塞态：请求等待某个事件发生 创建态：操作系统为新进程分配资源，创建PCB 终止态：操作系统回收进程资源，撤销PCB 状态转换 就绪态-&gt;运行态：进程被调度 运行态-&gt;就绪态：CPU运行时间片到，或CPU被其他更高优先级的进程抢占了 运行态-&gt;阻塞态：等待某个事件发生（主动行为） 阻塞态-&gt;就绪态：等待的事件被触发（被动行为） 创建态-&gt;就绪态：系统完成创建进程的相关工作 运行态-&gt;终止态：进程运行结束，或运行遇到不可修复的错误 原语原语的执行具有原子性，原子性通过开中断指令和关中断指令两个特权指令实现原子性 如果中断信号在关中断指令和开中断指令之间发生，则会推迟到之后 开关中断指令只能在内核进程使用，不能在用户进程使用 进程通信进程的地址空间是相互独立的，一个进程无法直接访问另一个进程的地址空间，操作系统提供了下面三种通信方式 共享存储: 独立于进程之外的空间，两个进程都能互斥访问 管道通信: 其实是在内存中开辟的一个固定大小的缓冲区 管道只能采用半双工通信（一个时间段只能实现单向传输），如果要实现双向通信，需要2个管道 进程访问管道是互斥的 管道必须写满才能被读，必须读完才能被写 消息传递 直接通信方式：每个进程会有一个消息缓冲队列，用于接受其他进程发送过来的消息 间接通信方式：消息通过信箱集中管理进程的通信 线程进程也有并发的需求，多进程并发，会有性能差，通信麻烦的问题，所以在进程内部引入线程 解决进程并发问题 解决进程切换开销大的问题 解决进程通信的问题 线程：处理器的调度单位，为进程的执行过程，一个进程可以由多个线程，进程内的线程共享进程的地址空间，资源等 线程实现方式 用户级线程: 用单线程模拟多线程，例如消息循环 不支持多核并行 一个线程阻塞会导致所有线程被阻塞 不需要CPU切换内核态核用户态，效率高 内核级线程: 由操作系统内核支持 并发能力强 需要CPU切换内核态核用户态，开销大 进程的调度 高级调度（作业调度）: 外存 -&gt; 内存 中级调度（内存调度）: 内存 ⇌ 外存 低级调度（进程调度）: 内存 ⇌ CPU 时机 主动放弃 进程正常终止 运行过程发生异常而终止 主动阻塞（如I&#x2F;O等待） 被动放弃 CPU时间片用完 有更紧急的事情要处理（如I&#x2F;O中断） 有更高优先级的进程进入就绪队列 不能进行线程调度 处理中断过程中 进程在操作系统内核程序临界区中 院子操作过程中 调度 非抢占方式: 由进程主动放弃处理器, 可能CPU会被一个进程一直占用 抢占方式: 可以优先处理更紧急的进程 切换 保存当前进程现场（保存寄存器） 恢复即将切换进程现场（恢复寄存器） 临界区临界资源：一个时间段只允许一个进程使用的资源，进程互斥访问临界资源临界区：访问临界资源的代码内核程序临界区：访问某种内核数据结构的代码，如进程的就绪队列，过程中进程不能被调度 优先级调度算法 系统进程优先级高于用户进程 前台进程优先级高于后台进程 操作系统更偏好I/O型进程（可以让I&#x2F;O进程尽早投入工作，提高资源利用率，系统吞吐量） 优先级分为静态优先级和动态优先级 如果某进程在就绪队列等待了很长时间，则可以适当的提高优先级 如果某进程占用处理机运行了很长事件，则可以适当的降低优先级 进程同步由于操作系统的并发性，导致不同进程中业务的执行顺序不可预测，为了满足特地执行流程（例如，先进程A读数据要在进程B写数据之后才能继续），就需要使用进程同步的技术，解决异步的问题 临界资源：一个时间段内只允许一个进程使用的资源，进程对于临界资源的访问是互斥的 四个部分 进入区：检查是否可以进入临界区，负责上锁 临界区：访问临界区的代码 退出区：负责解锁 剩余区：其余代码部分 遵循原则 空闲进入 忙则等待 优先等待 让权等待，等待的时候让出CPU 进程互斥软件实现方法 单标志法 双标志先检查法 双标志后检查法 Peterson算法 进程互斥的硬件实现 中断屏蔽方法：通过开&#x2F;关中断指令实现，简单高效，只是用于单处理器，只是用于内核进程 TestAndSet指令：检查临界区和上锁的操作为原子操作 Swap指令：与TestAndSet指令类似 信号量机制整型信号量信号量：一个变量，可以表示系统某种资源的数量 使用wait和signal原语对信号量进行操作，也称为PV操作 12345678910111213// 初始化整形信号量S，可用资源为1int S = 1;// wait原语，相当于进入区void wait(int S) &#123; while(S &lt;= 0) ; // 资源不够时，进入忙等待 S = S - 1; // 占用资源&#125;// signal原语，相当于退出区void signal(int S) &#123; S = S + 1; // 释放资源&#125; 使用资源 1234567// P操作wait(S);// 使用资源// V操作signal(S) 存在问题：不满足让权等待的原则，会出现CPU空转的情况 记录型信号量解决整形信号量让权等待的问题，通过block和wakeup原语，避免忙等待的情况，提高CPU的利用率 12345678910111213141516171819202122typedef struct &#123; int value; struct process *L; // 等待队列&#125; semaphore;// 原子操作void wait(semaphore S) &#123; S.value--; if (S.value &lt; 0) &#123; // 没有空闲的资源， 阻塞当前进程进程，并把进程放到等待队列中 block(S.L); &#125;&#125;// 原子操作void signal(semaphore S) &#123; S.value++; if (S.value &lt;= 0) &#123; // 说明有进程在等待，唤醒队列中的进程 wakeup(S.L); &#125;&#125; 使用信号量解决互斥问题 123456789101112131415161718192021semaphore mutex = 1;// 进程P1P1() &#123; ... // P操作 P(mutex); 临界区代码 // V操作 V(mutex) ...&#125;// 进程P2P2() &#123;... P(mutex); 临界区代码 V(mutex) ...&#125; 使用信号量解决同步问题 1234567891011121314151617semaphore S=0;P1() &#123; 代码1; 代码2; // 释放资源 V(S); 代码3;&#125;P2() &#123; // 在代码2执行完成后执行 P(S); 代码4; 代码5; 代码6;&#125; 生产者消费者问题12345678910111213141516171819202122232425262728293031semaphore mutex = 1; // 互斥信号量semaphore empty = n; // 缓冲区大小semaphore full = 0; // 产品数量producer() &#123; while(1) &#123; // 生产一个产品 P(empty); // 消耗一个空闲缓冲区 P(mutex); 将产品放入缓冲区 V(mutex); V(full); // 增加一个产品 &#125;&#125;consumer() &#123; while(1) &#123; P(full); // 消耗一个产品 P(mutex); 从缓冲区取出一个产品 V(mutex); V(empty) // 增加一个空闲缓存区 // 使用产品 &#125;&#125; 读者写者问题读并发，写互斥 1234567891011121314151617181920212223242526272829303132333435363738semaphore rw = 1; // 文件互斥访问int count = 0; // 读文件进程个数semaphore mutex = 1; // 用户对count互斥semaphore w = 1; // 实现当写进程进入的时候，新的读进程进不来，防止写饥饿writer() &#123; while(1) &#123; P(w); P(rw); 写文件 V(rw); V(w) &#125;&#125;reader() &#123; while(1) &#123; P(w); P(mutex); if (count == 0) &#123; P(rw); &#125; count++; V(mutex); V(w); 读文件 P(mutex); count--; if (count == 0) &#123; V(rw); // 没有读操作，释放 &#125; V(mutex); &#125;&#125; 哲学家进餐问题123456789101112131415semaphore chopstick[5] = &#123;1, 1, 1, 1, 1&#125;;semaphore mutex = 1;Pi() &#123; while(1) &#123; P(mutex); P(chopstick[i]); // 拿起左边筷子 P(chopstick[(i+1)%5]); // 拿起右边筷子 V(mutex) 吃饭 V(chopstick[i]); // 放下左边筷子 V(chopstick[(i+1)%5]); // 放下右边筷子 &#125;&#125; 其他问题 多生产者消费者问题 吸烟者问题 管程信号量机制存在问题：编写程序困难，易出错，容易发生死锁，管程的引入是为了解决该问题管程：通过封装同步数据的方法，由编译器实现方法的互斥，从而简单化信号量的使用，对于管程的方法，同一时间只有一个进程能进入方法，如下面JAVA的管程 12345678static class monitor &#123; private Item buffer[] = new Item[N]; private int count = 0; public synchronized void insert(Item item) &#123; // 每次只能有一个线程进入，由编译器实现互斥 &#125;&#125; 管程其实是利用了封装的思想，把进程同步互斥的逻辑封装到方法里面，通过编译器实现方法的互斥，达到线程同步的目的","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://zhengbomo.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://zhengbomo.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"《操作系统》概论（一）","slug":"os-learn-basic","date":"2020-04-25T14:21:25.000Z","updated":"2020-04-25T14:21:25.000Z","comments":true,"path":"2020-04-25/os-learn-basic/","link":"","permalink":"http://zhengbomo.github.io/2020-04-25/os-learn-basic/","excerpt":"操作系统：控制和管理整个计算机系统的硬件和软件资源，并合理组织调度计算机工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件","text":"操作系统：控制和管理整个计算机系统的硬件和软件资源，并合理组织调度计算机工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件 概念语功能提供的功能 处理机管理 存储器管理 文件管理 设备管理 目标 安全 高效 为上层提供服务 普通用户 GUI 命令接口 软件&#x2F;程序员 程序接口&#x2F;系统调用 基本特征 并发: 宏观上同时发生，微观上交替发生，CPU的调度 共享: 多个进程共同使用同一资源 虚拟: 对资源的抽象（虚拟内存，分时CPU等） 异步: 多道程序环境下，IO资源有限，带来的时间等待 并行：宏观和微观上都是同时发生，多核CPU 运行机制两类程序 内核程序: 多个内核程序组成操作系统内核 应用程序: 基于操作系统之上的的应用程序 两种指令 特权指令: 只允许操作系统调用（保护计算机安全） 非特权指令: 可以被上层应用程序调用 两种处理器状态 内核态 用户态 CPU通过内核态和用户态区分特权指令，CPU通过程序状态字寄存器（PSW）标志位区分内核态还是用户态 内核态-&gt;用户态: 执行特权指令修改PSW标志位 用户态-&gt;内核态: 通过中断引发，由硬件自动完成 中断中断是操作系统内核夺回CPU的使用权的的唯一途径（用户态-&gt;内核态） 内中断: CPU内部触发 陷阱，陷入：由程序主动引发，如系统调用 故障：由错误条件引起，内核修复故障后，会把CPU使用权还给程序，如缺页故障 终止：由致命错误引起的，CPU无法修复，会终止引用程序，如除数为0，非法执行特权指令 外中断: 每一条指令执行结束时，CPU都会检查是否有外中断信号（由硬件完成，效率高） 时钟中断（50nm）实现并发 IO设备发出的中断信号(如：打印机准备就绪) 系统调用应用程序通常使用操作系统提供的一组应用程序接口（库函数）来使用系统的服务，而这些应用程序接口由一组系统调用组成，更底层 应用程序: 可以直接使用库函数，也可以直接使用系统调用(比较少) 库函数：通常由编程语言通过库函数的方式提供，封装了系统调用，有些库函数不包含系统调用 系统调用（可以通过汇编语言调用） 系统调用是操作系统对底层资源管理的抽象，可以让上层更安全的使用系统资源，凡事与共享资源有关的操作（存储&#x2F;IO&#x2F;文件），都必须通过系统调用的方式向操作系统内核提出服务请求，保证系统的稳定性和安全性，防止用户非法操作，主要分为下面几类 设备管理: 启动&#x2F;请求&#x2F;释放 文件管理: 读&#x2F;写&#x2F;创建&#x2F;删除 进程控制: 创建&#x2F;阻塞&#x2F;唤醒 进程通信: 消息传递&#x2F;信号传递 内存管理: 内存的分配&#x2F;回收 应用程序把对应的参数放到寄存器 调用陷入指令（trap），让CPU内核切换到内核态 CPU调用对应的系统调用（内核程序） CPU把使用权返还给应用程序 体系结构 底层 时钟管理 中断处理 原语 处于最底层，最接近硬件 原子性操作 运行时间短，调用频繁 管理 进程管理 存储器管理 设备管理 由于进程管理，存储器管理，设备管理不直接操作底层，也可以作为用户态执行 大内核&#x2F;宏内核: 将操作系统主要功能模块作为系统内核，运行在内核态 优点：高性能 缺点：内核代码庞大 常用操作系统：Linux，Unix 微内核：只保留最基本的功能在内核 优点：性能低 缺点：内核代码少，易维护 常用操作系统：Windows, MacOS","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://zhengbomo.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://zhengbomo.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"重学C++学习笔记（三）","slug":"cpp-learn-3","date":"2020-04-16T08:53:44.000Z","updated":"2020-04-16T08:53:44.000Z","comments":true,"path":"2020-04-16/cpp-learn-3/","link":"","permalink":"http://zhengbomo.github.io/2020-04-16/cpp-learn-3/","excerpt":"接上一篇，本篇主要是针对C++的新特性介绍，包括异常和智能指针","text":"接上一篇，本篇主要是针对C++的新特性介绍，包括异常和智能指针 异常异常函数，抛出异常用throw xxx; 123456789101112131415161718192021// 默认情况下表示可能会抛出任何异常int divide(int v1, int v2) &#123; ...&#125;// 声明不会抛出任何异常int divide(int v1, int v2) throw () &#123; ...&#125;// 声明会抛出const char *类型的异常int divide(int v1, int v2) throw (const char *) &#123; if (v2 == 0) &#123; // 抛出异常 throw &quot;不能除于0&quot;; // 不会执行 cout &lt;&lt; &quot;后面当操作&quot; &lt;&lt; endl; &#125; return v1/ v2;&#125; try-catch捕获异常 12345678try &#123; int *p = new int[999999];&#125; catch (int exception) &#123; cout &lt;&lt; &quot;捕获异常&quot; &lt;&lt; exception &lt;&lt; endl&#125; catch(...) &#123; // 三个点表示可以捕获所有类型的异常 cout &lt;&lt; &quot;内存不足&quot; &lt;&lt; endl&#125; throw异常后，会在当前函数中查找匹配的catch，找不到就终止当前函数代码，去上一层函数中查找。如果最终都找不到匹配的catch，整个程序就会终止 C++标准库提供了很多常用的异常，放在std命名空间下，开发中可以使用这些异常，让代码语义更明确，如下 std::exception std::bad_alloc std::bad_cast std::bad_exception std::bad_typeid std::logic_error std::domain_error std::invalid_argument std::length_error std::out_of_range std::runtime_error std::overflow_error std::range_error std::underflow_error 智能指针由于函数执行的流程不可预测，异常处理会带来内存管理的问题，C++引入智能指针解决内存管理的问题 auto_ptr（已废弃）：自动管理内存的释放 1234567891011121314#include &lt;memory&gt;#include &lt;string&gt;&#123; // 1. 创建一个auto_ptr指针变量p1，当p1释放时，&quot;hello&quot;也会被释放，不需要手动释放hello字符串 auto_ptr&lt;string&gt; *p1 = new string(&quot;hello&quot;); // 不需要手动释放，当变量p1释放的时候（栈空间被回收），就会自动释放 // delete p1; // 2. p1将所有权转让给p2，p1会指向nullptr，而p2指向&quot;hello&quot; auto_ptr&lt;string&gt; p2 = p1;&#125; unique_ptr：自动管理内存释放，且内存只能有一个指针变量引用，不支持赋值和复制 123456789101112#include &lt;memory&gt;std::unique_ptr&lt;Task&gt; p1(new string(&quot;hello&quot;));// 通过 unique_ptr 访问其成员string *s1 = p1.get();// 编译不通过，不能支持赋值std::unique_ptr&lt;Task&gt; p2 = p1;// 可以通过std::move转移所有权到p2，此时p1指向nullptrstd::unique_ptr&lt;Task&gt; p2 = std::move(p1); shared_ptr：通过引用技术共享对象，对象内部存储引用技术，当引用技术为0的时候，则进行析构，与ObjC的ARC技术类似 123456shared_ptr&lt;string&gt; p1(new string(&quot;hello&quot;));// 引用计数为1cout &lt;&lt; p1.use_count() &lt;&lt; endl;auto p2 = p1// 引用计数为2cout &lt;&lt; p1.use_count() &lt;&lt; endl; weak_ptr：由于shared_ptr存在循环引用的问题，weak_ptr用于弱引用对象（引用计数不加1）与strong_ptr配合使用 自己实现auto_ptr指针，通过栈上的局部变量管理 12345678910111213141516171819202122232425template &lt;typename T&gt;class SmartPoint &#123;private: T *m_obj;public: SmartPoint(T *obj): m_obj(obj) &#123; &#125; ~SmartPoint() &#123; if (m_obj != nullptr) &#123; delete m_obj; &#125; &#125; // 重写变量访问 T *operator-&gt;() &#123; return m_obj; &#125;&#125;void main() &#123; &#123; // 由于p是存放在栈空间，当p释放的时候，内部的Person也会被释放 SmartPoint&lt;Person&gt; p(new Person(20)); p-&gt;run(); &#125;&#125; 模板（泛型）C++通过模板实现泛型，模板其实是相当于语法糖，在编译的时候自动生成对应的方法，如果方法没有使用，则不会被编译 1234567891011121314151617181920212223// 模板方法-单参数// template &lt;class T&gt; // 也可以使用class，是等价的template &lt;typename T&gt;T add(T a, T b) &#123; return a + b;&#125;int result = add&lt;int&gt;(10, 20);// 模板方法，多参数template &lt;typename TA, typename TB&gt; T add(TA a, TB b) &#123; return a + b;&#125;// 模板类template &lt;typename T&gt;class Array &#123; T *m_data; void add(T t) &#123; &#125;&#125; 编译细节 所有的.cpp文件都是单独编译的，编译成.obj目标文件，而对于外部符号（例如头文件的声明的符号）都通过占位的方式进行编译 编译完成后，通过链接器linker，链接所有的.obj，把所有的占位符号都修复成成真实的地址 为了解决模板编译的问题，把头文件改为.hpp，hpp文件既包含声明也包含实现，通常用来定义模板类和模板方法 C++新特性这里只列出一些常用的 auto关键字：自动识别类型，和其他语言的var差不多 12auto person = new Person();auto a = 10; decltype: 编译器特性，获取变量的类型 123int a = 10;// 相当于：int b = a + 1decltype(a) b = a + 1; nullptr: 空指针，解决NULl二义性问题 123456789void func(int a) &#123; &#125;void func(int *a) &#123; &#125;// 存在二义性问题func(NULL);// 用下面方式调用func(0);func(nullptr); for快速遍历 1234int items[] = &#123;1, 2, 3&#125;;for (auto item: items) &#123; ...&#125; lambda表达式: [capture] (params) mutable exception -&gt; returntype &#123; body &#125; 12345678910111213141516171819202122232425262728293031323334353637int g = 10;int h = 20// 捕获局部变量g，参数为int，返回值为voidvoid (*p)(int) = [g] (int a) -&gt; void &#123; cout &lt;&lt; a &lt;&lt; g &lt;&lt; endl&#125;;// 可以用auto，自动识别类型，用=隐式捕获用到的变量auto p1 = [=] (int a) -&gt; void &#123; cout &lt;&lt; a &lt;&lt; g &lt;&lt; endl&#125;;// 引用捕获auto p1 = [&amp;g] (int a) -&gt; void &#123; cout &lt;&lt; a &lt;&lt; g &lt;&lt; endl&#125;;// 隐式引用捕获，g为值捕获auto p1 = [&amp;, g] (int a) -&gt; void &#123; cout &lt;&lt; a &lt;&lt; g &lt;&lt; endl&#125;;// 值捕获变量修改，添加mutable，可以修改捕获变量，修改了也还是值捕获，不会作用到外部auto p1 = [g] (int a) mutable -&gt; void &#123; g++; cout &lt;&lt; a &lt;&lt; g &lt;&lt; endl&#125;;// 如果能推断返回值类型，也可以返回值auto p2 = [](int a)&#123; cout &lt;&lt; a &lt;&lt; endl return a;&#125;;p();p2();","categories":[{"name":"C++","slug":"C","permalink":"http://zhengbomo.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://zhengbomo.github.io/tags/C/"}]},{"title":"Swift Annotating","slug":"annotating-swift-code","date":"2020-04-14T01:51:28.000Z","updated":"2020-04-14T01:51:28.000Z","comments":true,"path":"2020-04-14/annotating-swift-code/","link":"","permalink":"http://zhengbomo.github.io/2020-04-14/annotating-swift-code/","excerpt":"除了普通的代码注释外，编译器通常也会提供一些辅助开发的注释，例如TODO，FIXME，ERROR之类的注释，这些注释可以被编译器识别到，并提供一些友好提示，我们应该多利用这些编译器的特性来辅助我们日常的开发","text":"除了普通的代码注释外，编译器通常也会提供一些辅助开发的注释，例如TODO，FIXME，ERROR之类的注释，这些注释可以被编译器识别到，并提供一些友好提示，我们应该多利用这些编译器的特性来辅助我们日常的开发 TODO1234func takePicture() -&gt; Bool &#123; // TODO: Do camera stuff return true&#125; FIXME1234func increment(_ num: Int) -&gt; Int &#123; // FIXME: Make this increment the input return num&#125; warning通过warning提示警告⚠️，可以编译通过 12345func increment(_ num: Int) -&gt; Int &#123; // FIXME: Make this increment the input #warning(&quot;Incorrect result returned&quot;) return num&#125; errorerror警告会编译不通过 1234567func readArr(_ arr: [Int]) &#123; for i in 0…arr.count &#123; if i == arr.count &#123; #error(“err”) &#125; &#125;&#125; 模拟器在模拟器调试的特殊代码，相当于宏隔离，模拟器的代码不会编译到真机 12345678@discardableResultfunc takePicture() -&gt; Bool &#123; #if targetEnvironment(simulator) return false #else return true #endif&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://zhengbomo.github.io/tags/Swift/"}]},{"title":"重学C++学习笔记（二）","slug":"cpp-learn-2","date":"2020-04-11T07:45:22.000Z","updated":"2020-04-11T07:45:22.000Z","comments":true,"path":"2020-04-11/cpp-learn-2/","link":"","permalink":"http://zhengbomo.github.io/2020-04-11/cpp-learn-2/","excerpt":"接上一篇，本篇主要是面向对象相关的知识点","text":"接上一篇，本篇主要是面向对象相关的知识点 类C++可以使用struct和class定义一个类 12345678910111213141516// 默认为public权限struct Person &#123; int age; void run &#123; cout &lt;&lt; &quot;person run&quot; &lt;&lt; endl; &#125;&#125;;// 默认为private，需要显示声明publicclass Person &#123;public: int age; void run &#123; cout &lt;&lt; &quot;person run&quot; &lt;&lt; endl; &#125;&#125; struct和class的区别: class默认权限为private，struct默认权限为public，推荐使用class 嵌套类C++中类支持嵌套定义，本质是语法糖，用于限制作用域 12345678910111213class Person &#123; class Car &#123; &#125;&#125;void func() &#123; // 局部类，可以在函数内使用 class Point &#123; int x; int y; &#125;&#125; 函数调用123Person p;p.age = 20;p.run(); 转成汇编 1234567mov d word ptr [ebp-0Ch], 0Ah; 传递调用者到exc，也就是plea ecx, [ebp-0Ch]; 调用函数call 00061366 C++对象的内存结构如下 对象的本质，其实就是字段（和虚表指针）的内存集合，先定义的对象会放在低地址，后定义的对象防止高地址 thisthis是调用对象的地址，为指针，当对象调用成员函数的时候，会自动传入当前对象的指针 1234567891011121314151617181920212223class Person &#123;private: int m_age;public: void func() &#123; this -&gt; m_age = 0; // 编译成汇编 // 0x10c9c2f7c &lt;+12&gt;: movl $0x0, (%rax) ; 取到寄存器rdx存放的地址，给该地址赋值0 &#125;&#125;;int main() &#123; Person p = Person(); p.func(); return 0; // 生成汇编（AT&amp;T） // 0x10c9c2f50 &lt;+32&gt;: movq %rax, -0x10(%rbp) ; 设置p变量 // 0x10c9c2f54 &lt;+36&gt;: callq 0x10c9c2f8a ; 初始化Person的内存 // 0x10c9c2f59 &lt;+41&gt;: movq -0x10(%rbp), %rdi ; 将p的地址赋值给寄存器rdi // 0x10c9c2f5d &lt;+45&gt;: callq 0x10c9c2f84 ; 调用函数&#125; 由汇编可以看出，通过寄存器传递this指针，this指针存放对象的地址 堆空间初始化12345678910int *p1 = new int; // 不会被初始化int *p2 = new int(); // 初始化为0int *p3 = new int(5); // 初始化为5int *p4 = new int[3]; // 数组未被初始化int *p5 = new int[3](); // 数组元素都被初始化为0int *p6 = new int[3]&#123;&#125;; // 数组元素都被初始化为0int *p7 = new int[3] &#123;5&#125;; // 数组首元素被初始化为5，其他被初始化为0Person *p8 = new Person; // 成员变量不会被初始化Person *p9 = new Person(); // 成员变量默认被初始化为0，或调用构造函数 对象内存分布1234567891011// 全局变量，全局区Person g_person;int main() &#123; // 局部变量，栈空间 Person person; // 手动申请内存，堆空间 Person *p = new Person(); return 0;&#125; 构造函数&#x2F;析构函数构造函数支持重载 12345678910111213141516171819struct Person &#123; int m_age; Person() &#123; m_age = 10; &#125; // 重载构造函数 Person(int age) &#123; m_age = age; &#125; // 析构函数，只有一个 ~Person() &#123; // 对象释放之前调用 &#125;&#125;;Person person(20);cout &lt;&lt; person.age &lt;&lt; endl; 如果自定义了构造函数，除了全局区（默认会初始化为0），其他内存空间的成员变量都需要手动初始化 123456789struct Person &#123; int age; Person() &#123; // age的值不确定，需要手动初始化age变量 // 所有成员初始化为0 msmset(this, 0, sizeof(Person)); &#125;&#125;; 构造函数和析构函数必须是public，如果定义为private，则该类无法被外部创建构造函数先调用父类，后调用子类析构函数先调用子类，后调用父类 成员访问权限权限与JAVA一样，对类的成员变量声明权限（struct默认为public，class默认为private） public：公开访问（struct默认） protected：当前类和子类访问 private：私有（class默认） 继承关系也可以添加权限，表示继承的成员对子类的权限，struct默认为public，class默认为private，class要手写public 1234// Student的子类不能访问Person的成员，叠加权限使用最小权限struct Student: private Person &#123; int m_score;&#125;; 初始化列表123456789101112131415struct Person &#123; int m_age; int m_height; // Person(int age, int height) &#123; // m_age = age; // m_height = height; // &#125; // 与上面构造方法等价 Person(int age, int height): m_age(age), m_height(height) &#123; &#125;&#125;; 初始化顺序跟成员变量的声明顺序有关系，和列表顺序无关，下面写法是一样的 1234Person(int age, int height): m_age(age), m_height(height) &#123; &#125;// 与上面等价，先初始化m_age，再初始化m_heightPerson(int age, int height): m_height(height), m_age(age) &#123; &#125; 构造函数互相调用123456789101112131415struct Person &#123; int m_age; int m_height; // 必须写在后面 Person() : Person(0, 0) &#123; // 这里相当于创建一个新的对象 // Person(0, 0); &#125; Person(int age, int height) &#123; m_age = age; m_height = height; &#125;&#125;; 父类的构造函数123456789101112131415161718192021struct Person &#123;private: int m_age; Person() &#123; m_age = 0; &#125; Person(int age): m_age(age) &#123; &#125;&#125;;struct Student : Person &#123; // 默认是调用无参构造函数 // Student() : Person() &#123; // 显示调用父类构造函数 Student() : Person(10) &#123; &#125;&#125;; 如果父类没有构造函数，则不调用 如果父类有构造函数，子类没有定义构造函数，则子类会隐式生成构造函数，并且调用父类的构造函数 调用父类方法继承关系中调用父类方法，通过类名调用 12345678910111213141516171819class Person &#123;public: void func() &#123; &#125;&#125;class Student: public Person &#123;public: void func() &#123; // 调用父类方法，相当于swift的super.func() Person::func(); &#125; //运算符重载 Student &amp;operator=(const Student &amp;student) &#123; // 调用父类的方法 Person::operator=(student); ... &#125;&#125; 拷贝构造函数123456789101112131415161718192021222324class Person &#123;public: int m_age; // 默认无参构造函数 Person() &#123;&#125; // 拷贝构造函数，赋值操作会调用拷贝构造函数 Person(const Person &amp;person): m_age(person.m_age) &#123; &#125;&#125;;int main() &#123; // p1, p2通过无参构造函数构造 Person p1 = Person(); Person p2; // p3, p4通过拷贝构造函数构造 Person p3 = p1; Person p4(p1); // 非初始化赋值，直接做变量内存拷贝，不会调用构造函数 p2 = p1; return 0;&#125; 隐式构造1234567891011class Person &#123;private: int m_age;public: Person(int age): m_age(age) &#123; &#125;&#125;;Person p1(10);// 隐式构造，相当于：Person p2 = Person(20)Person p2 = 20; 可读性差，尽量不用，可以通过关键字explicit禁用隐式构造 12// 不能通过 Person p2 = 20; 构造explicit Person(int age): m_age(age) &#123; &#125; 自动生成构造函数在下面情况下，编译器会自动为类生成无参构造函数 父类存在构造函数，子类没有定义构造函数 虚继承（需要做虚表指针的初始化） 有虚函数（需要做虚表指针的初始化） 类包含了有构造函数的成员，并且没有定义构造函数，则编译器会自动生成构造函数初始化成员 类的字段在声明的时候进行了初始化 仿函数相当于直接调用对象，本质是重载()运算符 12345678910class Sum &#123;public: int operator()(int a, int b) &#123; return a + b; &#125;&#125;auto sum = Sum();// res = 30auto res = sum(10, 20); 深拷贝&#x2F;浅拷贝 浅拷贝: 编译器默认提供的拷贝为浅拷贝，将一个对象所有成员变量的值拷贝到另一个对象（指针变量只拷贝地址，不会拷贝指针指向的内存空间），浅拷贝会带来一个问题，就是多次free的问题 12345678910111213141516171819202122232425262728class Car &#123;public: Car() &#123;&#125;&#125;;class Person &#123;private: int m_age; Car *car;public: Person() &#123; car = new Car(); &#125; ~Person() &#123; if (car != nullptr) &#123; delete car; car = nullptr; &#125; &#125;&#125;;int main() &#123; &#123; // 下面代码会导致Person的析构函数调用了两次 Person p1 = Person(); Person p2 = p1; &#125;&#125; 深拷贝：需要自定义拷贝构造函数实现，手动将指针类型的变量指向的内容拷贝一份新的 多态C++的多态通过虚函数来实现 虚函数需要在父类方法实现virtual函数才能使用多态，否则不是多态（不加virtual，编译器直接根据类型调用对应的函数） 123456789101112131415161718192021222324252627struct Animal &#123; void speak() &#123; cout &lt;&lt; &quot;animal speak&quot; &lt;&lt; endl; &#125;&#125;;struct Dog: Animal &#123; // 子类不用声明virtual，默认就是虚函数 void speak() &#123; cout &lt;&lt; &quot;dog speak&quot; &lt;&lt; endl; &#125;&#125;;void func(Animal *ani) &#123; // 由于speak是普通函数，编译之后，会直接调用Animal::speak ani.speak(); // call [0A3C] ; Animal::speak&#125;int main() &#123; Dog *dog = new Dog(); func(dog); // 输出 animal speak，而我们希望输出 dog speak delete dog; return 0;&#125; 修改Animal::speak改为virtual 1234567struct Animal &#123; virtual void speak() &#123; cout &lt;&lt; &quot;animal speak&quot; &lt;&lt; endl; &#125;&#125;;// 输出 `dog speak` 纯虚函数：没有实现的虚函数，后面用等于0 抽象类：含有纯虚函数的类，抽象类不能被实例化 12345struct Animal &#123; // 纯虚函数，等于0是固定写法 virtual void speak() = 0; virtual void run() = 0;&#125; 虚表虚函数的多态特性是通过虚表来实现的，如果一个类对象有虚函数，则会多4或8个字节，32或64位环境不同，并且多出来的内存是放在对象首地址 12345678910111213struct Animal &#123; int m_age; virtual void speak() &#123; cout &lt;&lt; &quot;animal speak&quot; &lt;&lt; endl; &#125; virtual void run() &#123; cout &lt;&lt; &quot;animal run&quot; &lt;&lt; endl; &#125;&#125;;cout &lt;&lt; sizeof(Animal) &lt;&lt; endl;// 输出8 (4 + 4）(x86环境) 原理：多出的4&#x2F;8个字节用来存储虚函数表的地址，虚函数表存放着对象的虚函数地址，编译器在运行时通过该表，找到对应的函数地址执行，从而达到多态的目的 1234567891011121314Animal *ani = new Dog();// speak是虚函数ani.speak();// 编译为汇编// mov eax, dword ptr [epb-8] ; [epb-8]是ani指向的地址，即Dog的地址// mov edx, dword ptr [eax] ; 取出eax头4个自己的值（即虚表地址），存放到edx// mov eax, dword ptr [edx] ; 取出edx的前4个字节（即虚表中的第一个函数地址），存放到eax// call eax ; 调用寄存器eax指向的函数地址ani.run();// 转成汇编和speak方法是一样的，在从虚表取函数地址的时候，会加上对应的偏移量// mov eax, dword ptr [edx+4] ; 从edx地五个字节开始读（即虚表中的第二个函数地址），存放到eax 从汇编代码可以看出，虚函数的调用过程 通过对象存放的虚表地址（对象首地址） 通过虚表地址找到虚表，从虚表中找到对应函数的地址 调用函数 同个类所有对象共用一份虚表，不管对象使用什么指针接收，最终都会调用虚表的方法，也就是对象真正的方法 注意：如果子类没有重写父类的虚函数，父类的虚函数编译的时候也会被放到子类的虚表里面，也就是函数调用在编译的时候就确定了，如下 12345678910111213141516struct Animal &#123; virtual void speak() &#123; &#125; virtual void run() &#123; &#125;&#125;struct Dog : Animal &#123; void run() &#123; &#125;&#125;struct WhiteDog: Dog &#123;&#125;WhiteDog *dog = new WhiteDog();// dog对象的虚表存放了 Dog::run 和 Animal::speak 方法的地址 多态的调用行为在编译后就确定了，而不是运行时动态确定 多态-析构函数由于C++多态使用的虚表实现的，对于多态，析构函数也要使用虚函数 12345678910111213141516171819using namespace std;struct Animal &#123; // 父类的析构函数 ~Animal &#123; cout &lt;&lt; &quot;Animal::~Animal&quot; &lt;&lt; endl; &#125;&#125;struct Dog: Animal &#123; // 父类的析构函数 ~Dog &#123; cout &lt;&lt; &quot;Dog::~Dog&quot; &lt;&lt; endl; &#125;&#125;Animal *ani = new Dog();// 这里值调用Animal的析构函数，不会调用Dog的析构函数delete ani; 需要把Animal的析构函数设置为virtual 123456struct Animal &#123; // 父类的析构函数 virtual ~Animal &#123; cout &lt;&lt; &quot;Animal::~Animal&quot; &lt;&lt; endl; &#125;&#125; 多态继承如果要用父类指针指向子类对象，则继承的权限必须是public 123456789class Person &#123; &#125;// 必须public继承Personclass Student: public Person &#123;&#125;// 多态Person *person = new Student() 调用父类方法直接通过类名调用 123456789101112131415161718192021using namespace std;struct Animal &#123; virtual void speak() &#123; cout &lt;&lt; &quot;animal speak&quot; &lt;&lt; endl; &#125; void run() &#123; &#125;&#125;struct Dog: Animal &#123; void speak() &#123; // 直接调用父类的方法 Animal::speak(); // 调用父类的成员函数 Animal::run(); cout &lt;&lt; &quot;animal speak&quot; &lt;&lt; endl; &#125;&#125; 多继承C++支持多继承（不建议使用，会增加程序设计的复杂度） 1234567891011121314151617181920212223242526272829class Student &#123;public: int m_score; void study() &#123; &#125;&#125;;class Worker &#123;public: int m_salary; void work() &#123; &#125;&#125;;class Undergraduate: public Student, public Worker &#123;public: int m_grade; void play() &#123; &#125;&#125;;int main() &#123; Undergraduate ug; ug.m_score = 10; ug.m_salary = 20; ug.m_grade = 30; ug.study(); ug.work(); ug.play(); return 0;&#125; 内存分布 多继承-虚函数多继承的多态也是通过虚函数实现的，单继承一样，但是由于又多个父类，多继承会又多个虚表地址 多继承的子类会产生多张虚表，分别对应不同父类 12345678910111213141516171819202122232425262728293031class Student &#123;public: int m_score = 1; virtual void func() &#123; cout &lt;&lt; &quot;student func&quot; &lt;&lt; endl; &#125;&#125;;class Worker &#123;public: int m_salary = 2; virtual void func() &#123; cout &lt;&lt; &quot;worker func&quot; &lt;&lt; endl; &#125;&#125;;class Undergraduate : public virtual Student, public virtual Worker &#123;public: int m_grade = 3; void func() &#123; cout &lt;&lt; &quot;undergraduate func&quot; &lt;&lt; endl; &#125;&#125;;int main() &#123; Undergraduate *undergraduate = new Undergraduate(); Student *stu = undergraduate; cout &lt;&lt; stu-&gt;m_score; &lt;&lt; endl; stu-&gt;func(); return 0;&#125; 同名函数&#x2F;变量问题对于同名变量，C++默认会当成多个变量来存储 12345678910111213141516171819202122232425class Student &#123;public: int m_age = 1;&#125;class Worker &#123;public: int m_age = 2;&#125;class Undergraduate &#123;public: int m_age = 3;&#125;int main() &#123; Undergraduate *under = new Undergraduate(); // 默认访问 Undergraduate::m_age == 3 cout &lt;&lt; under-&gt;m_age &lt;&lt; endl; // 多态，这里不支持，需要通过虚继承实现 Student* stu = under; // 访问的是Student::m_age == 1 cout &lt;&lt; stu-&gt;m_age &lt;&lt; endl; return 0;&#125; 内存分布 菱形继承由于C++支持多继承，所以会出现菱形继承这种情况，我们知道子类会继承父类的所有成员变量（包括同名的） 1234567891011121314151617181920212223242526272829303132class Person &#123;public: int m_age = 1;&#125;;class Student: public Person &#123;public: int m_score = 2;&#125;;class Worker: public Person &#123;public: int m_salary = 3;&#125;;class Undergraduate : public Student, public Worker &#123;public: int m_grade = 4;&#125;;int main() &#123; Undergraduate *under = new Undergraduate(); // 不能直接引用，存在二义性，下面代码报错 under-&gt;m_age = 10; // 可以通过指定类类访问 under-&gt;Student::m_age = 11; under-&gt;Worker::m_age = 11; return 0;&#125; Undergraduate的内存分布 虚继承上面Undergraduate会继承两份Person的成员m_age，为了避免这种情况（通常我们希望只继承一份成员变量），C++使用虚继承解决 1234567891011121314151617181920212223242526272829class Person &#123;public: int m_age = 1;&#125;;// 虚继承基类class Student: virtual public Person &#123;public: int m_score = 2;&#125;;// 虚继承基类class Worker: virtual public Person &#123;public: int m_salary = 3;&#125;;class Undergraduate : public Student, public Worker &#123;public: int m_grade = 4;&#125;;int main() &#123; Undergraduate *under = new Undergraduate(); under-&gt;m_age = 10; cout &lt;&lt; sizeof(Undergraduate) &lt;&lt; endl; return 0;&#125; 内存分布 可以看到出多了两个虚表，用于声明基类字段m_age的偏移量，m_age只有一份 静态成员 静态成员存储在数据段（全局区）整个程序运行过程中只有一份内存 C++的静态成员必须初始化，并且必须在类外面初始化 1234567class Student &#123; // 声明 static int m_count;&#125;;// 初始化int Student::m_count = 10; 友元友元方法：可以在类外部的方法访问类的所有成员（字段和方法）友元类：可以在其他类访问类的所有成员（字段和方法） 1234567891011121314151617181920212223242526272829303132class Point &#123; // 声明友元方法 friend Point add(const Point &amp;a, const Point &amp;b); // 声明友元类 friend class Math;private: int m_x; int m_y; // 私有方法 void func() &#123; &#125;public: Point(int x, int y): m_x(x), m_y(y) &#123; &#125;&#125;;Point add(const Point &amp;a, const Point &amp;b) &#123; // 在这里可以直接访问Point的私有变量 return Point(a.m_x + b.m_x, a.m_y + b.m_y);&#125;class Math &#123; void func() &#123; Point p = Point(1, 2); // 可以访问类的私有成员 p.m_x = 10; p.m_y = 20; // 访问私有方法 p.func(); &#125;&#125;; 下一篇主要是C++的新特性","categories":[{"name":"C++","slug":"C","permalink":"http://zhengbomo.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://zhengbomo.github.io/tags/C/"}]},{"title":"重学C++学习笔记（一）","slug":"cpp-learn-1","date":"2020-04-06T14:56:44.000Z","updated":"2020-04-06T14:56:44.000Z","comments":true,"path":"2020-04-06/cpp-learn-1/","link":"","permalink":"http://zhengbomo.github.io/2020-04-06/cpp-learn-1/","excerpt":"越深入底层，C&#x2F;C++的作用就越大，对于底层的了解比别人更具体，工作中由于不是主要语言，用的少，近来有空，重新完整的过了一遍C++的语法和一些内存知识，在这里做一下笔记","text":"越深入底层，C&#x2F;C++的作用就越大，对于底层的了解比别人更具体，工作中由于不是主要语言，用的少，近来有空，重新完整的过了一遍C++的语法和一些内存知识，在这里做一下笔记 基础语法数据类型 int &#x2F; short &#x2F; long, &#x2F; long long：默认都为signed，也可以加unsigned变为无符号数 123int a = 10;uint a = 10u;long a = 10l; float &#x2F; double, long double：默认都为signed，也可以加unsigned变为无符号数 bool：本质是1和0 char(1个字节) &#x2F; wchar_t(2个字节) 12char a = &#x27;a&#x27;;wchar_t a = L`a`; 进制表示 十进制：int a = 10; 十六进制：int a = 0xF2; 八进制: int a = 070;（以0开头） 运算符 算数运算符: +,-,*,/,%,++,-- 关系运算符: ==, !=, &gt;, &lt;, &gt;=, &lt;= 逻辑运算符: &amp;&amp;, ||, ! 位运算符: &amp;, |, ~（取反） ^（异或）, &lt;&lt;, &gt;&gt; 赋值运算符: =, +=, -=, *=, /=, %= 其他运算符: 获取变量大小：sizeof（不是运算符，为编译器特性） 三元运算符：? : 取址运算符: &amp; 取值运算符: * 运算符重载 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Point &#123; // 友元函数，为了访问私有变量 const Point operator-(const Point a, const Point b);private: int m_x; int m_y;public: Point(int x, int y): m_x(x), m_y(y) &#123; &#125; // 加号运算符 cosnt Point operator+(const Point &amp;point) const &#123; return Point(m_x + point.m_x, m_y + point.m_y); &#125; // 返回引用，用于支持（a += b） = 1 Point &amp;operator+=(const Point &amp;point) &#123; m_x += point.m_x; m_y += point.m_y; return *this; &#125; // 单目运算: Point p2 = -p1; const Point operator-() const &#123; return Point(-m_x, -m_y); &#125; // 前置运算符: Point p2 = ++p1; Point &amp;operator++() &#123; m_x += 1; m_y += 1; return *this; &#125; // 后置运算符: Point p2 = ++p1; const Point operator++(int) &#123; Point temp(m_x, m_y); m_x += 1; m_y += 1; return temp; &#125;&#125;;// 定义在外面const Point operator-(const Point a, const Point b) &#123; return Point(a.m_x - b.m_x, a.m_y + b.m_y);&#125;int main() &#123; auto p1 = Point(1, 2); auto p2 = Point(3, 4); // p3 = Point(4, 6); auto p3 = p1 + p2; // p4 = Point(2, 2); auto p4 = p2 - p1; return 0;&#125; +运算符 第一个const：用于限制不能当成左值(p1 + p2) = Point(1, 2) 第二个const：用于让参数接受const和非const变量 第三个const：用于声明为const函数，让返回值const支持二次操作p1 + p2 + p3 +=运算符 返回引用，用于支持(a += b) = 1 关于位运算 左移：移走位补0 右移： 逻辑右移：移走位补0 算数右移：对于有符号数，正数移走位补0，负数移走位补1 具体使用逻辑右移还是算数右移，取决于编译器，所以，尽量不要使用右移运算符 流程控制 if-else switch-case do-while for: C++11支持下面集合遍历 1234int items[] = &#123;1, 2, 3&#125;;for (auto item: items) &#123; cout &lt;&lt; item &lt;&lt; endl;&#125; 头文件重复引用 使用#define宏防止重复导入 123456#ifndef __HEADER_H#define __HEADER_H...#endif 在文件头使用#pragma once也可以防止重复导入（旧的编译器可能不支持），通常放在文件头 123#pragma once... 注释C++的注释与C语言一样 123456// 单行注释/* 多行注释 多行注释*/ 不支持嵌套注释 auto自动类型在C++11添加了auto用于自动推断类型，为编译器特性，免去长长的类型声明 1234// 编译器会自动推断出i的类型，下面语句等价auto i = unique_ptr&lt;int&gt;(new int(10));unique_ptr&lt;int&gt; i = unique_ptr&lt;int&gt;(new int(10)); const1234567891011121314int age = 10;// p1不是常量，*p1是常量const int *p1 = &amp;age;// 与p1一样int const *p2 = &amp;age;// p3是常量，*p3不是常量int * const p3 = &amp;age;// p4是常量，*p4是常量const int * const p4 = &amp;age;// 与p4一样int const * const p5 = &amp;age; const修饰的是右边的内容const还能用于修饰函数参数，让引用参数接受常量参数，见后面 头文件和实现文件分离头文件person.h 123456789class Person &#123;private: int m_age;public: void setAge(int age); int getAge(); Person(); ~Person();&#125; 实现文件person.cpp 1234567891011121314#include &quot;Person.h&quot;void Person::setAge(int age) &#123; m_age = age;&#125;int Person::getAge() &#123; return m_age;&#125;Person::Person() &#123; m_age = 0;&#125;Person::~Person() &#123; // ...&#125; 命名空间12345678910111213141516171819202122232425262728293031323334namespace BM &#123; class Person &#123; int m_age; int m_height; &#125; void func() &#123; &#125; // 命名空间支持嵌套 namespace SS &#123; // ... &#125;&#125;// 全局命名空间// 可以通过`::func`访问// 默认情况下不用加`::`void func() &#123;&#125;BM::Person person = new BM::Person();// 只用命名空间的部分成员using BM::Person;// 使用using之后不用加前缀using namespace BM;// 访问命名空间里面的方法BM::func()// 访问全局命名空间::func() 命名空间不影响内存布局 命名空间可以在代码块使用 命名空间可以合并 1234567891011namespace BM &#123; int g_age;&#125;namespace BM &#123; int g_height;&#125;// 上面与下面等价namespace BM &#123; int g_age; int g_height;&#125; 引用（Reference）12345678910111213// 变量int age = 10;// 引用变量，相当于age的别名，定义的时候就要赋值int &amp;rage = age;// 相当于：age = 20rage = 20;int height = 20;// rage赋值后不能修改，下面相当于rage = 20，rage还是引用agerage = height 交换两个数 1234567891011void swap(int &amp;a, int &amp;b) &#123; int tmp = a; a = b; b = tmp;&#125;int a = 10;int b = 20;swap(a, b);// a为20，b为10 引用不可以修改指向，指针可以 本质：引用本质就是指针，只是从编译层面削弱了功能，增强了安全性，下面代码生成最终机器码是一样的 123456789int age = 10;// 指针int *p = &amp;age;*p = 30// 引用int &amp;ref = age;ref = 30; 数组的引用 12345678910int array[] = &#123;1， 2， 3&#125;;// 需要指定数组大小int (&amp;ref)[3] = array;// 使用指针接受引用int * const &amp;ref = array;// 使用autoauto &amp;ref = array; 常引用(const reference)12345int a = 10;const int &amp;b = a;// 无法修改引用的值，报错b = 20; 常引用作为函数参数时 12345678910111213// 使用const修饰参数，可以接受常量和变量int sum(const int &amp;a, const int &amp;b) &#123; return a + b&#125;int p = 10;int q = 20;// 可以接受变量sum(p, q);// 可以接受常量sum(p, 10); 指针变量三个重要信息 变量的内容 变量存放的地址 变量的类型 指针变量：专门用来记录变量地址的变量，通过指针变量可以间接访问另一个变量的值 未初始化和非法的指针 1234// a未初始化int *a;// 直接修改a指向的值，会出现不可预测的问题*a = 12; NULL指针：不指向任何东西，表示一种状态，指针变量不用时，或未初始化时，应置位NULL，在C++11之后，空指针使用nullptr 12345int *a = nullptr;if (a != nullptr) &#123; *a = 12;&#125; 野指针：指向垃圾（程序逻辑上用不到的指针）内存的指针，通常是被回收资源后未置空的指针，不再使用的指针变量应置为nullptr值 指针的基本操作： &amp;运算符: 取变量地址 *运算符：去指针指向地址的值 指针编译成汇编 12345678910int a = 10;// mov dword ptr [ebp-0Ch], 10 ; a的地址为[ebp-0Ch], a = 10int *p = &amp;a;// lea eax, [epb-0Ch] ; 取a的地址赋值到eax// mov dword ptr [ebp-18h], eax ; p的地址为[epb-18h]，把a的地址赋值给指针p，int *p = &amp;a;*p = 20;// mov eax, dword ptr [ebp-18h] ; eax = &amp;a;// mov dword ptr [eax], 20 ; 取出eax指向的地址，复制20，相当于 age = 20; 指针变量原理 12345678910111213Person person;person.age = 10;// mov dword ptr [ebp-14h], 0Ahperson.height = 20;// mov dword ptr [ebp-10h], 14hPerson *p = &amp;person;// lea eax, [ebp-14h] ; 将person的地址赋值给寄存器eax// mov dword ptr [epb-20h], eax ; 将寄存器eax的地址赋值给变量p(epb-20h)p-&gt;age = 10;// mov eax, dword ptr [epb-20h] ; 将变量p存放的地址赋值给eax，eax = &amp;person// mov dword ptr [eax], 0Ah ; 将eax指向对象赋值10 可以看出，通过指针针变量访问成员变量生成2条语句，一条取地址的值，第二条才是根据变量的偏移量取变量值，而普通变量访问成员变量会生成1条语句 1234567891011Person person;person.m_id = 10;person.m_age = 20;// 这里取的是 m_agePerson *p = (Person *)&amp;person.m_age;p-&gt;m_id = 30;cout &lt;&lt; person.m_id &lt;&lt; endl;cout &lt;&lt; person.m_age &lt;&lt; endl;// 输出: 10, 30 汇编很多时候（对于栈空间）是通过偏移量来操作对象和字段的 内存空间管理 malloc &#x2F; free：C语言的方式 new &#x2F; delete：C++的方式，推荐 new[] &#x2F; delete[]：数组空间 数组释放的时候和变量不一样，需要加中括号 12345678910111213// C语言申请空间int *p1 = (int *)malloc(4);*p1 = 20;free(p1);// C++申请空间int *p2 = new int;*p2 = 10;delete p2;// 如果是数组，delete也要加中括号char *p3 = new char[4];delete [] p3; 通常情况下申请的内存空间不会进行初始化（不同平台可能不一样） 12345678int *p1 = (int *)malloc(4);// 初始化p1 = 0;int size = sizeof(int) * 10;int *p2 = (int *)malloc(size);// 初始化，把所有空间清零memset(p2, 0, size); 如果是对象，new创建的对象会调用构造函数，而malloc不会，在C++中，推荐使用new在堆申请空间 类型转换C语言的类型转换 123int a = 10;long b = (int)a;double c = double(a) C++有四中类型转换符 static_cast: 通常基本数据类型转换，用于非const变量转换成const变量，由于C++有隐式转换，通常不用写 123456789101112int a = 10;// 下面两句等价double b = static_cast&lt;double&gt;(a);double b = a;Person *p1 = new Person();// 下面两句等价，C++默认会做隐式转换const Person *p2 = static_cast&lt;const Person *&gt;(p1);const Person *p2 = p1; dynamic_cast: 用于多态类型转换，如果不能转换，则返回nullptr 1234567891011121314151617Person *p1 = new Person();Person *p2 = new Student();// 父类不能赋值给子类，报错Student *stu1 = p1;// dynamic_cast会做运行时安全检查，类型不匹配时，会返回NULLStudent *stu2 = dynamic_cast&lt;Student *&gt;(p1);Student *stu3 = dynamic_cast&lt;Student *&gt;(p2);// 汇编：会调用一个函数进行// call __RTDynamicCast(0C14ABh) ; 调用方法判断类型，返回值放到eax，可能为NULl，可能为对象的值// add esp, 14h// mov dword ptr [stu1], eax// stu2 = NULLL// stu3 = p2 const_cast: 将const常量转换成非常量，有安全风险 1234567const Person *p1 = new Person();// 无法直接转换，报错Person *p2 = p1;// 下面两种转换等价Person *p2 = const_cast&lt;Person *&gt;p1;Person *p3 = (Person *)p1; reinterpret_cast: 纯二进制拷贝，没有类型检查 12345678910int a = 10;// 0A 00 00 00double b = a;// 00 00 00 00 00 00 24 40// 由于double类型和int的表示10不一样，所以下面b != 10;double c = reinterpret_cast&lt;double&amp;&gt;(a);// 0A 00 00 00 CC CC CC CC// -9.25596e+61 多余对象拷贝1234567891011Point func() &#123; // 1. 调用Point默认构造函数 Point p; return p;&#125;void main() &#123; // 2. 从func函数栈拷贝Point到main函数栈 // 3. 调用Point拷贝构造函数 Point p = func();&#125; 上面代码如果编译器不做优化的话，会调用3次Point的构造函数 在func函数栈构造Point 从func函数栈返回到main函数栈，会把返回值，通过拷贝构造函数拷贝到main函数栈 main函数中，返回值赋值给p，会调用Point的拷贝构造函数 编译器在编译的时候会做返回值优化(RVO)，不会造成多次拷贝，可以通过-fno-elide-constructors关闭该优化 C++程序内存分布 栈 堆 全局区&#x2F;静态区: 可读写 常量区: 只读 代码段: 只读 函数函数重载指函数名相同的函数，函数参数类型不同或函数参数顺序不同或函数参数个数不同，构成函数重载，函数重载与返回值类型无关（C语言不支持函数重载） 1234567891011// 下面函数都构成重载int sum(int a, int b);int sum(long a, long b);int sum(int a, int b, int c);int sum(int a, long b);int sum(long a, int b);// const引用(指针)与非const引用(指针)构成重载，下面两个函数是不同函数int sum(int &amp;a, int &amp;b);int sum(const int &amp;a, const int &amp;b); 本质：C++使用了name mangling或name decoration的技术，C++编译器在编译的时候会对函数名进行改编，修饰，不同的编译器修饰的规则可能不同，例如上面sum函数在VC++会编译下面方法名 1sum0, sum1, sum2, sum3, sum4, sum5, sum6 默认参数C++支持默认参数，如果有声明和实现，默认参数必须放在声明上 12345int sum(int a = 1, int b = 2);int sum(int a, int b) &#123; return a + b;&#125; 默认参数可以是常亮，全局符号 本质：编译器在编译阶段根据默认参数补完传参，也就是sum(1)和sum(1, 2)编译后的汇编代码是一样的 extern “C”使用extern &quot;C&quot;修饰的代码会按照C语言的方式编译 12345678910// func会被编译为C语言的方法extern &quot;C&quot; void func() &#123; // ...&#125;extern &quot;C&quot; &#123; // C语言代码 void func() &#123; // ... &#125;&#125; 如果函数声明和实现分开，声明需要加extern &quot;C&quot;，实现不加\b由于C++的函数有name mangling，extern &quot;C&quot;通常在C语言和C++混编的时候用到C语言不支持extern &quot;C&quot;，可以使用__cplusplus加判断 12345678910111213141516171819// C语言不支持extern符号#ifdef __cplusplusextern &quot;C&quot; &#123;#endif // 引用C头文件 #include &quot;header.h&quot;#ifdef __cplusplus&#125;#endif#ifdef __cplusplusextern &quot;C&quot; &#123;#endif int sum(int a, int b); int delta(int a, int b); int divide(int a, int b);#ifdef __cplusplus&#125;#endif 内联函数(inline)1inline void add(int a, int b) &#123; return a + b; &#125; 函数展开，类似于define的效果，省去函数调用开辟栈空间的操作 函数代码体积小（小于10行） 函数频繁使用 递归函数不会被编译为内联函数，即使声明了 其他知识点关于补码对于有符号数的正负3 十进制+3: 00000000 00000000 00000000 00000011十进制-3: 10000000 00000000 00000000 00000011 上面的表示并不方便计算（两个数想加），实际上，计算机使用补码的方式表示有符号数，在计算上有很大的优势 十进制+3: 00000000 00000000 00000000 00000011十进制-3: 11111111 11111111 11111111 11111101 使用补码是为了：用加法计算减法，性能更优，CPU不用单独再实现一个减法运算器 字节序（Byte Ordering） 大端法（Big Endian）: 高位字节在前，低位字节在后，这是人类读写数值的方法 小端法（Little Endian）: 低位字节在前，高位字节在后 为什么会有小端字节序？ 答案是，计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序 为什么会有大端字节序？ 人类习惯读写是大端字节序（从左到右）。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。 引用：https://www.cnblogs.com/gremount/p/8830707.html 内存对齐12345678910111213typedef struct &#123; int a; double b; short c;&#125; A;typedef struct &#123; int a; short b; double c;&#125; B;sizeof(A); // 24sizeof(B); // 26 C++的结构体是按变量的定义顺序进行存储的，也就是 a -&gt; b -&gt; c CPU从内存中读取数据时，有一个最小读取单位，例如64位的CPU，从内存的0地址开始，0-63bit的数据可以一次IO读取出来，64-127bit的数据也可以一次读取出来，每个次读取的单位是64，CPU和内存IO的硬件限制导致没办法一次跨在两个数据宽度中间进行IO，为了提高CPU读取效率，减少IO次数，编译器在编译代码的时候，会考虑到内存对齐的情况，例如上面结构体A会被编译为24个字节 如果结构体A不进行内存对齐的话，变量b与变量a靠在一起，就会导致，读取在变量b的时候，需要两次IO 命名法 匈牙利命名法：int iMyValue，第一个小写字母表示类型 Cammel命名法：int myAge Pascal命名法：int MyAge 编码Unicode: 表示所有语言 ASCII: 1byte表示一个字符，存储效率高，存储的字符有限 UTF-8：1byte表示一个字符，可以兼容ASCII码，存储效率高，可变长（随机访问效率低），无字节序的问题（可作为外部编码），如网络传输普遍使用 UTF-16：2byte表示一个字符，定长（随机访问效率高），有字节序的问题（不可作为外部编码），但不能表达所有的字符 UTF-32：4byte表示一个字符，定长（随机访问效率高），有字节序的问题（不可作为外部编码），可以表达目前已存在的所有的字符 下一篇主要是面向对象相关的知识点","categories":[{"name":"C++","slug":"C","permalink":"http://zhengbomo.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://zhengbomo.github.io/tags/C/"}]},{"title":"iOS二进制重排对缺页和启动时间的优化实践","slug":"ios-symbol-order-build","date":"2020-03-30T07:45:56.000Z","updated":"2020-03-30T07:45:56.000Z","comments":true,"path":"2020-03-30/ios-symbol-order-build/","link":"","permalink":"http://zhengbomo.github.io/2020-03-30/ios-symbol-order-build/","excerpt":"抖音团队去年针对系统虚拟内存缺页的情况，基于二进制重排的方案，给App启动速度提升了15%，各路大神也随后分享了几篇优质的二进制重排的文章，这里基于自己的项目做一下实践","text":"抖音团队去年针对系统虚拟内存缺页的情况，基于二进制重排的方案，给App启动速度提升了15%，各路大神也随后分享了几篇优质的二进制重排的文章，这里基于自己的项目做一下实践 基本原理 进程运行时使用的内存是操作系统提供的虚拟内存，而不是直接操作物理内存 从虚拟内存到物理内存有一个映射表(页表) 进程的内存会进行分页管理，以页为单位 程序启动的时候，并不会把所有内存都加载到物理内存中，而是用到的时候才加载，没有用到的内存，可能并没有加载到物理内存中 当程序访问到的内存地址（虚拟内存），如果还没有加载到物理内存时，就会触发Page Fault，（对应System Trace的File Backed Page In），然后操作系统把数据加载到物理内存中，如果已经已经加载到物理内存了，则会触发Page Cache Hit，后者是比较快的，这也是热启动比冷启动快的原因之一 基于上面原理. 我们的目标就是在启动的时候增加Page Cache Hit，减少Page Fault，从而达到优化启动时间的目的 我们需要确定，在启动的时候，执行了哪些符号，尽可能让这些符号的内存集中在一起，减少占用的页数，就能减少Page Fault的命中次数 测试Page Fault通过Instrument / System Trace工具，可以查看我们的App，在启动过程中的Page Fault数量(File Breaked Page In) 如果App比较大，Analizing的过程会比较久，需要耐心等待 这里有个注意点，为了确保App是真正的冷启动，需要把内存清干净，不然结果会不太准，下图是我直接杀掉App，重新打开得到的结果 可以看到，和第一次测试差的有点多，我们可以在杀掉App后，重新打开多个其他的App（尽可能多），把原来的内存都覆盖掉，这样在重新打开App的时候，就会重新加载物理内存 确定代码执行顺序接下来需要确定App在启动的时候，调用了哪些函数（使用了哪些符号），这里我们使用杨萧玉写的一个工具AppOrderFiles，使用Clang SanitizerCoverage，通过编译器插装的方式，获取到调用函数的符号顺序 通过pod引入 1pod &#x27;AppOrderFiles&#x27; 并且添加编译宏OTHER_CFLAGS和OTHER_SWIFT_FLAGS（只在Debug生效即可） 1234567891011post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| case config.name when &quot;Debug&quot; config.build_settings[&#x27;OTHER_CFLAGS&#x27;] = &#x27;-fsanitize-coverage=func,trace-pc-guard&#x27; config.build_settings[&#x27;OTHER_SWIFT_FLAGS&#x27;] = &#x27;-sanitize-coverage=func -sanitize=undefined&#x27; end end endend 在App启动后，到第一个页面（HomePage）的viewDidLoad方法 123456789101112131415161718import AppOrderFilesoverride func viewDidLoad() &#123; super.viewDidLoad() ... #if DEBUG // 延迟一下，让运行实践长一点，避免进入后因为PageFault造成卡顿 DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 0.5, execute: &#123; AppOrderFiles &#123; (filePath) in if let p = filePath &#123; print(&quot;output order file \\(p)&quot;) &#125; &#125; &#125;) #endif&#125; 输出的文件在App沙盒，用模拟器运行更方便，得到文件app.order，这里面就是排好序的符号列表，根据App的执行顺序，如果项目比较大的话，会比较久 1234567891011121314151617___swift_instantiateConcreteTypeFromMangledName_main_$s3jcm11AppDelegateCMa_$s3jcm11AppDelegateCACycfcTo_$s3jcm11AppDelegateCACycfc_$s3jcm11AppDelegateC11application_29didFinishLaunchingWithOptionsSbSo13UIApplicationC_SDySo0j6LaunchI3KeyaypGSgtFTo_$s3jcm11AppDelegateC11application_29didFinishLaunchingWithOptionsSbSo13UIApplicationC_SDySo0j6LaunchI3KeyaypGSgtF_$s3jcm11AppDelegateC5setup13launchOptionsySDySo019UIApplicationLaunchF3KeyaypGSg_tF_$s3jcm5ConstV11wechatAppIdSSvau_globalinit_33_27D199AC10BAAE2783814C508183B809_func13_$s3jcm5ConstV19wechatUniversalLinkSSvau_globalinit_33_27D199AC10BAAE2783814C508183B809_func15_$sSo12BaiduMobStatCMa_$sSo12BaiduMobStatCs5Error_pIggzo_ABsAC_pIegnzo_TRTA_$sSo12BaiduMobStatCs5Error_pIggzo_ABsAC_pIegnzo_TR... 把app.order放到工程目录，配置到Xcode里面Build Setting -&gt; Order File -&gt; $(PROJECT_DIR)/app.order 验证是否生效Xcode里面Build Setting有个Write Link Map File，可以生成Link Map文件的选项，路径如下 12345# Link Map文件Intermediates.noindex/xxxx.build/Debug-iphoneos/xxx.build/xxx-LinkMap-normal-arm64.txt# 生成app文件路径Products/Debug-iphoneos/xxx.app 文件内容其实是描述链接器连接的详情，对应的是MachO文件的内存分布，文件如下 12345678910111213141516171819202122232425262728293031323334353637# Path: /Users/bomo/Library/Developer/Xcode/DerivedData/SwiftScaffold-fdswirgebkkdidcxcpxdffxxvxye/Build/Products/Debug-iphoneos/jcm.app/jcm# Arch: arm64# Object files:[ 0] linker synthesized[ 1] /Users/bomo/Library/Developer/Xcode/DerivedData/SwiftScaffold-fdswirgebkkdidcxcpxdffxxvxye/Build/Intermediates.noindex/SwiftScaffold.build/Debug-iphoneos/jcm.build/Objects-normal/arm64/JHCollectionViewFlowLayout.o[ 2] /Users/bomo/Library/Developer/Xcode/DerivedData/SwiftScaffold-fdswirgebkkdidcxcpxdffxxvxye/Build/Intermediates.noindex/SwiftScaffold.build/Debug-iphoneos/jcm.build/Objects-normal/arm64/JHCollectionReusableView.o...# Sections:# Address Size Segment Section0x100004928 0x00ED5B08 __TEXT __text0x100EDA430 0x00005550 __TEXT __stubs0x100EDF980 0x00005190 __TEXT __stub_helper0x100EE4B10 0x000684D9 __TEXT __cstring...# Symbols:# Address Size File Name0x100004928 0x00000094 [ 6] ___swift_instantiateConcreteTypeFromMangledName0x1000049BC 0x00000088 [ 78] _main0x100004A44 0x00000070 [ 78] _$s3jcm11AppDelegateCMa0x100004AB4 0x00000044 [ 78] _$s3jcm11AppDelegateCACycfcTo0x100004AF8 0x00000108 [ 78] _$s3jcm11AppDelegateCACycfc0x100004C00 0x00000144 [ 78] _$s3jcm11AppDelegateC11application_29didFinishLaunchingWithOptionsSbSo13UIApplicationC_SDySo0j6LaunchI3KeyaypGSgtFTo0x100004D44 0x00000430 [ 78] _$s3jcm11AppDelegateC11application_29didFinishLaunchingWithOptionsSbSo13UIApplicationC_SDySo0j6LaunchI3KeyaypGSgtF...# Dead Stripped Symbols:# Size File Name&lt;&lt;dead&gt;&gt; 0x00000006 [ 2] literal string: class&lt;&lt;dead&gt;&gt; 0x00000014 [ 2] literal string: setBackgroundColor:&lt;&lt;dead&gt;&gt; 0x0000000B [ 2] literal string: v24@0:8@16&lt;&lt;dead&gt;&gt; 0x00000010 [ 3] literal string: backgroundColor&lt;&lt;dead&gt;&gt; 0x00000014 [ 3] literal string: setBackgroundColor:&lt;&lt;dead&gt;&gt; 0x0000000E [ 3] literal string: .cxx_destruct&lt;&lt;dead&gt;&gt; 0x00000008 [ 3] literal string: @16@0:8... 这里我们只关注符号表Symbols，这里的顺序就是MachO文件对应的顺序，如果与app.order的顺序一致，就表明改成功了 对比通过System Trace工具测试修改前后对比\b page fault减少了900，速度提升225ms，这里的时间与具体的运行环境有关系，建议多次测试 引用 抖音研发实践：基于二进制文件重排的解决方案 APP启动速度提升超15% App 二进制文件重排已经被玩坏了","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"}]},{"title":"Xcode动态调试第三方App","slug":"xcode-dynamic-debug","date":"2020-03-15T12:22:10.000Z","updated":"2020-03-15T12:22:10.000Z","comments":true,"path":"2020-03-15/xcode-dynamic-debug/","link":"","permalink":"http://zhengbomo.github.io/2020-03-15/xcode-dynamic-debug/","excerpt":"之前我们知道，我们可以使用lldb调试手机上的App，而Xcode就是用的lldb进行调试的，而且功能非常强大，例如查看UI层级结构，查看调用栈，打断点，lldb只能提示等等，使用起来比直接用lldb调试会方便很多，这里记录一下如何在XCode调试第三方App","text":"之前我们知道，我们可以使用lldb调试手机上的App，而Xcode就是用的lldb进行调试的，而且功能非常强大，例如查看UI层级结构，查看调用栈，打断点，lldb只能提示等等，使用起来比直接用lldb调试会方便很多，这里记录一下如何在XCode调试第三方App 直接启动调试 我们先拿到脱壳的第三方App（WeChat），进行重签名，得到WeChat.app 有很多种脱壳的方式，笔者用的是iOS13，用的是CrackerXI+工具 新建一个新的工程，证书与重签名的一致，修改bundleId为com.tencent.xin，运行到手机上 把WeChat.app放到工程根目录，在工程添加Run Script 12# 运行之前换成第三方app，达到偷梁换柱的目的cp -rf &quot;$&#123;SRCROOT&#125;/WeChat.app&quot; &quot;$&#123;BUILT_PRODUCTS_DIR&#125;/&quot; 接下来就跟我们平常调试应用一样，只是没有源码可以看 添加断点通过Hopper查看方法的地址为: 0x0000000102a9602c 1234-[WCAccountLoginControlLogic onFirstViewLogin]:0000000102a9602c stp x22, x21, [sp, #-0x30]!0000000102a96030 stp x20, x19, [sp, #0x10]0000000102a96034 stp x29, x30, [sp, #0x20] 打断点 12345678910111213141516# 1. 查看ASLR为：0x0000000000558000 = 0x0000000100558000 - 0x0000000100000000(lldb) image list | grep WeChat[ 0] 7195B97E-9078-3119-9110-8BDA959283F0 0x0000000100558000 /Users/wendy/Library/Developer/Xcode/DerivedData/Test-haevfjompsameldsewkriqunrgfe/Build/Products/Debug-iphoneos/WeChat.app/WeChat# 2. 所以方法的内存地址为: 0x0000000102fee02c = 0x0000000000558000 + 0x0000000102a9602c(lldb) p/x 0x0000000000558000 + 0x0000000102a9602c(long) $27 = 0x0000000102fee02c# 3. 添加地址断点(lldb) breakpoint set -a 0x0000000102fee02cBreakpoint 5: where = WeChat`___lldb_unnamed_symbol137105$$WeChat, address = 0x0000000102fee02c# 4. 添加符号断点（失败）(lldb) breakpoint set -n &quot;-[WCAccountLoginControlLogic onFirstViewLogin]&quot;Breakpoint 8: no locations (pending).WARNING: Unable to resolve breakpoint to any actual locations. 断点只能通过地址添加，并不能解析符号，另外Xcode也不能解析堆栈信息，我们可以用restore-symbol恢复符号表 恢复符号表为了方便调试，打断点，查看堆栈调用信息，我们可以使用restore-symbol恢复符号表 使用方法，网站上很详细了 1234567# 下载git clone --recursive https://github.com/tobefuturer/restore-symbol.git# 编译cd restore-symbol &amp;&amp; make# 运行（恢复OC符号表）./restore-symbol /pathto/origin_mach_o_file -o /pathto/mach_o_with_symbol 恢复block的符号表需要借助IDA导出映射关系，具体见网站说明，恢复符号表后需要重签名 打符号断点 UI 层级 远程附加调试先安装第三方App(脱壳)，然后新建一个新工程，运行 在XCode -&gt; DEBGU -&gt; Attach to Process，然后选择对应的进程附加 用起来和直接调试是一样 附加调试有时候会很慢","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"}]},{"title":"MacOS 10.15安装IDA7","slug":"ida7-catalina","date":"2020-03-13T14:01:20.000Z","updated":"2020-03-13T14:01:20.000Z","comments":true,"path":"2020-03-13/ida7-catalina/","link":"","permalink":"http://zhengbomo.github.io/2020-03-13/ida7-catalina/","excerpt":"MacOS 10.15对系统做了比较大的改动，之前的IDA7.0无法在10.15上安装，而在10.14安装是正常的，解决方案是通过MacOS 10.14安装，然后把安装好的文件放到10.15系统运行","text":"MacOS 10.15对系统做了比较大的改动，之前的IDA7.0无法在10.15上安装，而在10.14安装是正常的，解决方案是通过MacOS 10.14安装，然后把安装好的文件放到10.15系统运行 Mac 10.14安装IDA 下载并安装虚拟机VMware Fusion 下载并安装MacOS 10.14镜像 链接: https://pan.baidu.com/s/1XVPCyecg4xIbxnvR6_ukDA 提取码: y8xn 下载IDA7.0，安装到MacOS10.14上 安装完得到 复制到Mac 10.15拷贝10.14系统下的到/Applications/IDA Pro 7.0目录到10.15系统的/Applications/下 直接打开会直接崩溃 需要替换一下libqcocoa.dylib文件，在这里可以找到 1/Applications/IDA Pro 7.0/ida.app/Contents/PlugIns/platforms/libqcocoa.dylib 每次打开会报授权过期 解压Fixes/IDA Mac 7 pacth.7z并替换下面文件 1234/Applications/IDA Pro 7.0/ida.app/Contents/MacOS/ida/Applications/IDA Pro 7.0/ida.app/Contents/MacOS/ida64/Applications/IDA Pro 7.0/ida.app/Contents/MacOS/libida.dylib/Applications/IDA Pro 7.0/ida.app/Contents/MacOS/libida64.dylib 打开ida64如果出现无法打开的情况 可能是权限问题 1234# 如果没有执行权限，需要先添加，之后就能直接启动了cd /Applications/IDA Pro 7.0/ida.app/Contents/MacOSchmod +x idachmod +x ida64 下面是我处理后的文件，可以直接拿到Mac10.15使用 链接:https://pan.baidu.com/s/1DwkW2ICWev5FhIqOHuq6BA 密码:kzxx","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"},{"name":"逆向","slug":"逆向","permalink":"http://zhengbomo.github.io/tags/%E9%80%86%E5%90%91/"}]},{"title":"iOS安全防护","slug":"ios-security-protection","date":"2020-01-14T14:35:28.000Z","updated":"2020-04-30T14:35:28.000Z","comments":true,"path":"2020-01-14/ios-security-protection/","link":"","permalink":"http://zhengbomo.github.io/2020-01-14/ios-security-protection/","excerpt":"对于安全性要求高的App，需要添加逆向成本，较少被破解和攻击的风险，防护的方式主要有越狱检测, 抓包检测, 防反编译, 防重签名, 防hook, 防动态调试","text":"对于安全性要求高的App，需要添加逆向成本，较少被破解和攻击的风险，防护的方式主要有越狱检测, 抓包检测, 防反编译, 防重签名, 防hook, 防动态调试 越狱检测12345678910111213141516171819202122232425262728293031323334+ (BOOL)isJailbroken &#123; // 检查是否存在越狱常用文件 NSArray *jailFilePaths = @[@&quot;/Applications/Cydia.app&quot;, @&quot;/Library/MobileSubstrate/MobileSubstrate.dylib&quot;, @&quot;/bin/bash&quot;, @&quot;/usr/sbin/sshd&quot;, @&quot;/etc/apt&quot;]; for (NSString *filePath in jailFilePaths) &#123; if ([[NSFileManager defaultManager] fileExistsAtPath:filePath]) &#123; return YES; &#125; &#125; // 检查是否安装了越狱工具Cydia if([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@&quot;cydia://package/com.example.package&quot;]])&#123; return YES; &#125; // 检查是否有权限读取系统应用列表 if ([[NSFileManager defaultManager] fileExistsAtPath:@&quot;/User/Applications/&quot;])&#123; NSArray *applist = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:@&quot;/User/Applications/&quot; error:nil]; NSLog(@&quot;applist = %@&quot;,applist); return YES; &#125; // 检测当前程序运行的环境变量 char *env = getenv(&quot;DYLD_INSERT_LIBRARIES&quot;); if (env != NULL) &#123; return YES; &#125; return NO;&#125; 当然，上面方法很容易被hook，我们可以把它拆成多个方法，并且字符串加密处理，放到C方法中，增加hook的成本 防抓包 代理检测 SSLPinning：校验 防反编译这里主要是代码混淆，不做展开 类名方法名混淆，OC的话可以用宏占位和宏替换来做 llvm编译器混淆 反注入（已失效）dyld在加载MachO的时候，会判断segments中判断是否有restrict这个段，如果有的话,那么就不会加载DYLD_INSERT_LIBRARIES环境变量的动态库，所以可以在程序中加入restrict这个字段 在Xcode -&gt; Build Settings -&gt; Other Link Flags添加-Wl,-sectcreate,__RESTRICT,__restrict,/dev/null标记即可，使用MachOView即可看到load commands中多了__RESTRICT段 iOS10以后,苹果在dyld中就不在检测__restrict字段，已经失效了 防重签名我们都知道，App在打包签名后在app里面会带上embedded.mobileprovision，系统会通过该文件校验应用是否合法，这个文件就是我们打包用的文件，我们我们可以在代码中校验该文件是不是我们自己的，如果不是，则退出程序（AppStore下载的包没有embedded.mobileprovision） 12345678910111213141516171819202122232425262728293031323334353637/// 判断签名/// &lt;string&gt;9PCXXXXK5A.*&lt;/string&gt;/// &lt;string&gt;9PCXXXXK5A.com.bomo.demo&lt;/string&gt;void checkCodesign(NSString *identifier)&#123; // 描述文件路径 NSString *embeddedPath = [[NSBundle mainBundle] pathForResource:@&quot;embedded&quot; ofType:@&quot;mobileprovision&quot;]; if ([NSFileManager.defaultManager fileExistsAtPath:embeddedPath]) &#123; NSString *embeddedProvisioning = [NSString stringWithContentsOfFile:embeddedPath encoding:NSASCIIStringEncoding error:nil]; NSArray *embeddedProvisioningLines = [embeddedProvisioning componentsSeparatedByCharactersInSet:[NSCharacterSet newlineCharacterSet]]; for (int i = 0; i &lt; embeddedProvisioningLines.count; i++) &#123; if ([embeddedProvisioningLines[i] rangeOfString:@&quot;application-identifier&quot;].location != NSNotFound) &#123; NSString *value = embeddedProvisioningLines[i + 1]; NSInteger start = [value rangeOfString:@&quot;&lt;string&gt;&quot;].location; NSInteger end = [value rangeOfString:@&quot;&lt;/string&gt;&quot;].location; if (start != NSNotFound &amp;&amp; end != NSNotFound) &#123; NSString *applicationIdentifier = [value substringWithRange:NSMakeRange(start + 8, end - start - 8)]; // &lt;string&gt;9PCXXXXK5A.*&lt;/string&gt; // &lt;string&gt;9PCXXXXK5A.com.bomo.demo&lt;/string&gt; // 对比签名ID if (![applicationIdentifier isEqual:identifier]) &#123; // exit asm( &quot;mov X0,#0\\n&quot; &quot;mov w16,#1\\n&quot; &quot;svc #0x80&quot; ); &#125; &#125; &#125; &#125; &#125; else &#123; // AppStore的包没有mobileprovision文件 &#125;&#125; 防动态调试使用ptrace函数反调试debugserver之所以可以调试APP, 是依赖一个系统函数ptrace(process trace 进程跟踪). 此函数提供了一个进程监听控制另外一个进程, 并且可以检查被控制进程的内容和寄存器里面的数据. 可以用来实现断电调试和系统调用跟踪. iOS中没有提供此函数的头文件, 但不是私有API. ptrace函数在iOS项目中不能找到，在MacOS工程可以引用到，我们把需要用到的函数声明搬过来 12345678910111213141516171819202122232425/** * request: 要做的事情 * pid: 要监听/操作的id * addr: 为request代表的操作提供的地址 */int ptrace(int _request, pid_t _pid, caddr_t _addr, int _data);#define PT_TRACE_ME 0 /* child declares it&#x27;s being traced */#define PT_READ_I 1 /* read word in child&#x27;s I space */#define PT_READ_D 2 /* read word in child&#x27;s D space */#define PT_READ_U 3 /* read word in child&#x27;s user structure */#define PT_WRITE_I 4 /* write word in child&#x27;s I space */#define PT_WRITE_D 5 /* write word in child&#x27;s D space */#define PT_WRITE_U 6 /* write word in child&#x27;s user structure */#define PT_CONTINUE 7 /* continue the child */#define PT_KILL 8 /* kill the child process */#define PT_STEP 9 /* single step the child */#define PT_ATTACH ePtAttachDeprecated /* trace some running process */#define PT_DETACH 11 /* stop tracing a process */#define PT_SIGEXC 12 /* signals as exceptions for current_proc */#define PT_THUPDATE 13 /* signal for thread# */#define PT_ATTACHEXC 14 /* attach to running process with signal exception */#define PT_FORCEQUOTA 30 /* Enforce quota for root */#define PT_DENY_ATTACH 31#define PT_FIRSTMACH 32 /* for machine-specific requests */ 找地方执行，可以在load方法 12345+ (void)load &#123; // PT_DENY_ATTACH 表示拒绝调试 // 第二个参数也可以设置为0，表示当前进程 ptrace(PT_DENY_ATTACH, getpid(), 0, 0);&#125; 当打开debugserver的时候会失败(Segmentation fault: 11) 123456root# debugserver 127.0.0.1:3333 -a Testdebugserver-@(#)PROGRAM:LLDB PROJECT:lldb-900.3.98 for arm64.Attaching to process Test...Segmentation fault: 11laboshi:~ root# 直接使用ptrace方法的时候，编译完成后符号表会出现ptrace符号，提审可能会被拒，这个就看审核员的心情了，我们可以通过dlopen动态加载系统的动态库和方法 1234567891011121314151617// 引用头文件#include &lt;dlfcn.h&gt;// 定义函数指针int (*ptrace_p)(int _request, pid_t _pid, caddr_t _addr, int _data);// 加载系统动态库void *handler = dlopen(&quot;/usr/lib/system/libsystem_kernel.dylib&quot;, RTLD_LAZY);if (handler) &#123; // 读取符号地址 ptrace_p = dlsym(handler, &quot;ptrace&quot;); if (ptrace_p) &#123; // 调用 ptrace_p(PT_DENY_ATTACH, 0, 0, 0); &#125;&#125; 上面的字符串可以做一定的加密处理，减少特征 使用sysctl函数反调试使用sysctl函数可以判断当前程序是否正在被调试，可以隔一段时间检测一下 12345678910111213141516171819202122232425#import &lt;sys/sysctl.h&gt;bool isDebuging() &#123; // 控制码 int name[4]; // 里面放字节码, 查询信息 name[0] = CTL_KERN; // 内核 name[1] = KERN_PROC; // 查询进程 name[2] = KERN_PROC_PID; // 通过id查询, 传递的参数是进程id name[3] = getpid(); // 拿到当前进程id struct kinfo_proc info; // 结束进程查询结果的结构体 size_t info_size = sizeof(info); // 结构体的大小 int error = sysctl(name, sizeof(name)/sizeof(*name), &amp;info, &amp;info_size, 0, 0); if (!error) &#123; // p_flag 的值转换为二进制, 假如从低位到高位第12位的值为1(0x800), 则正在被调试 if (info.kp_proc.p_flag &amp; P_TRACED) &#123; return true; &#125; else &#123; return false; &#125; &#125; return false;&#125; 反反调试上面反调试方法都是C语言的方法，而我们知道fishhook可以 hook (系统的)C方法，所以上面两个方法可以被fishhook替换掉 这时候我们就需要保护系统的C方法不被hook，我们可以在别人hook之前换成我们自己的实现，然后别人再hook的时候就只是hook我们替换过的实现了 如何确保我们的hook在别人之前调用呢？ 我们知道，dyld加载App的时候，动态库是先加载的，而动态库的加载顺序是根据MachO文件描述的顺序（也就是Xcode -&gt; Frameworks,Libraries,and Embedded Content配置的顺序），我们可以用一个防护的动态库让我们的动态库先执行 当然如果MachO文件的动态链接库的顺序被改变了，还是会被别人先hook，这个成本就比较高了 123456789101112131415161718192021222324252627282930#import &quot;fishhook.h&quot;#define PT_DENY_ATTACH 31// 原方法static int (*ptrace_p)(int _request, pid_t _pid, caddr_t _addr, int _data);// 新方法int my_ptrace(int _request, pid_t _pid, caddr_t _addr, int _data) &#123; if (_request != PT_DENY_ATTACH) &#123; return ptrace_p(_request, _pid, _addr, _data); &#125; else &#123; return 0; &#125;&#125;// 在动态库的方法里面添加重绑+ (void)load &#123; struct rebinding ptraceBd; // 符号 ptraceBd.name = &quot;ptrace&quot;; // 新方法 ptraceBd.replaced = (void *)&amp;ptrace_p; // 原方法 ptraceBd.replacement = my_ptrace; struct rebinding bds[] = &#123;ptraceBd&#125;; // 绑定符号 rebind_symbols(bds, 1);&#125; 防hook对于OC的方法的hook通常是使用runtime的方法交换来实现method_exchangeImplementations，所以我们确保这个方法是安全的，就能很大程度上降低OC方法被hook 由于dyld加载程序时候，对于外部符号（例如系统函数）是lazybind加载的，编译的时候并不是绑定真实的地址，而是在运行时动态绑定的，所以fishhook可以hook系统方法 我们可以先把method_exchangeImplementations先换成我们的函数，然后别人在交换该方法的时候，就无法拿到原本的实现了 如何让我们的hook先调用呢 dyld在加载程序的时候，会先加载动态库，并且是按照MachO文件存储的顺序加载（也就是Xcode链接库的顺序），所以我们可以把我们的hook代码放到动态库放到最前面，就可以然后在load方法交换方法 当然，如果MachO文件的动态库链接顺序也被修改了，那么就没办法了，这时候可以通过一些逻辑判断来增加hook难度，例如如果调用次数多了，就退出程序exit(0) 上面只做了method_exchangeImplementations方法的防护，还有其他一些潜在的危险方法也需要做防护，\b例如：method_setImplementation和method_getImplementation，通常我们没有用到这两个方法，如果没有用到，就直接替换掉 另外由于程序库内部的C方法比较难被hook，对于一些敏感的方法可以放到C方法中（在命名也做一些混淆处理） 防fishhook我们知道系统库的方法可以被fishhook替换掉，如何防fishhook呢 dlopen+dlsym采用dlopen+dlsym调用系统方法可以防fishhook，如上面调用ptrace的第二种方式 syscall使用系统函数syscall调用ptrace 12// 第一个参数为函数的编号，后面的参数为对应函数的参数int syscall(int, ...); 通过&lt;sys/syscall.h&gt;头文件找到对应的ptrace函数编号为26 12345678...#define SYS_setuid 23#define SYS_getuid 24#define SYS_geteuid 25#define SYS_ptrace 26#define SYS_recvmsg 27#define SYS_sendmsg 28... 调用 1syscall(26, PT_DENY_ATTACH, 0, 0); 汇编调用双面两种方式都是基于符号调用函数，这里有个缺点是可以被符号断点短住，这样攻击者，可以先断住符号断点，然后跳过该符号函数从而让我们的代码失效，如果我们写的是汇编代码，则不会被符号断点跟踪到，下面用汇编执行ptrace 1234567891011121314151617181920212223asm volatile( &quot;mov x0,#31\\n&quot; &quot;mov x1,#0\\n&quot; &quot;mov x2,#0\\n&quot; &quot;mov x3,#0\\n&quot; &quot;mov x16,#26\\n&quot;//中断根据x16 里面的值，跳转ptrace &quot;svc #0x80\\n&quot;//这条指令就是触发中断（系统级别的跳转！）);#ifdef __arm64__ asm( &quot;mov x0,#0\\n&quot; &quot;mov w16,#1\\n&quot; &quot;svc #0x80\\n&quot; );#endif#ifdef __arm__ //32位下 asm( &quot;mov r0,#0\\n&quot; &quot;mov r12,#1\\n&quot; &quot;svc #80\\n&quot; );#endif 小结安全防护之后更好，没有最好，我们只能增加攻击者的成本，增加逆向难度","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"},{"name":"逆向","slug":"逆向","permalink":"http://zhengbomo.github.io/tags/%E9%80%86%E5%90%91/"}]},{"title":"Docker 学习笔记","slug":"docker-learn","date":"2020-01-10T07:11:02.000Z","updated":"2020-01-10T07:11:02.000Z","comments":true,"path":"2020-01-10/docker-learn/","link":"","permalink":"http://zhengbomo.github.io/2020-01-10/docker-learn/","excerpt":"初体验","text":"初体验 安装一个 nginx 并运行执行命令 1docker run -d -p 8080:80 nginx 查看当前运行的进程 1docker ps 访问http://localhost:8080 执行原理 检测本地是否有 nginx 镜像 如果没有，则去仓库下载最新的镜像 下载成功后，运行镜像 把本地的8080端口映射到容器的80端口 运行ubuntu容器，并进入bash控制台 1docker run -it ubuntu /bin/bash -t：分配一个伪终端并绑定到容器标准输入输出上 -i：让容器的标准输入保持打开，可以一直监听输入 基本概念镜像相当于操作系统安装文件，提供容器所需要的程序，依赖库，资源，配置等信息 镜像可以嵌套镜像，一个镜像可以由多个镜像组成 容器相当于一个独立的操作系统，拥有特定的运行环境，镜像与容器类似于类和实例的关系，容器的本质是进程 仓库集中管理和分发给用户下载的镜像的服务 基础实战镜像 搜索镜像 1docker search nginx 下载镜像，(如果本地不存在) 1docker pull fuhai/jpress:v2.0.7 查看镜像 1docker images 删除镜像 1docker rmi fuhai/jpress:v2.0.7 运行镜像 1docker run 查看命令 1docker run --help 实例 1docker run -d -p 8080:80 nginx -p：端口映射 -d：后台运行，并返回ContainerId，不加的话是直接运行 停止容器 1234567891011121314# 停止容器docker stop &lt;container_id&gt;# 启动容器docker start &lt;container_id&gt;# 暂停容器docker pause &lt;container_id&gt;# 继续已经暂停的容器docker unpause &lt;container_id&gt;# 重启容器docker restart &lt;container_id&gt; 容器操作 12345678# 列出容器docker ps# 查看容器详细信息docker inspect &lt;container_id&gt;# 删除容器docker rm &lt;container_id&gt; 进入容器 1docker exec -it &lt;container_id&gt; bash 拷贝文件 12345# 从本地拷贝到容器docker cp /srcdir/srcfile &lt;container_id&gt;:/usr/local/webapp/...# 从容器拷贝到本地docker cp &lt;container_id&gt;:/usr/local/webapp/... /local/testdir/... 把容器做成镜像 1docker commit &lt;conainer_id&gt; mynginx:v1.0","categories":[{"name":"docker","slug":"docker","permalink":"http://zhengbomo.github.io/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://zhengbomo.github.io/tags/docker/"}]},{"title":"load和initialize方法","slug":"ios-load-initialize","date":"2019-10-20T14:38:09.000Z","updated":"2019-10-20T14:38:09.000Z","comments":true,"path":"2019-10-20/ios-load-initialize/","link":"","permalink":"http://zhengbomo.github.io/2019-10-20/ios-load-initialize/","excerpt":"我们都知道，iOS的类中，有两个方法load和initialize，load方法在程序启动的时候就会执行，而initialize方法在类第一次调用的时候执行，这里我们从源码的角度探究一下这两个方法的原理和实现","text":"我们都知道，iOS的类中，有两个方法load和initialize，load方法在程序启动的时候就会执行，而initialize方法在类第一次调用的时候执行，这里我们从源码的角度探究一下这两个方法的原理和实现 我们下载objc4运行时源码，下载最新的版本objc4-779.1.tar.gz，在objc-os.mm找到_objc_init方法，这个函数是OC运行时的入口函数，整个OC运行时从这里开始加载 123456789101112131415161718192021222324/************************************************************************ _objc_init* Bootstrap initialization. Registers our image notifier with dyld.* Called by libSystem BEFORE library initialization time**********************************************************************/void _objc_init(void)&#123; static bool initialized = false; if (initialized) return; initialized = true; // fixme defer initialization until an objc-using image is found? environ_init(); tls_init(); static_init(); runtime_init(); exception_init(); cache_init(); _imp_implementationWithBlock_init(); _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);&#125; load前面是一些初始化方法，最后一个_dyld_objc_notify_register是向dyld注册三个事件，我们这里关注load_images事件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647voidload_images(const char *path __unused, const struct mach_header *mh)&#123; // Return without taking locks if there are no +load methods here. if (!hasLoadMethods((const headerType *)mh)) return; recursive_mutex_locker_t lock(loadMethodLock); // Discover load methods &#123; mutex_locker_t lock2(runtimeLock); prepare_load_methods((const headerType *)mh); &#125; // Call +load methods (without runtimeLock - re-entrant) call_load_methods();&#125;void call_load_methods(void)&#123; static bool loading = NO; bool more_categories; loadMethodLock.assertLocked(); // Re-entrant calls do nothing; the outermost call will finish the job. if (loading) return; loading = YES; void *pool = objc_autoreleasePoolPush(); do &#123; // 1. Repeatedly call class +loads until there aren&#x27;t any more while (loadable_classes_used &gt; 0) &#123; call_class_loads(); &#125; // 2. Call category +loads ONCE more_categories = call_category_loads(); // 3. Run more +loads if there are classes OR more untried categories &#125; while (loadable_classes_used &gt; 0 || more_categories); objc_autoreleasePoolPop(pool); loading = NO;&#125; 可以看出，load方法的加载顺序，先加载类的load方法，再加载Category里面的load方法 进入call_class_loads方法 1234567891011121314151617181920212223242526static void call_class_loads(void)&#123; int i; // Detach current loadable list. struct loadable_class *classes = loadable_classes; int used = loadable_classes_used; loadable_classes = nil; loadable_classes_allocated = 0; loadable_classes_used = 0; // Call all +loads for the detached list. for (i = 0; i &lt; used; i++) &#123; Class cls = classes[i].cls; load_method_t load_method = (load_method_t)classes[i].method; if (!cls) continue; if (PrintLoading) &#123; _objc_inform(&quot;LOAD: +[%s load]\\n&quot;, cls-&gt;nameForLogging()); &#125; (*load_method)(cls, @selector(load)); &#125; // Destroy the detached list. if (classes) free(classes);&#125; 这里拿到了loadable_classes这个是带有load方法的类列表，并且可以直接拿到load方法的imp直接调用，这里没有使用objc_msgSend机制调用方法，而是直接拿到IMP直接调用，签名如下 1typedef void(*load_method_t)(id, SEL); 在prepare_load_methods方法会初始化所有的类的加载方法，遍历所有的类，如果类实现了load方法，就会构造loadable_class添加到loadable_classes中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107void prepare_load_methods(const headerType *mhdr)&#123; Module mods; unsigned int midx; header_info *hi; for (hi = FirstHeader; hi; hi = hi-&gt;getNext()) &#123; if (mhdr == hi-&gt;mhdr()) break; &#125; if (!hi) return; if (hi-&gt;info()-&gt;isReplacement()) &#123; // Ignore any classes in this image return; &#125; // Major loop - process all modules in the image mods = hi-&gt;mod_ptr; for (midx = 0; midx &lt; hi-&gt;mod_count; midx += 1) &#123; unsigned int index; // Skip module containing no classes if (mods[midx].symtab == nil) continue; // Minor loop - process all the classes in given module for (index = 0; index &lt; mods[midx].symtab-&gt;cls_def_cnt; index += 1) &#123; // Locate the class description pointer Class cls = (Class)mods[midx].symtab-&gt;defs[index]; if (cls-&gt;info &amp; CLS_CONNECTED) &#123; schedule_class_load(cls); &#125; &#125; &#125; // Major loop - process all modules in the header mods = hi-&gt;mod_ptr; // NOTE: The module and category lists are traversed backwards // to preserve the pre-10.4 processing order. Changing the order // would have a small chance of introducing binary compatibility bugs. midx = (unsigned int)hi-&gt;mod_count; while (midx-- &gt; 0) &#123; unsigned int index; unsigned int total; Symtab symtab = mods[midx].symtab; // Nothing to do for a module without a symbol table if (mods[midx].symtab == nil) continue; // Total entries in symbol table (class entries followed // by category entries) total = mods[midx].symtab-&gt;cls_def_cnt + mods[midx].symtab-&gt;cat_def_cnt; // Minor loop - register all categories from given module index = total; while (index-- &gt; mods[midx].symtab-&gt;cls_def_cnt) &#123; old_category *cat = (old_category *)symtab-&gt;defs[index]; add_category_to_loadable_list((Category)cat); &#125; &#125;&#125;static void schedule_class_load(Class cls)&#123; if (!cls) return; ASSERT(cls-&gt;isRealized()); // _read_images should realize if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return; // Ensure superclass-first ordering schedule_class_load(cls-&gt;superclass); add_class_to_loadable_list(cls); cls-&gt;setInfo(RW_LOADED);&#125;void add_class_to_loadable_list(Class cls)&#123; IMP method; loadMethodLock.assertLocked(); method = cls-&gt;getLoadMethod(); if (!method) return; // Don&#x27;t bother if cls has no +load method if (PrintLoading) &#123; _objc_inform(&quot;LOAD: class &#x27;%s&#x27; scheduled for +load&quot;, cls-&gt;nameForLogging()); &#125; if (loadable_classes_used == loadable_classes_allocated) &#123; loadable_classes_allocated = loadable_classes_allocated*2 + 16; loadable_classes = (struct loadable_class *) realloc(loadable_classes, loadable_classes_allocated * sizeof(struct loadable_class)); &#125; loadable_classes[loadable_classes_used].cls = cls; loadable_classes[loadable_classes_used].method = method; loadable_classes_used++;&#125; 我们在schedule_class_load方法看到，这里面做了一次递归，也就是如果存在父类，会先添加父类，所以父类的load方法会比子类先执行 可以看出，load方法的加载顺序 父类的load方法 再加载子类的load方法（加载顺序为编译顺序） 再加载category里面的load方法（加载顺序为编译顺序） initialize由于initialize是在调用的时候才执行的，我们调试一下看看 1234567891011121314151617181920212223@interface ABC : NSObject@end@implementation ABC+ (void)initialize &#123; // 添加断点 NSLog(@&quot;%@&quot;, @&quot;ass&quot;);&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [ABC alloc];&#125;@end 在initialize添加断点，查看调用栈 12345678910(lldb) bt* thread #1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = breakpoint 1.1 * frame #0: 0x0000000104911f20 Test`+[ABC initialize](self=ABC, _cmd=&quot;initialize&quot;) at ViewController.m:19:5 frame #1: 0x00000001818bb6f0 libobjc.A.dylib`CALLING_SOME_+initialize_METHOD + 20 frame #2: 0x00000001818c1074 libobjc.A.dylib`initializeNonMetaClass + 640 frame #3: 0x00000001818c2318 libobjc.A.dylib`initializeAndMaybeRelock(objc_class*, objc_object*, mutex_tt&lt;false&gt;&amp;, bool) + 284 frame #4: 0x00000001818cf074 libobjc.A.dylib`lookUpImpOrForward + 732 frame #5: 0x00000001818bbe9c libobjc.A.dylib`_objc_msgSend_uncached + 60 frame #6: 0x0000000104911f9c Test`-[ViewController viewDidLoad](self=0x0000000104e0cf90, _cmd=&quot;viewDidLoad&quot;) at ViewController.m:33:5 ... 可以看到，在调用init方法的时候，调用了objc_msgSend_uncached，然后，走到了lookUpImpOrForward方法，我们在objc4源码中查看该方法 在_objc_msgSend_uncached方法调用了MethodTableLookup 在MethodTableLookup方法调用了lookUpImpOrForward，并且behavior传了LOOKUP_INITIALIZE | LOOKUP_RESOLVER 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110IMP lookUpImpOrForward(id inst, SEL sel, Class cls, int behavior)&#123; const IMP forward_imp = (IMP)_objc_msgForward_impcache; IMP imp = nil; Class curClass; runtimeLock.assertUnlocked(); // Optimistic cache lookup if (fastpath(behavior &amp; LOOKUP_CACHE)) &#123; imp = cache_getImp(cls, sel); if (imp) goto done_nolock; &#125; // runtimeLock is held during isRealized and isInitialized checking // to prevent races against concurrent realization. // runtimeLock is held during method search to make // method-lookup + cache-fill atomic with respect to method addition. // Otherwise, a category could be added but ignored indefinitely because // the cache was re-filled with the old value after the cache flush on // behalf of the category. runtimeLock.lock(); // We don&#x27;t want people to be able to craft a binary blob that looks like // a class but really isn&#x27;t one and do a CFI attack. // // To make these harder we want to make sure this is a class that was // either built into the binary or legitimately registered through // objc_duplicateClass, objc_initializeClassPair or objc_allocateClassPair. // // TODO: this check is quite costly during process startup. checkIsKnownClass(cls); if (slowpath(!cls-&gt;isRealized())) &#123; cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock); // runtimeLock may have been dropped but is now locked again &#125; if (slowpath((behavior &amp; LOOKUP_INITIALIZE) &amp;&amp; !cls-&gt;isInitialized())) &#123; cls = initializeAndLeaveLocked(cls, inst, runtimeLock); // runtimeLock may have been dropped but is now locked again // If sel == initialize, class_initialize will send +initialize and // then the messenger will send +initialize again after this // procedure finishes. Of course, if this is not being called // from the messenger then it won&#x27;t happen. 2778172 &#125; runtimeLock.assertLocked(); curClass = cls; // The code used to lookpu the class&#x27;s cache again right after // we take the lock but for the vast majority of the cases // evidence shows this is a miss most of the time, hence a time loss. // // The only codepath calling into this without having performed some // kind of cache lookup is class_getInstanceMethod(). for (unsigned attempts = unreasonableClassCount();;) &#123; // curClass method list. Method meth = getMethodNoSuper_nolock(curClass, sel); if (meth) &#123; imp = meth-&gt;imp; goto done; &#125; if (slowpath((curClass = curClass-&gt;superclass) == nil)) &#123; // No implementation found, and method resolver didn&#x27;t help. // Use forwarding. imp = forward_imp; break; &#125; // Halt if there is a cycle in the superclass chain. if (slowpath(--attempts == 0)) &#123; _objc_fatal(&quot;Memory corruption in class list.&quot;); &#125; // Superclass cache. imp = cache_getImp(curClass, sel); if (slowpath(imp == forward_imp)) &#123; // Found a forward:: entry in a superclass. // Stop searching, but don&#x27;t cache yet; call method // resolver for this class first. break; &#125; if (fastpath(imp)) &#123; // Found the method in a superclass. Cache it in this class. goto done; &#125; &#125; // No implementation found. Try method resolver once. if (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123; behavior ^= LOOKUP_RESOLVER; return resolveMethod_locked(inst, sel, cls, behavior); &#125; done: log_and_fill_cache(cls, imp, sel, inst, curClass); runtimeLock.unlock(); done_nolock: if (slowpath((behavior &amp; LOOKUP_NIL) &amp;&amp; imp == forward_imp)) &#123; return nil; &#125; return imp;&#125; 如果传入的behavior是LOOKUP_INITIALIZE并且没有被初始化，就会进入initializeAndLeaveLocked 123456789101112131415161718192021222324// initializeAndLeaveLocked -&gt; initializeAndMaybeRelock -&gt; initializeNonMetaClass -&gt; callInitializevoid initializeNonMetaClass(Class cls)&#123; ASSERT(!cls-&gt;isMetaClass()); Class supercls; bool reallyInitialize = NO; // Make sure super is done initializing BEFORE beginning to initialize cls. // See note about deadlock above. supercls = cls-&gt;superclass; if (supercls &amp;&amp; !supercls-&gt;isInitialized()) &#123; initializeNonMetaClass(supercls); &#125; ...&#125;void callInitialize(Class cls)&#123; ((void(*)(Class, SEL))objc_msgSend)(cls, @selector(initialize)); asm(&quot;&quot;);&#125; 这里initializeNonMetaClass对superclass进行了递归，如果存在父类，则先调用父类的方法而callInitialize方法用到了消息发送objc_msgSend，根据消息发送机制，如果子类没有找到实现的方法，会到父类里面查找，找到方法，则调用，所以，如果多个子类没有实现initialize，而父类实现了，在不同的子类初始化的时候都会调用父类的initialize方法，导致initialize被调用多次 第一次使用的时候（objc_msgSend）调用 先调用父类initialize，再调用子类的 调用方法使用objc_msgSend，如果子类没有实现initialize，会调用父类的initialize（存在多次调用的问题） 由于使用objc_msgSend调用，与普通方法一样，分类的initialize方法会先找到，相当于覆盖类的initialize方法，顺序与编译顺序相反（后编译的分类方法会被加到前面）","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"}]},{"title":"【iOS逆向】为Tweak插件添加设置项","slug":"ios-tweak-preference","date":"2019-10-12T03:45:59.000Z","updated":"2019-10-12T03:45:59.000Z","comments":true,"path":"2019-10-12/ios-tweak-preference/","link":"","permalink":"http://zhengbomo.github.io/2019-10-12/ios-tweak-preference/","excerpt":"THEOS提供了iphone/preference_bundle_modern工具，可以为插件添加设置项，该设置项会被打包成bundle并和tweak插件合并打包到deb文件中","text":"THEOS提供了iphone/preference_bundle_modern工具，可以为插件添加设置项，该设置项会被打包成bundle并和tweak插件合并打包到deb文件中 创建preference bundle先进入我们tweak插件的目录，然后通过nic.pl创建preference_bundle_modern 12345678910111213141516171819202122$ nic.plNIC 2.0 - New Instance Creator------------------------------ [1.] iphone/activator_event [2.] iphone/application_modern [3.] iphone/application_swift [4.] iphone/flipswitch_switch [5.] iphone/framework [6.] iphone/library [7.] iphone/preference_bundle_modern [8.] iphone/tool [9.] iphone/tool_swift [10.] iphone/tweak [11.] iphone/xpc_serviceChoose a Template (required): 7Project Name (required): testprereferencePackage Name [com.yourcompany.testprereference]: com.bomo.testprereferenceAuthor/Maintainer Name [bomo]:[iphone/preference_bundle_modern] Class name prefix (three or more characters unique to this project) [XXX]: BMInstantiating iphone/preference_bundle_modern in testprereference/...Adding &#x27;testprereference&#x27; as an aggregate subproject in Theos makefile &#x27;Makefile&#x27;.Done. 生成下面testprereference文件夹 123456789101112- control- Makefile- Tweak.x- tweaktest- testprereference | - Resources | - Info.plist | - Root.plist 配置设置页面Root页面（从entry.plist进入） | - entry.plist 定义在设置页面的入口按钮和文字 | - Makefile | - BMRootListController.h | - BMRootListController.m Root页面绑定的控制器，可以在这里实现action事件 图标处理图标放在Resources目录下大小为29*29，可以使用2&#x2F;3倍图 12345testprereference | - Resources | - icon.png | - icon@2x.png | - icon@3x.png entry.plist我们看一下设置入口配置的定义entry.plist 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;entry&lt;/key&gt; &lt;dict&gt; &lt;key&gt;bundle&lt;/key&gt; &lt;string&gt;testprereference&lt;/string&gt; &lt;!-- cell类型 --&gt; &lt;key&gt;cell&lt;/key&gt; &lt;string&gt;PSLinkCell&lt;/string&gt; &lt;!-- 详情页绑定的控制器 --&gt; &lt;key&gt;detail&lt;/key&gt; &lt;string&gt;BMRootListController&lt;/string&gt; &lt;!-- 图标，放在Resources目录下，可以是icon@3x.png --&gt; &lt;key&gt;icon&lt;/key&gt; &lt;string&gt;icon.png&lt;/string&gt; &lt;!-- 是否绑定控制器 --&gt; &lt;key&gt;isController&lt;/key&gt; &lt;true/&gt; &lt;!-- 显示的文本 --&gt; &lt;key&gt;label&lt;/key&gt; &lt;string&gt;测试设置&lt;/string&gt; &lt;/dict&gt;&lt;/dict&gt;&lt;/plist&gt; 编译后可以打开设置.app可以看到该项，如上图，接下来我们配置设置主页面Root.plist Root.plist定义设置主页面的内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;items&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;cell&lt;/key&gt; &lt;string&gt;PSGroupCell&lt;/string&gt; &lt;key&gt;label&lt;/key&gt; &lt;string&gt;分组1&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;!-- cell类型：开关类型 --&gt; &lt;key&gt;cell&lt;/key&gt; &lt;string&gt;PSSwitchCell&lt;/string&gt; &lt;!-- 默认值：true --&gt; &lt;key&gt;default&lt;/key&gt; &lt;true/&gt; &lt;!-- userdefault关联的bundleId --&gt; &lt;key&gt;defaults&lt;/key&gt; &lt;string&gt;com.bomo.testprereference&lt;/string&gt; &lt;!-- 关联的userDefault的key --&gt; &lt;key&gt;key&lt;/key&gt; &lt;string&gt;testpreferenceMainSwitch&lt;/string&gt; &lt;!-- 显示的文本 --&gt; &lt;key&gt;label&lt;/key&gt; &lt;string&gt;插件开关&lt;/string&gt; &lt;!-- 当值改变的时候回发出通知 --&gt; &lt;key&gt;PostNotification&lt;/key&gt; &lt;string&gt;com.bomo.testprereference/reloadSettings&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;cell&lt;/key&gt; &lt;string&gt;PSButtonCell&lt;/string&gt; &lt;!-- 关联的事件，在BMRootListController定义 --&gt; &lt;key&gt;action&lt;/key&gt; &lt;string&gt;openHomePage&lt;/string&gt; &lt;!-- 按钮颜色 --&gt; &lt;key&gt;isDestructive&lt;/key&gt; &lt;true/&gt; &lt;!-- 按钮文本 --&gt; &lt;key&gt;label&lt;/key&gt; &lt;string&gt;打开项目主页&lt;/string&gt; &lt;/dict&gt; &lt;/array&gt; &lt;!-- navigationbar标题 --&gt; &lt;key&gt;title&lt;/key&gt; &lt;string&gt;测试插件&lt;/string&gt;&lt;/dict&gt;&lt;/plist&gt; 编译后可以查看效果 RootListController关联的controllerBMRootListController实现PSButtonCell绑定的action 12345678910@implementation BMRootListController// ...- (void)openHomePage &#123; NSURL *url = [NSURL URLWithString:@&quot;https://blog.bombox.org&quot;]; [UIApplication.sharedApplication openURL:url options:@&#123;&#125; completionHandler:nil];&#125;@end 读取配置在Root.plist里面，对于每一个设置项，这里有详细的说明 其中有两个属性 defaults：设置UserDefault关联的bundleId key：设置关联UserDefaults的key，例如PSSwitchCell开关变化的时候，会把值保存到plist文件里面 如上面的设置 123456&lt;!-- userdefault关联的bundleId --&gt;&lt;key&gt;defaults&lt;/key&gt;&lt;string&gt;com.bomo.testprereference&lt;/string&gt;&lt;!-- 关联的userDefault的key --&gt;&lt;key&gt;key&lt;/key&gt;&lt;string&gt;testpreferenceMainSwitch&lt;/string&gt; 我们可以NSUserDefault在bundle的程序中读取（如：BMRootListController） 123456NSString *bundleId = @&quot;com.bomo.testprereference&quot;;NSString *switchStatusKey = @&quot;testpreferenceMainSwitch&quot;;NSDictionary *bundleDefaults = [[NSUserDefaults standardUserDefaults] persistentDomainForName:bundleId];BOOL isSwitchOn = [[bundleDefaults objectForKey:switchStatusKey] boolValue];NSLog(@&quot;%@&quot;, @(isSwitchOn)); 在Tweak项目中无法使用NSUserDefault的方式读取配置，我们的配置会被保存在/var/mobile/Library/Preferences/&#123;bundle_id&#125;.plist，我们在tweak插件中，可以通过该文件读取到设置的值，但不要代码中写入值 12345NSString *bundleId = @&quot;com.bomo.testprereference&quot;;NSString *plistPath = [NSString stringWithFormat:@&quot;/var/mobile/Library/Preferences/%@.plist&quot;, bundleId];NSDictionary *settings = [[NSDictionary alloc] initWithContentsOfFile:plistPath];BOOL isOn = [settings[@&quot;testpreferenceMainSwitch&quot;] boolValue]; 监听设置变化通过下面方法监听系统通知 123456CFNotificationCenterAddObserver(CFNotificationCenterGetDarwinNotifyCenter(), // 系统的notifycenter，固定 NULL, reloadSettings, // 回调函数 CFSTR(&quot;com.bomo.testprereference/reloadSettings&quot;), // 通知Key NULL, CFNotificationSuspensionBehaviorCoalesce); 通知的key在配置cell的时候定义（Root.plist） 123456789&lt;dict&gt; &lt;!-- cell类型 --&gt; &lt;key&gt;cell&lt;/key&gt; &lt;string&gt;PSSwitchCell&lt;/string&gt; ... &lt;!-- 当值改变的时候回发出通知 --&gt; &lt;key&gt;PostNotification&lt;/key&gt; &lt;string&gt;com.bomo.testprereference/reloadSettings&lt;/string&gt;&lt;/dict&gt; 监听函数 123static void reloadSettings(CFNotificationCenterRef center, void *observer, CFStringRef name, const void *object, CFDictionaryRef userInfo) &#123; // reload setting，这里需要重新读取配置&#125; 安装插件编译打包后，preferencebundle会被编译成bundle放到deb里面，PreferenceLoaders是MobileSubstrate其中的一个工具，可以把tweak扩展PreferenceBundles注入到iOS的设置中 入口文件entry.plist会被装到/Library/PreferenceLoader/Preferences 我们编译好的preference bundle（可执行文件和资源）会被安装到/Library/PreferenceBundles下面 而配置数据文件&#123;bundle_id&#125;.plist，会被存放在/var/mobile/Library/Preferences/目录下 在编译的时候可能会报下面问题 12ld: warning: directory not found for option &#x27;-F/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.4.sdk/System/Library/PrivateFrameworks&#x27;ld: framework not found Preferences 这是由于Preferences是私有库，我们可以从theos/sdk找到Preferences.framework，下载下来放到/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/System/Library/PrivateFrameworks，这样就可以正常引用了 参考 Preferences_specifier_plist PreferenceLoader","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"},{"name":"逆向","slug":"逆向","permalink":"http://zhengbomo.github.io/tags/%E9%80%86%E5%90%91/"}]},{"title":"搭建自己的Cydia源","slug":"make-cydia-source","date":"2019-10-10T07:43:48.000Z","updated":"2019-10-10T07:43:48.000Z","comments":true,"path":"2019-10-10/make-cydia-source/","link":"","permalink":"http://zhengbomo.github.io/2019-10-10/make-cydia-source/","excerpt":"对于自己开发的插件，也需要使用软件源来维护和备份，可以向其他源一样，直接安装插件，这个记录一下搭建的过程","text":"对于自己开发的插件，也需要使用软件源来维护和备份，可以向其他源一样，直接安装插件，这个记录一下搭建的过程 准备 创建一个目录 cydia 在cydia里面再创建一个目录debs，把所有的插件都放到里面 新建一个文本文件Release，用于描述源信息 在cydia添加一个图标CydiaIcon.png，在软件源列表显示 目录如下 123456- cydia |- CydiaIcon.png 源图标 |- Release 描述源信息 |- debs 插件 |- com.bomo.tweaksb_0.0.1-7_iphoneos-arm.deb |- com.bomo.tweakjianshu_0.0.1-7_iphoneos-arm.deb Release 文件如下 123456789101112Origin: BigBossLabel: BigBossSuite: stableVersion: 1.0Codename: BigBossSupport: http://cydia.saurik.com/support/*Architectures: darwin-arm iphoneos-armComponents: mainDescription: apps &amp; tweaksMD5Sum: be8806290d5904cdf45b542706f6a3ad 165020 main/binary-darwin-arm/Packages 03026ac993187b0eecae50466f64fb3c 35049 main/binary-darwin-arm/Packages.gz Release相关说明 12345678910111213必须Origin: 软件源名称，可以使用中文（Cydia的软件源列表中显示的标题）Label: 同上，也可以使用中文Suite: 软件源的类型，比如正式源，测试源等，可以分别用stable, beta, unstable等来表示，一般填stable就可以了Version: 版本号，这个其实不重要，随便填，一般都是写1.0Codename: 代码代号，比如BigBoss的就写BigBoss，威锋的就写WeiPhone，也没什么限制，只能用英文Architectures: 结构。iPhone平台统一写iphoneos-armComponents: mainDescription: 软件介绍，可以使用中文和html代码，具体能使用哪些代码在下面会介绍。可选Support: 支持，没什么作用，除非特别需要，否则可以不要这个。MD5Sum: 不是必须的，但如果Packages文件位置不与Release文件在同一目录下，则必须有此项。另外，如果需要签名Release文件，也必须有这个。关于MD5Sum的格式，在下文也会介绍。 打包插件接下来我们需要 linux 环境，并且需要安装dpkg-dev，我这里使用 docker 创建的环境，其他 linux 环境也可以 12345# 更新系统源apt-get update# 安装dpkg-devapt-get install dpkg-dev 把我们准备好的文件拷贝到 linux 系统 1docker cp ~/Desktop/cydia 75119aae5029:/var/cydia 生成Packages 12345678# 进入我们的文件目录cd /var/cydia# 扫描插件到 Packagedpkg-scanpackages debs /dev/null &gt; Packagestar zcvf Packages.gz Packagesbzip2 -k Packages Packages.bz2 上面步骤生成三个文件 Package Packages.bz2 Package.gz 接下来是先生成一个密钥 1gpg --gen-key 提示输入Email和Real name，输入密码，生成过程可能需要等一会 签名 Package 1gpg -abs -r &quot;你刚才的输入的 Real name&quot; -o Release.gpg Release 输入密码，生成Release.gpg，文件目录如下 1234567891011- cydia |- CydiaIcon.png 源图标 |- Release 描述源信息 |- debs 插件 |- com.bomo.tweaksb_0.0.1-7_iphoneos-arm.deb |- com.bomo.tweakjianshu_0.0.1-7_iphoneos-arm.deb |- Release.gpg |- Packages |- Packages.bz2 |- Packages.gz |- Release.gpg 接下来把整个cydia文件夹放到可以被 web 访问到的地方，访问的路径就是源地址，如http://192.168.0.3:8080/cydia，然后可以添加到 Cydia 安装插件了 更新如果有 deb 更新，重新执行一下上面命令重新导出即可 123456cd cydia;# 删除原来的 packagerm Packages; rm Packages.gz; rm Packages.bz2;# 生成新的packagedpkg-scanpackages debs /dev/null &gt; Packages &amp;&amp; tar zcvf Packages.gz Packages &amp;&amp; bzip2 -k Packages Packages.bz2 然后替换原来的文件即可，在 Cydia 就会收到更新 引用 http://www.saurik.com/id/7","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"}]},{"title":"初识ARM64汇编","slug":"ios-arm64-asm","date":"2019-10-08T08:29:04.000Z","updated":"2019-10-08T08:29:04.000Z","comments":true,"path":"2019-10-08/ios-arm64-asm/","link":"","permalink":"http://zhengbomo.github.io/2019-10-08/ios-arm64-asm/","excerpt":"所有的程序，最终编译为机器（汇编）代码，运行起来，本质都是操作CPU的寄存器和内存，了解了寄存器和内存的操作，就能知道程序具体做了什么","text":"所有的程序，最终编译为机器（汇编）代码，运行起来，本质都是操作CPU的寄存器和内存，了解了寄存器和内存的操作，就能知道程序具体做了什么 汇编是依赖机器架构的，不同的CPU的指令不同 iOS汇编 真机：amr64，GNU 汇编 模拟器：x86，AT&amp;T 汇编 寄存器CPU运行时用于临时存储的数据，都会放到寄存器中 通用寄存器(数据地址寄存器)主要用户存储临时数据，例如加法运算，地址操作等 64bit 的：0x ~ x28，有29个寄存器 32bit 的：w0 ~ w28（属于 x0 ~ x28的低32bit） 其中 x0 ~ x7通常用来存放函数的参数，超过的食用堆栈来存放x0 通常用来存放函数的返回值 通过 lldb 存取寄存器 12345678910111213141516# 读取所有寄存器地址的值registe read# 读取寄存器地址为x0的值registe read x0# 向寄存器地址为x0写入值registe write x0 0x1100000000000011# 读取寄存器x0的值registe read x0 x0 = 0x1100000000000011# 读取寄存器 w0的值(相当于取 x0 的低32bit)registe read w0 x0 = 0x00000011 再xcode查看寄存器的值 PC寄存器(program counter)PC寄存器为指令指针寄存器，用于存放当前CPU要读取的指令的地址，PC寄存器指到哪，CPU执行到哪 SP寄存器（stack pointer registers）是一个指向堆栈顶部的寄存器，通常用于为方法执行开辟空间和回收空间，进入方法入栈，离开方法出栈，例如下面 12345678Test`main: 0x100dc3f9c &lt;+0&gt;: sub sp, sp, #0x10 ; sp的指针往下移 0x10，开辟栈空间用于存放临时变量 0x100dc3fa0 &lt;+4&gt;: str wzr, [sp, #0xc] 0x100dc3fa4 &lt;+8&gt;: str w0, [sp, #0x8] 0x100dc3fa8 &lt;+12&gt;: str x1, [sp]-&gt; 0x100dc3fac &lt;+16&gt;: mov w0, #0x1 0x100dc3fb0 &lt;+20&gt;: add sp, sp, #0x10 ; sp的指针往上移 0x10，回收栈空间 0x100dc3fb4 &lt;+24&gt;: ret CPSR状态寄存器（current program status register）CPSR是状态寄存器，用于存放程序运行中一些状态标识。其他寄存器是用来存放数据的，而CPSR寄存器是按位起作用的，它的每一位都有专门的含义，通常存放比较结果，溢出等信息，下面为C语言判断语句的 12345if (a == 10) &#123; printf(&quot;aa&quot;);&#125; else &#123; printf(&quot;bb&quot;);&#125; 对应的汇编代码 1234567891011121314151617...cmp w8, #0xa ; =0xa ; 比较w8和#0xa的值，w8就是a，比较结果会放到CPSR寄存器中b.ne 0x104037f64 ; &lt;+60&gt; at main.m:16:9 ; 如果不等，则跳到 0x104037f64，通过CPSR的状态判断adrp x0, 0add x0, x0, #0xfb0 ; =0xfb0bl 0x104037f80 ; symbol stub for: printfb 0x104037f70 ; &lt;+72&gt; at main.m:18:1 ; 跳到 0x104037f70adrp x0, 0add x0, x0, #0xfb3 ; =0xfb3bl 0x104037f80 ; symbol stub for: printfldur w0, [x29, #-0x4] ; 判断外... 高速缓存由于CPU读取指令需要从内存中读取，而内存的读写速度要远远低于寄存器的速度，为了拟补这里的时间差，通常CPU还会提供一个速度介于内存和寄存器的高速缓存，再程序运行前，会先将要执行的指令和数据提前读取到高速缓存中，而CPU从高速缓存中读取指令来执行 指令汇编使用;分号开头表示注释 函数定义声名 test 函数 1234567891011; global 用于声明函数为公开的，可以被外部调用; 汇编语言的函数比上层函数多一个下划线（外部调用为 test），如果是内部使用的函数，可以不加下划线.global _test, _add, _sub_test:; 赋值操作: x0 = 0x8mov x0 #0x8; 赋值赋值: x1 = x0mov x1, x0; 函数返回: returnret mov：赋值操作mov指令只允许操作寄存器的，不允许直接操作内存 12; 把 0x8 赋值给寄存器 x0mov x0, #0x8 add: 加法运算add只能对寄存器做加法，内存中的数据必须先放到寄存器中 12; x1 = x1 + x0add x1, x0 sub：减法12345; sp的指针往下移 0x20sub sp, sp, #0x20 ; sp的指针往上移 0x20add sp, sp, #0x20 ret指令返回函数调用出，相当于c语言的return，与bl和lr配合使用，本质是将lr寄存器的值赋值给pc寄存器 1ret cmp：比较两个数（减法）比较结果会被放在 cpsr（程序状态寄存器里面），cpsr使用标识位控制 123mov x0, #0x3mov x1, #0x2cmp x0, x1 b跳转指令相当于 C 语言的 goto 12345; 直接跳到 mycodeb mycodemov x0, #0x5mycode:mov x1, #0x6 b指令可以带条件，通常跟 cmp 配合使用 eq: 相等 ne：不相等 gt：大于 lt：小于 ge：大于或等于 le：小于或等于 123456789mov x0, #0x1mov x1, #0x2; 比较 x0, x1cmp x0, x1; 如果x0 = x1就跳转beq mycode; 如果x0 &gt; x1则跳转bgt mycode bl指令可以带返回的跳转指令，跳转执行完成后会回到调用的地方继续往下执行，相当于函数调用 1234567891011privatecode:mov x0, #0x1mov x2, #0x2add x2, x0, x1ret_test:; 在 privatecode ret 之后，回继续走下面的语句，如果是 b 指令的话，不会走下面的语句bl privatecodemov x3, #0x2mov x4, #0x4 bl 会将吓一跳指令的地址存储到 lr（x30）寄存器中 ldr&#x2F;ldur&#x2F;ldp（从内存读取数据）如果偏移地址是正数，用ldr，如果是负数，用ldur 12345678910; 从x1的地址中读取数据值到 x0 中ldr x0, [x1]; 从[x1 + 0x4]地址读取数据值到 x0 中ldr x0, [x1, #0x4]; 在上面的基础上，加上 x1 = x1 + 0x4 的操作，会改变 x1ldr x0, [x1, #0x4]!ldur x0, [x1, #-0x8] ldp，读取一对数据到（2个）寄存器 12; x1偏移0x4的地址分别读取4个字节到 w1 和 w2ldp w1, w2, [x1, #0x4] str&#x2F;stur&#x2F;stp（往内存写数据）寄存器在左边，如果偏移地址是正数，用str，如果是负数，用stur 1234; 把 w0的数据写到 x1的地址str w0, [x1, #0x5]stur w0, [x1, #-0x5] stp: 写入2个寄存器的数据到连续的内存 12; x1偏移0x4的地址分别读取4个字节到 w1 和 w2stp w1, w2, [x1, #-0x5]! wzr&#x2F;xzr（零寄存器）里面存储的值为0，不能在lldb中读&#x2F;写，表示清零操作（false, nil, 0） wzr（32bit） xzr（64bit） lr寄存器lr：存储函数的返回地址，与bl配合使用（bl执行跳转执行指令ret后，会回到调用的地方，就是根据lr存放的地址） 函数的分类 叶子函数：内部不再调用其他函数的函数，不用再开辟栈空间 非叶子函数：函数内部会调用其他的函数","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"},{"name":"ARM64","slug":"ARM64","permalink":"http://zhengbomo.github.io/tags/ARM64/"}]},{"title":"【iOS逆向】Mach-O文件","slug":"ios-mach-o","date":"2019-09-12T08:31:26.000Z","updated":"2019-09-12T08:31:26.000Z","comments":true,"path":"2019-09-12/ios-mach-o/","link":"","permalink":"http://zhengbomo.github.io/2019-09-12/ios-mach-o/","excerpt":"Mach-O是Mach object的缩写，是Mac&#x2F;iOS上用于存储程序、库的标准格式，这里简要解析Mach-O文件格式，结构和一些要点","text":"Mach-O是Mach object的缩写，是Mac&#x2F;iOS上用于存储程序、库的标准格式，这里简要解析Mach-O文件格式，结构和一些要点 Mach-O格式Mach-O是一个以数据块分组的二进制字节流，这些数据块包含元信息，比如字节顺序、CPU类型、数据块大小等等 典型的Mach-O文件通常包含三个主要区域 Header: 描述Mach-O文件的基本信息，如标识文件类型，目标架构类型，内存对齐大小，大小端序，加载命令数量，flags信息等 Load commands: 描述文件中每个段的信息（物理内存大小，虚拟内存等信息） Raw data: 在Load command中定义的segment的原始数据 如下图 查看Mach-O文件结构 file: 查看Mach-O文件类型 12# Hugu为可执行文件file Hugo otool：查看Mach-O特定部分和段的内容 12345678910# 查看mach-o headerotool -h Hugo# 查看load commandotool -l Hugo# 查看链接的动态库otool -L Hugo# otool 支持很多参数，查看不同的信息 size：查看段的内存分布 1size -l -m -x Hugo 输出 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Segment __PAGEZERO: 0x100000000 (vmaddr 0x0 fileoff 0)Segment __TEXT: 0x1308000 (vmaddr 0x100000000 fileoff 0)Section __text: 0x104f4cc (addr 0x100005150 offset 20816)Section __stubs: 0x42d8 (addr 0x10105461c offset 17122844)Section __stub_helper: 0x42c0 (addr 0x1010588f4 offset 17139956)Section __objc_methname: 0xbf942 (addr 0x10105cbb4 offset 17157044)Section __objc_classname: 0x130d2 (addr 0x10111c4f6 offset 17941750)Section __objc_methtype: 0x1c635 (addr 0x10112f5c8 offset 18019784)Section __cstring: 0xf26fd (addr 0x10114bc00 offset 18136064)Section __ustring: 0xd3a0 (addr 0x10123e2fe offset 19129086)Section __const: 0x2db07 (addr 0x10124b6a0 offset 19183264)Section __gcc_except_tab: 0x21a80 (addr 0x1012791a8 offset 19370408)Section __swift5_typeref: 0xc382 (addr 0x10129ac28 offset 19508264)Section __swift5_fieldmd: 0xb028 (addr 0x1012a6fac offset 19558316)Section __swift5_builtin: 0x76c (addr 0x1012b1fd4 offset 19603412)Section __swift5_reflstr: 0x1417d (addr 0x1012b2740 offset 19605312)Section __swift5_assocty: 0xd38 (addr 0x1012c68c0 offset 19687616)Section __swift5_proto: 0x624 (addr 0x1012c75f8 offset 19691000)Section __swift5_types: 0x998 (addr 0x1012c7c1c offset 19692572)Section __swift5_capture: 0xb524 (addr 0x1012c85b4 offset 19695028)Section __swift5_protos: 0x50 (addr 0x1012d3ad8 offset 19741400)Section __dof_RACSignal: 0x37b (addr 0x1012d3b28 offset 19741480)Section __dof_RACCompou: 0x2e8 (addr 0x1012d3ea3 offset 19742371)Section __unwind_info: 0x31ce4 (addr 0x1012d418c offset 19743116)Section __eh_frame: 0x2184 (addr 0x101305e70 offset 19947120)total 0x1302e97Segment __DATA: 0x560000 (vmaddr 0x101308000 fileoff 19955712)Section __got: 0x1190 (addr 0x101308000 offset 19955712)Section __la_symbol_ptr: 0x2c90 (addr 0x101309190 offset 19960208)Section __mod_init_func: 0x40 (addr 0x10130be20 offset 19971616)Section __const: 0x48950 (addr 0x10130be60 offset 19971680)Section __cfstring: 0x6fea0 (addr 0x1013547b0 offset 20268976)Section __objc_classlist: 0x68c8 (addr 0x1013c4650 offset 20727376)Section __objc_nlclslist: 0x2c0 (addr 0x1013caf18 offset 20754200)Section __objc_catlist: 0x1ef8 (addr 0x1013cb1d8 offset 20754904)Section __objc_nlcatlist: 0x88 (addr 0x1013cd0d0 offset 20762832)Section __objc_protolist: 0x11f8 (addr 0x1013cd158 offset 20762968)Section __objc_imageinfo: 0x8 (addr 0x1013ce350 offset 20767568)Section __objc_const: 0x3c85f8 (addr 0x1013ce358 offset 20767576)Section __objc_selrefs: 0x2e430 (addr 0x101796950 offset 24734032)Section __objc_protorefs: 0x4a8 (addr 0x1017c4d80 offset 24923520)Section __objc_classrefs: 0x5c00 (addr 0x1017c5228 offset 24924712)Section __objc_superrefs: 0x39d8 (addr 0x1017cae28 offset 24948264)Section __objc_ivar: 0xc120 (addr 0x1017ce800 offset 24963072)Section __objc_data: 0x59c10 (addr 0x1017da920 offset 25012512)Section __data: 0x1c885 (addr 0x101834530 offset 25380144)Section __swift_hooks: 0xb8 (addr 0x101850db8 offset 25497016)Section __bss: 0x12e30 (addr 0x101850e70 offset 0)Section __common: 0x1b88 (addr 0x101863ca0 offset 0)total 0x55d825Segment __LINKEDIT: 0x168000 (vmaddr 0x101868000 fileoff 25509888)total 0x1019d0000 也可以通过MachOView查看Segment相关信息 还有一个功能非常强大的二进制编辑器010Editor，需要安装一下MachO模板，与MachOView类似，使用起来也非常方便 Header我们通过machoview查看 名称 解释 magic Mach-O魔数，FAT:0xcafebabe, ARMv7:0xfeedface, ARM64:0xfeedfacf cputype、cpusubtype CPU架构及子版本 filetype mach-o文件类型 ncmds 加载命令的数量 sizeofcmds 所有加载命令的大小 flags dyld加载需要的一些标记 reserved 64位保留字段 在Header信息中，flags标志信息有一个标志为MH_PIE（在xnu项目的EXTERNAL_HEADERS/mach-o/loader.h中可以找到），意思是开启ASLR 笔者尝试把MH_PIE去掉，然后重签名跑到真机上，发现会闪退 Mach-O文件类型在苹果开源的内核xnu源码中EXTERNAL_HEADERS/mach-o/loader.h可以找到Mach-O文件格式的定义 12345678910111213#define MH_OBJECT 0x1 /* relocatable object file */#define MH_EXECUTE 0x2 /* demand paged executable file */#define MH_FVMLIB 0x3 /* fixed VM shared library file */#define MH_CORE 0x4 /* core file */#define MH_PRELOAD 0x5 /* preloaded executable file */#define MH_DYLIB 0x6 /* dynamically bound shared library */#define MH_DYLINKER 0x7 /* dynamic link editor */#define MH_BUNDLE 0x8 /* dynamically bound bundle file */#define MH_DYLIB_STUB 0x9 /* shared library stub for static */ /* linking only, no section contents */#define MH_DSYM 0xa /* companion file with only debug */ /* sections */#define MH_KEXT_BUNDLE 0xb /* x86_64 kexts */ 常见的类型有 MH_OBJECT 目标文件（.o） 静态库文件（.a）（多个目标文件合并） MH_EXECUTE： 可执行文件，我们编译出来的App的主程序就是该类型 MH_DYLIB：动态库 dylib文件 framework动态库(.framework&#x2F;xx) MH_DYLINKER /usr/lib/dyld：动态链接器 MH_DSYM .dSYM&#x2F;Contents&#x2F;Resources&#x2F;DWARF&#x2F;xx（符号表） Universal Binary（通用二进制文件）包含多个CPU架构的二进制文件，在运行时，只会加载对应架构的二进制 1234$ file jcmjcm: Mach-O universal binary with 2 architectures: [arm_v7:Mach-O executable arm_v7] [arm64]jcm (for architecture armv7): Mach-O executable arm_v7jcm (for architecture arm64): Mach-O 64-bit executable arm64 Segment在machoview的load commands可以看到所有段的 LC_SEGMENT_64：记录一个段，加载后被映射到内存中 LC_DYLD_INFO_ONLY：记录动态链接的重要信息，动态链接器要根据它来进行地址重定向 LC_SYMTAB：文件所使用的符号表，符号数，字符串表的偏移量和大小 LC_DYSYMTAB：动态链接器所使用的符号表，找到后获取间接符号表偏移量 LC_LOAD_DYLINKER：默认的加载器路径（/usr/bin/dylb） LC_UUID: Mach-O文件的唯一标识 LC_MAIN：程序的入口，动态链接器获取该地址，然后程序跳转到该处运行 LC_SOURCE_VERSION：构建二进制文件的源代码版本 LC_VERSION_MIN_IPHONEOS：最低支持系统版本 LC_ENCRYPTION_INFO_64：文件加密信息，我们判断是否脱壳，就是用了这里的信息 LC_RPATH：链接器搜索路径列表，主要搜索framework LC_FUNCTION_STARTS: 函数其实地址表，调试器货其他程序能判断一个地址是否在该表范围内 LC_DATA_IN_CODE: 定义在代码内的非指令表 LC_CODE_SIGNATURE: 代码签名信息 LC_SEGMENT_64图中可以看到，LC_SEGMENT_64段有4个 1234567891011121314151617181920* LC_SEGMENT_64(`__PAGEZERO`) * VM Address：0x0000000000000000 * VM Size： 0x0000000100000000 * File Offset: 0 * File Offset: 0* LC_SEGMENT_64(`__TEXT`) * VM Address：0x100000000 * VM Size： 0x001308000 * File Offset: 0x000000000 * File Size: 0x001308000* LC_SEGMENT_64(`__DATA`) * VM Address：0x101308000 * VM Size： 0x000560000 * File Offset: 0x001308000 * File Size: 0x00054C000* LC_SEGMENT_64(`__LINKEDIT`) * VM Address：0x101868000 * VM Size： 0x000168000 * File Offset: 0x001854000 * File Size: 0x000166AB0 上面可以看出 PAGEZERO段并不占用文件大小，当mach-o加载到内存时会占用8个字节（64位） TEXT段从0开始的，也就是header和loadcommand也属于TEXT段，加载到内存后，排在PAGEZERO后面 __TEXT段TEXT段包含可执行的代码和一些只读数据，静态链接器设置该段位可读可执行，进程被允许执行这些代码，但不能修改 __text：主程序代码 __stubs: 帮助动态链接库绑定符号 __const: const关键字修饰的常量 __cstring: 只读c语言字符串 __objc_methname: OC方法名 __objc_classname：OC类名 __objc_methtype：OC方法类型（方法签名） __unwind_info：编译器自动生成，用于确定异常发生时栈所对应的信息 __DATA段包含了将会被更改的数据，静态链接器设置该段的虚拟内存权限位可读写 __got: 全局非懒绑定符号指针表 __la_symbol_ptr: 懒绑定符号指针表 __mod_init_func：C++类的构造函数 __const：未初始化过的常亮 __cfstring：CoreFoundation字符串 __objc_class_list：OC类列表 __objc_nlclslist：实现了+load方法的OC类列表 __objc_catlist：OC分类列表 __objc_protolist：OC协议列表 __objc_imageinfo：镜像信息，可用它区别Objective1.0与2.0 __objc_const：OC初始化过的常量 __objc_selrefs：OC选择器引用列表 __objc_protorefs：OC协议引用列表 __objc_classrefs：OC类引用列表 __objc_superrefs: OC父类引用列表 __objc_ivar: OC类的实例变量 __objc_data: OC初始化过的变量 __data：实际初始化数据段 __common：未初始化过的符号声明 __bss：未初始化的全局变量 __LINKEDIT包含动态链接库的原始数据，如符号，字符串，重定向表条目等 dylddyld用于加载以下类型的Mach-O文件，在iOS中，App的可执行文件和动态库都是由dyld负责加载的 MH_EXECUTE MH_DYLIB MH_BUNDLE 关于dyld如何加载mach-o文件，可以参考这里 ASLR（Address Space Layout Randomization）iOS4.3开始引入了ASLR技术，地址空间布局随机化，系统在加载Mach-O文件的时候，会随机在头部添加一部分内存空间，从而让Mach-O文件在每次加载到内存时的地址都不相同，是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的的一种技术 ASLR 会在程序每次载入的时候随机在原来的基础上添加随机的内存区域，已达到每次运行的程序地址都不一样，相当于__PAGEZERO段的位置后移了 我们可以在lldb调试器查看程序每个模块的偏移大小ASLR偏移的大小 12345# -o 表示虚拟地址偏移量，-f 表示路径(lldb) image list -o -f# 输出[ 0] 0x00000000003f8000 /private/var/containers/Bundle/Application/943EF984-E5F8-45FC-A466-99474D559B68/Test.app/Test(0x00000001003f8000) 0x00000000003f8000 为主程序Test的内存偏移地址，这个偏移地址每次启动App都是随机的 0x00000001003f8000 为主程序__TEXT段的起始地址，即ASLR偏移地址+__PAGEZERO的大小 由于MachO文件加载到内存中的数据和MachO文件的数据是一致的，连续的，所以，我们可以通过ASLR的偏移地址加上在MachO静态分析的地址，得到运行时的地址，我们再Hopper查看到的地址，其实就是没有算上ASLR，即上面的0x00000000003f8000 再Hopper搜索[ViewController test:]方法，可以看到该函数的地址为0x0000000100005744，根据上面得到的ASLR的偏移地址，就可以算出函数在内存中的地址，由于Hopper显示的地址是算上__PAGEZERO段的，所以直接加上即可 10x00000000003f8000 + 0x0000000100005744 小结了解Mach-O可以帮助我们理解dyld的加载Mach-O的过程以及与Mach-O相关的读取或操作，为逆向分析提供更好的思路","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"},{"name":"逆向","slug":"逆向","permalink":"http://zhengbomo.github.io/tags/%E9%80%86%E5%90%91/"}]},{"title":"【iOS逆向】LLDB动态调试","slug":"ios-lldb-debug","date":"2019-08-17T12:50:11.000Z","updated":"2019-08-17T12:50:11.000Z","comments":true,"path":"2019-08-17/ios-lldb-debug/","link":"","permalink":"http://zhengbomo.github.io/2019-08-17/ios-lldb-debug/","excerpt":"正向开发的时候通常是使用xcode对app进行调试，我们先来看看xcode的调试流程 手机启动app进程 手机启动debugservice服务，debugserver附加到App进程 调试器lldb通过连接debugservice进行调试","text":"正向开发的时候通常是使用xcode对app进行调试，我们先来看看xcode的调试流程 手机启动app进程 手机启动debugservice服务，debugserver附加到App进程 调试器lldb通过连接debugservice进行调试 debugserviceXcode调试用到的debugservice位于/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport/13.2/DeveloperDiskImage.dmg这个dmg下面，打开后可以在usr/bin/debugserver找到 当手机第一次通过xcode调试时，会把该文件拷贝到手机/Developer/usr/bin/debugserver下，未使用xcode调试过的手机没有该文件，这个程序只能调试通过xcode安装的app，无法调试从商店下载的app，为了调试其他的App，我们需要修改它的权限，把下面权限签到可执行文件 12345678910111213&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;com.apple.springboard.debugapplications&lt;/key&gt; &lt;true/&gt; &lt;key&gt;get-task-allow&lt;/key&gt; &lt;true/&gt; &lt;key&gt;task_for_pid-allow&lt;/key&gt; &lt;true/&gt; &lt;key&gt;run-unsigned-code&lt;/key&gt; &lt;true/&gt;&lt;/dict&gt;&lt;/plist&gt; 使用ldid签名 12345678910# 安装ldidbrew install ldid# 从原来的debugserver导出权限文件ldid -e debugserver &gt; debugserver.entitlements# 修改debugserver.entitlements，换成上面文件的内容# 重新签名ldid -Sdebugserver.entitlements debugserver 得到新的debugserver，传到手机/user/bin/debugserver上，这样可以直接在命令行使用 1scp debugserver root@xx.xx.xx.xx:/user/bin/ 还需要给debugserver添加可执行权限 1chmod +x debugserver 调试1. debugserver附加到进程让debugserver附加到App进程上，指定端口号和进程 12345678910debugserver 127.0.0.1:端口号 -a 进程id/进程名称# 如调试器附加到微信进程，端口号随机，只要没有被占用都可以debugserver 127.0.0.1:3333 -a WeChat# 附加成功后会等待链接，输出下面字符debugserver-@(#)PROGRAM:LLDB PROJECT:lldb-900.3.98 for arm64.Attaching to process WeChat...Listening to port 3333 for a connection from localhost... 我们如果直接使用xcode自带的debugserver来操作的话，会报下面错误，原因是debugserver权限不足 12345debugserver-@(#)PROGRAM:LLDB PROJECT:lldb-900.3.98 for arm64.Attaching to process wework...error: failed to attach to process named: &quot;&quot; unable to start the exception threadExiting. iOS12 下配置debugserver + lldb调试环境的小技巧和问题处理 2. debugserver启动调试如果App没有运行，可以直接启动App调试 12# 后面接的是完整路径debugserver -x auto xx.xx.xx.xx:3333 /private/var/containers/Bundle/Application/B7984908-D77C-47AE-97AF-3803988F1401/Test.app/Test 通过lldb连接调试器123456789101112131415161718# 进入lldb模式$ lldb# 连接调试器(lldb) process connect connect://xx.xx.xx.xx:3333# 链接成功后，会输出下面信息Process 40349 stopped* thread #1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = signal SIGSTOP frame #0: 0x0000000181971198 libsystem_kernel.dylib`mach_msg_trap + 8libsystem_kernel.dylib`mach_msg_trap:-&gt; 0x181971198 &lt;+8&gt;: retlibsystem_kernel.dylib`mach_msg_overwrite_trap: 0x18197119c &lt;+0&gt;: mov x16, #-0x20 0x1819711a0 &lt;+4&gt;: svc #0x80 0x1819711a4 &lt;+8&gt;: retTarget 0: (WeChat) stopped.(lldb) 这个时候进程会被暂停，可以使用continue让程序继续走 可能会出现下面问题 12(lldb) process connect connect://xx.xx.xx.xx:12121error: Failed to connect port 如果出现上面问题，可以通过端口转发到本地，使用USB端口转发速度也会更快，ip换成localhost 1iproxy 2333 3333 接下来使用lldb命令即可，与xcode调试一样 退出调试 1(lldb) exit 每次连接调试的时候都很麻烦，我们可以通过别名来简化连接，如下 12345# 使用 con 代替 process connect connect://xx.xx.xx.xx:12121(lldb) command alias con process connect connect://xx.xx.xx.xx:12121# 接下来就可以直接使用con连接(lldb) con lldb常用命令 列出所有断点：breakpoint list, br li 打开、关闭某个断点：breakpoint enable, breakpoint disable, br dis, br del 打印参数：frame variable, fr v 打印方法名和行数：frame info 打印寄存器的值：register read 修改寄存器的值：register write rax 123 列出文件加载基地址：image list 执行地址的加减运算：p/x 反调试使用ptrace函数反调试debugserver之所以可以调试APP, 是依赖一个系统函数ptrace(process trace 进程跟踪). 此函数提供了一个进程监听控制另外一个进程, 并且可以检查被控制进程的内容和寄存器里面的数据. 可以用来实现断电调试和系统调用跟踪. iOS中没有提供此函数的头文件, 但不是私有API. ptrace函数在iOS项目中不能找到，在MacOS工程可以引用到，我们把需要用到的函数声明搬过来 12345678910111213141516171819202122232425/** * request: 要做的事情 * pid: 要监听/操作的id * addr: 为request代表的操作提供的地址 */ptrace(int _request, pid_t _pid, caddr_t _addr, int _data)#define PT_TRACE_ME 0 /* child declares it&#x27;s being traced */#define PT_READ_I 1 /* read word in child&#x27;s I space */#define PT_READ_D 2 /* read word in child&#x27;s D space */#define PT_READ_U 3 /* read word in child&#x27;s user structure */#define PT_WRITE_I 4 /* write word in child&#x27;s I space */#define PT_WRITE_D 5 /* write word in child&#x27;s D space */#define PT_WRITE_U 6 /* write word in child&#x27;s user structure */#define PT_CONTINUE 7 /* continue the child */#define PT_KILL 8 /* kill the child process */#define PT_STEP 9 /* single step the child */#define PT_ATTACH ePtAttachDeprecated /* trace some running process */#define PT_DETACH 11 /* stop tracing a process */#define PT_SIGEXC 12 /* signals as exceptions for current_proc */#define PT_THUPDATE 13 /* signal for thread# */#define PT_ATTACHEXC 14 /* attach to running process with signal exception */#define PT_FORCEQUOTA 30 /* Enforce quota for root */#define PT_DENY_ATTACH 31#define PT_FIRSTMACH 32 /* for machine-specific requests */ 找地方执行，可以在load方法 1234+ (void)load &#123; // PT_DENY_ATTACH 表示拒绝调试 ptrace(PT_DENY_ATTACH, getpid(), 0, 0);&#125; 使用sysctl函数反调试使用sysctl函数可以判断当前程序是否正在被调试，需要隔一段时间检测一下 12345678910111213141516171819202122232425#import &lt;sys/sysctl.h&gt;bool isDebuging() &#123; // 控制码 int name[4]; // 里面放字节码, 查询信息 name[0] = CTL_KERN; // 内核 name[1] = KERN_PROC; // 查询进程 name[2] = KERN_PROC_PID; // 通过id查询, 传递的参数是进程id name[3] = getpid(); // 拿到当前进程id struct kinfo_proc info; // 结束进程查询结果的结构体 size_t info_size = sizeof(info); // 结构体的大小 int error = sysctl(name, sizeof(name)/sizeof(*name), &amp;info, &amp;info_size, 0, 0); if (!error) &#123; // p_flag 的值转换为二进制, 假如从低位到高位第12位的值为1(0x800), 则正在被调试 if (info.kp_proc.p_flag &amp; P_TRACED) &#123; return true; &#125; else &#123; return false; &#125; &#125; return false;&#125; 反反调试上面反调试方法都是C语言的方法，而我们知道fishhook可以 hook C方法，所以上面两个方法可以被fishhook替换掉 这时候我们就需要让系统的C方法不被hook，我们可以在别人hook之前换成我们自己的实现，然后别人再hook的时候就只是hook我们替换过的实现了，如何确保我们的hook在别人之前调用呢 我们知道，dyld加载App的时候，动态库是先加载的，而动态库的加载顺序是根据MachO文件描述的顺序（XCode中编译的顺序一样，也就是Frameworks,Libraries,and Embedded Content配置的顺序），我们可以用一个防护的动态库让我们的动态库先执行 当然如果MachO文件的动态链接库的顺序被改变了，还是会被别人先hook，这个成本就比较高了","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"},{"name":"逆向","slug":"逆向","permalink":"http://zhengbomo.github.io/tags/%E9%80%86%E5%90%91/"},{"name":"lldb","slug":"lldb","permalink":"http://zhengbomo.github.io/tags/lldb/"}]},{"title":"lldb常用命令","slug":"ios-lldb","date":"2019-08-06T08:40:58.000Z","updated":"2020-05-31T08:40:58.000Z","comments":true,"path":"2019-08-06/ios-lldb/","link":"","permalink":"http://zhengbomo.github.io/2019-08-06/ios-lldb/","excerpt":"lldb是llvm的一个子项目，用于调试llvm编译的程序，做iOS调试时，和lldb打交道应该是最多的，本文对lldb常用的一些命令做一些整理，以便后续查阅","text":"lldb是llvm的一个子项目，用于调试llvm编译的程序，做iOS调试时，和lldb打交道应该是最多的，本文对lldb常用的一些命令做一些整理，以便后续查阅 lldb常用操作lldb的指令格式 1&lt;command&gt; [&lt;subcommand&gt; [&lt;subcommand&gt;...]] &lt;action&gt; [-options [option\u0002value]] [argument [argument...]] 命令 子命令 命令操作 命令选项 命令参数 例如给函数test设置短点 1(lldb) breakpoint set -n test 我们常用的命令有 expression：表达式 thread：线程 frame： breakpoint：符号断点 watchpoint：内存断点 image：镜像 register：寄存器 memory：内存 help：查看命令帮助 所有命令可以通过help &lt;command&gt; [&lt;subcommand&gt;]查看详细文档 12345678910111213141516171819202122232425262728293031(lldb) help breakpoint Commands for operating on breakpoints (see &#x27;help b&#x27; for shorthand.)Syntax: breakpoint &lt;subcommand&gt; [&lt;command-options&gt;]The following subcommands are supported: clear -- Delete or disable breakpoints matching the specified source file and line. command -- Commands for adding, removing and listing LLDB commands executed when a breakpoint is hit. delete -- Delete the specified breakpoint(s). If no breakpoints are specified, delete them all. disable -- Disable the specified breakpoint(s) without deleting them. If none are specified, disable all breakpoints. enable -- Enable the specified disabled breakpoint(s). If no breakpoints are specified, enable all of them. list -- List some or all breakpoints at configurable levels of detail. modify -- Modify the options on a breakpoint or set of breakpoints in the executable. If no breakpoint is specified, acts on the last created breakpoint. With the exception of -e, -d and -i, passing an empty argument clears the modification. name -- Commands to manage name tags for breakpoints read -- Read and set the breakpoints previously saved to a file with &quot;breakpoint write&quot;. set -- Sets a breakpoint or set of breakpoints in the executable. write -- Write the breakpoints listed to a file that can be read in with &quot;breakpoint read&quot;. If given no arguments, writes all breakpoints.For more help on any particular subcommand, type &#x27;help &lt;command&gt; &lt;subcommand&gt;&#x27;.(lldb) help breakpoint set Sets a breakpoint or set of breakpoints in the executable.Syntax: breakpoint set &lt;cmd-options&gt;... expressionexpression命令是执行一个表达式，并将表达式返回的结果输出 调用方法expression 123(lldb) expression self.view.hidden = 1(lldb) expression [self.view layoutIfNeeded] 添加一个本地变量expression 1234# 命名以$开头(lldb) expression int $a = 10(lldb) p $a(int) $a = 1 我们可以通过添加本地变量实现页面跳转 12345678# 定义变量并赋值(lldb) expression id $navVC = self.navigationController;# 定义变量(lldb) expression id $vc# 创建vc(lldb) expression $vc = [[ViewController alloc] init];# push跳转(lldb) expression [$navVC pushViewController:$vc animated:YES] 打印变量地址expression --, p 123456789(lldb) expression button(UIButton *) $4 = 0x00007f9d1ea05b50# `--`表示选项结束(lldb) expression -- button(UIButton *) $5 = 0x00007f9d1ea05b50(lldb) p button(UIButton *) $6 = 0x00007f9d1ea05b50 expression --可以简写成expression，print，p 打印变量值expression -o --,po 123456# `--` 表示选项结束，`-o`表示按对象输出(lldb) expression -o -- button&lt;UIButton: 0x7f9d1ea05b50; frame = (184 433; 46 30); opaque = NO; autoresize = RM+BM; layer = &lt;CALayer: 0x600003a54ba0&gt;&gt;(lldb) po button&lt;UIButton: 0x7f9d1ea05b50; frame = (184 433; 46 30); opaque = NO; autoresize = RM+BM; layer = &lt;CALayer: 0x600003a54ba0&gt;&gt; expression -o --可以简写成po，实际是调用对象的description方法，输出返回值 thread 打印调用堆栈信息thread backtrace, bt 12345678910111213141516171819202122232425262728293031323334(lldb) bt* thread #1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = step over * frame #0: 0x00000001087d1bbf Test`-[ViewController viewDidLoad](self=0x00007fba7cc0ce10, _cmd=&quot;viewDidLoad&quot;) at ViewController.m:101:1 frame #1: 0x00007fff4856c066 UIKitCore`-[UIViewController _sendViewDidLoadWithAppearanceProxyObjectTaggingEnabled] + 83 frame #2: 0x00007fff48570f84 UIKitCore`-[UIViewController loadViewIfRequired] + 1084 frame #3: 0x00007fff485713a1 UIKitCore`-[UIViewController view] + 27 frame #4: 0x00007fff48c51ae1 UIKitCore`-[UIWindow addRootViewControllerViewIfPossible] + 326 frame #5: 0x00007fff48c5110a UIKitCore`-[UIWindow _updateLayerOrderingAndSetLayerHidden:actionBlock:] + 219 frame #6: 0x00007fff48c52195 UIKitCore`-[UIWindow _setHidden:forced:] + 362 frame #7: 0x00007fff48c655bc UIKitCore`-[UIWindow _mainQueue_makeKeyAndVisible] + 42 frame #8: 0x00007fff48e84d2c UIKitCore`-[UIWindowScene _makeKeyAndVisibleIfNeeded] + 202 frame #9: 0x00007fff48177720 UIKitCore`+[UIScene _sceneForFBSScene:create:withSession:connectionOptions:] + 1405 frame #10: 0x00007fff48c15561 UIKitCore`-[UIApplication _connectUISceneFromFBSScene:transitionContext:] + 1019 frame #11: 0x00007fff48c15898 UIKitCore`-[UIApplication workspace:didCreateScene:withTransitionContext:completion:] + 291 frame #12: 0x00007fff4876a160 UIKitCore`-[UIApplicationSceneClientAgent scene:didInitializeWithEvent:completion:] + 361 frame #13: 0x00007fff36c6091e FrontBoardServices`-[FBSSceneImpl _callOutQueue_agent_didCreateWithTransitionContext:completion:] + 419 frame #14: 0x00007fff36c869b1 FrontBoardServices`__86-[FBSWorkspaceScenesClient sceneID:createWithParameters:transitionContext:completion:]_block_invoke.154 + 102 frame #15: 0x00007fff36c6b347 FrontBoardServices`-[FBSWorkspace _calloutQueue_executeCalloutFromSource:withBlock:] + 220 frame #16: 0x00007fff36c86642 FrontBoardServices`__86-[FBSWorkspaceScenesClient sceneID:createWithParameters:transitionContext:completion:]_block_invoke + 355 frame #17: 0x0000000108a81e8e libdispatch.dylib`_dispatch_client_callout + 8 frame #18: 0x0000000108a84da2 libdispatch.dylib`_dispatch_block_invoke_direct + 300 frame #19: 0x00007fff36cac2d9 FrontBoardServices`__FBSSERIALQUEUE_IS_CALLING_OUT_TO_A_BLOCK__ + 30 frame #20: 0x00007fff36cabfc7 FrontBoardServices`-[FBSSerialQueue _queue_performNextIfPossible] + 441 frame #21: 0x00007fff36cac4d6 FrontBoardServices`-[FBSSerialQueue _performNextFromRunLoopSource] + 22 frame #22: 0x00007fff23da1c71 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 17 frame #23: 0x00007fff23da1b9c CoreFoundation`__CFRunLoopDoSource0 + 76 frame #24: 0x00007fff23da13cc CoreFoundation`__CFRunLoopDoSources0 + 268 frame #25: 0x00007fff23d9bf6e CoreFoundation`__CFRunLoopRun + 974 frame #26: 0x00007fff23d9b884 CoreFoundation`CFRunLoopRunSpecific + 404 frame #27: 0x00007fff38b5ac1a GraphicsServices`GSEventRunModal + 139 frame #28: 0x00007fff48c19220 UIKitCore`UIApplicationMain + 1605 frame #29: 0x00000001087d2072 Test`main(argc=1, argv=0x00007ffee742dd98) at main.m:18:12 frame #30: 0x00007fff519b910d libdyld.dylib`start + 1 frame #31: 0x00007fff519b910d libdyld.dylib`start + 1 frame variable [value] 打印当前调用栈的变量 123456789- (int)a:(NSSet *)a b:(NSString *)b c:(long)c d:(int)d e:(int)e &#123; NSString *f = @&quot;v&quot;; NSUInteger g = f.length; g += 1; return 10;&#125;// 调用[self a:nil b:@&quot;fdd&quot; c:1231 d:2123 e:23]; 在函数里面查看 12345678910(lldb) frame variable(ViewController *) self = 0x00007ffe4f4090b0(SEL) _cmd = &quot;a:b:c:d:e:&quot;(NSSet *) a = nil(__NSCFConstantString *) b = 0x0000000101b41088 @&quot;fdd&quot;(long) c = 1231(int) d = 2123(int) e = 23(__NSCFConstantString *) f = 0x0000000101b410a8 @&quot;v&quot;(NSUInteger) g = 2 流程控制 thread continue̵&#x2F;continue̵&#x2F;c: 程序继续运行 thread step-over&#x2F;next&#x2F;n：单步运行（源码），不会进入子函数 thread step-in&#x2F;step&#x2F;s: 单步运行（源码），会进入子函数 thread step-out&#x2F;finish: 直接执行完当前函数的所有代码，返回到调用的地方 thread return [value]&#x2F;thread r：让当前函数直接返回，不执行当前断点后面代码 thread step-inst-over&#x2F;nexti&#x2F;ni：单步运行（汇编），不会进入子函数 thread step-inst&#x2F;stepi&#x2F;si：单步运行（汇编），会进入子函数 前面四个对应Xcode工具栏的前四个 调用栈回退和前进 up&#x2F;down breakpoint 设置断点breakpoint set breakpoint set -a 函数地址 breakpoint set -n 函数符号 123456(lldb) breakpoint set -a 0x0000000101b3eab3Breakpoint 6: where = Test`-[ViewController viewDidLoad] + 147 at ViewController.m:101:5, address = 0x0000000101b3eab3(lldb) breakpoint set -n &quot;-[ViewController viewDidLoad]&quot;(lldb) breakpoint set -n touchesBegan:withEvent: 列出所有的断点：breakpoint list 12345678910111213(lldb) breakpoint listCurrent breakpoints:1: file = &#x27;/Users/bomo/Desktop/Test/Test/ViewController.m&#x27;, line = 116, exact_match = 0, locations = 1, resolved = 1, hit count = 01.1: where = Test`-[ViewController test:] + 60 at ViewController.m:116:21, address = 0x0000000101b3ebec, resolved, hit count = 02: file = &#x27;/Users/bomo/Desktop/Test/Test/ViewController.m&#x27;, line = 114, exact_match = 0, locations = 1, resolved = 1, hit count = 02.1: where = Test`-[ViewController test:] + 36 at ViewController.m:114:21, address = 0x0000000101b3ebd4, resolved, hit count = 03: file = &#x27;/Users/bomo/Desktop/Test/Test/ViewController.m&#x27;, line = 109, exact_match = 0, locations = 1, resolved = 1, hit count = 13.1: where = Test`-[ViewController a:b:c:d:e:] + 162 at ViewController.m:110:1, address = 0x0000000101b3eb72, resolved, hit count = 14: address = 0x00000001007f1cac, locations = 14.1: address = 0x00000001007f1cac, unresolved, hit count = 0 上面有4个断点，每个断点都有一个整数编号 设置断点状态 breakpoint disable 断点编号: 禁用断点 breakpoint enable 断点编号: 启用断点 breakpoint delete 断点编号: 删除断点 断点命令： breakpoint command add 断点编号: 给断点预先设置需要执行的命令，当触发断点时候，就会执行 breakpoint command list 断点编号: 列出断点的绑定的命令 breakpoint command delete 断点编号: 删除断点绑定的命令 123456(lldb) breakpoint command add 1Enter your debugger command(s). Type &#x27;DONE&#x27; to end.&gt; print &quot;断点命中了&quot;&gt; print &quot;断点参数为&quot;&gt; po sender&gt; DONE 当断点命中的时候时候 123456789101112131415161718192021print &quot;断点命中了&quot;(const char [16]) $0 = &quot;断点命中了&quot;print &quot;断点参数为&quot;(const char [16]) $1 = &quot;断点参数为&quot;po sender&lt;UIButton: 0x7fa86f80bf10; frame = (184 433; 46 30); opaque = NO; autoresize = RM+BM; layer = &lt;CALayer: 0x600001826580&gt;&gt;# 查看断点的命令(lldb) breakpoint command list 11: file = &#x27;/Users/bomo/Desktop/Test/Test/ViewController.m&#x27;, line = 105, exact_match = 0, locations = 1, resolved = 1, hit count = 4 Breakpoint commands: print &quot;断点命中了&quot; print &quot;断点参数为&quot; po sender1.1: where = Test`-[ViewController test:] + 36 at ViewController.m:105:20, address = 0x000000010375ed24, resolved, hit count = 4# 删除断点的命令(lldb) breakpoint command delete 1 内存断点内存断点与符号断点用法类似 watchpoint set variable 变量 1(lldb) watchpoint set variable self-&gt;age watchpoint set expression 地址 1(lldb) watchpoint set expression 0x0000000101b3eab3 watchpoint list watchpoint diable 断点编号 watchpoint enable 断点编号 watchpoint delete 断点编号 watchpoint command add 断点编号 watchpoint command list 断点编号 watchpoint command delete 断点编号 image 列出所加载的模块信息image list -o -f 1234567(lldb) image list -o -f[ 0] 0x000000000375d000 /Users/bomo/Library/Developer/Xcode/DerivedData/Test-frsrzegtqyfuthfhcjefdlbaqmgi/Build/Products/Debug-iphonesimulator/Test.app/Test[ 1] 0x0000000108ca5000 /usr/lib/dyld[ 2] 0x000000010376c000 /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Library/Developer/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/usr/lib/dyld_sim[ 3] 0x00000001039c7000 /Users/bomo/Library/Developer/Xcode/DerivedData/Test-frsrzegtqyfuthfhcjefdlbaqmgi/Build/Products/Debug-iphonesimulator/Test.app/Frameworks/AppOrderFiles.framework/AppOrderFiles[ 4] 0x00007fff2587b000 /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Library/Developer/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/Frameworks/Foundation.framework/Foundation... 可以使用grep过滤 12345(lldb) image list -o -f Test[ 0] /Users/bomo/Library/Developer/Xcode/DerivedData/Test-frsrzegtqyfuthfhcjefdlbaqmgi/Build/Products/Debug-iphoneos/Test.app/Test 0x0000000004a2c000(lldb) image list -o -f | grep Test[ 0] /Users/bomo/Library/Developer/Xcode/DerivedData/Test-frsrzegtqyfuthfhcjefdlbaqmgi/Build/Products/Debug-iphoneos/Test.app/Test 0x0000000004a2c000 可以使用image list命令查看ASLR偏移地址，上面表示Test文件的偏移地址为0x0000000004a2c000，MachO的TEXT段的偏移地址为0x0000000104a2c000（ASLR+PAGEZERO） 查找模块image lookup image lookup -t 类型 image lookup -a 地址 image lookup -n 符号 12345678910111213(lldb) image lookup -t AppDelegateBest match found in /Users/bomo/Library/Developer/Xcode/DerivedData/Test-frsrzegtqyfuthfhcjefdlbaqmgi/Build/Products/Debug-iphonesimulator/Test.app/Test:id = &#123;0x20000002b&#125;, name = &quot;AppDelegate&quot;, byte-size = 8, decl = AppDelegate.h:11, compiler_type = &quot;@interface AppDelegate : UIResponder@end&quot;(lldb) image lookup -n test:1 match found in /Users/bomo/Library/Developer/Xcode/DerivedData/Test-frsrzegtqyfuthfhcjefdlbaqmgi/Build/Products/Debug-iphonesimulator/Test.app/Test: Address: Test[0x0000000100001d00] (Test.__TEXT.__text + 688) Summary: Test`-[ViewController test:] at ViewController.m:103(lldb) image lookup -a 0x000000010375ed24 Address: Test[0x0000000100001d24] (Test.__TEXT.__text + 724) Summary: Test`-[ViewController test:] + 36 at ViewController.m:105:20 其中image lookup -a 地址经常用于查询崩溃位置，通过地址查询崩溃的地方位于哪个模块哪个文件哪个位置 registerregister指令能够获取和修改各个寄存器的信息 读取所有寄存器信息 123456789101112131415161718192021222324252627282930313233343536(lldb) register readGeneral Purpose Registers: x0 = 0x0000000000000000 x1 = 0x00000001bcf641e4 x2 = 0x000000010536d050 x3 = 0x000000028283b840 x4 = 0x000000028283b840 x5 = 0x000000028283b840 x6 = 0x0000000000000000 x7 = 0x0000000000000403 x8 = 0x0000000104dd1568 (void *)0x0000000104dd15b8: ABC x9 = 0x0000000000000006 x10 = 0x0000000000000008 x11 = 0x0000000000000000 x12 = 0x000000010a811840 x13 = 0x000005a1ce8843c7 (0x00000001ce8843c7) (void *)0x000001ce88448800 x14 = 0x00000001bd054dde x15 = 0x0000000104dd0220 (void *)0x00000001bd054dde x16 = 0x00000001818daa90 libobjc.A.dylib`objc_release x17 = 0x0000000186100418 UIKitCore`-[UIView(UIKitManual) retain] x18 = 0x0000000000000000 x19 = 0x000000028283b840 x20 = 0x000000010536d050 x21 = 0x00000001be56b4fe x22 = 0x0000000106c04bd0 x23 = 0x0000000000000001 x24 = 0x00000001ce893fe8 UIKitCore`UIApp x25 = 0x0000000000000000 x26 = 0x00000001bcf656b4 x27 = 0x0000000106c04bd0 x28 = 0x00000002813adfe0 fp = 0x000000016b039390 lr = 0x0000000104dc9d1c Test`-[ViewController test:] + 40 at ViewController.m:104 sp = 0x000000016b039340 pc = 0x0000000104dc9d24 Test`-[ViewController test:] + 48 at ViewController.m:106:20 cpsr = 0x00000000 register read/格式 寄存器名称 12# 读取寄存器x0的值registe read $x0 register write 寄存器名称 数值 1registe write $x1 10 查看内存memory read&#x2F;数量+格式+字节数 内存地址 格式：x为16进制，f位浮点数，d为10进制字节数：b为1个字节，h为2个字节，w为4个字节，g为8个字节 123456789101112131415161718192021222324252627(lldb) memory read 0x00006000001600b00x6000001600b0: 00 ed c1 89 ff 7f 00 00 00 00 00 00 00 00 00 00 ................0x6000001600c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................(lldb) memory read/3xg 0x00006000001600b00x6000001600b0: 0x00007fff89c1ed00 0x00000000000000000x6000001600c0: 0x0000000000000000(lldb) memory read/8xg 0x00006000001600b00x6000001600b0: 0x00007fff89c1ed00 0x00000000000000000x6000001600c0: 0x0000000000000000 0x00000000000000000x6000001600d0: 0x0000000000000000 0x00000000000000000x6000001600e0: 0x0000000000000000 0x0000000000000000(lldb) memory read/8xw 0x00006000001600b00x6000001600b0: 0x89c1ed00 0x00007fff 0x00000000 0x000000000x6000001600c0: 0x00000000 0x00000000 0x00000000 0x00000000(lldb) memory read/3dw 0x00006000001600b00x6000001600b0: -19837795840x6000001600b4: 327670x6000001600b8: 0(lldb) memory read/3fw 0x00006000001600b00x6000001600b0: -4.66859336E-330x6000001600b4: 4.59163468E-410x6000001600bc: 0 也可以直接使用x查看内存，用法和memory read一样 123(lldb) x/4xg 0x00006000001600b00x6000001600b0: 0x00007fff89c1ed00 0x00000000000000000x6000001600c0: 0x0000000000000000 0x0000000000000000 写内存 1memory write 内存地址 述职 缩写lldb大部分命令都支持缩写 命令 缩写 expression exp thread backtrace bt breakpoint list br l process continue continue, c thread step-over next, n thread step-in step, s thread step-out finish, f thread step-inst-over nexti, ni thread step-inst stepi, si","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"},{"name":"lldb","slug":"lldb","permalink":"http://zhengbomo.github.io/tags/lldb/"}]},{"title":"【iOS逆向】iOS可执行文件权限签名","slug":"ios-entitlement","date":"2019-08-04T07:06:25.000Z","updated":"2023-06-11T03:02:51.865Z","comments":true,"path":"2019-08-04/ios-entitlement/","link":"","permalink":"http://zhengbomo.github.io/2019-08-04/ios-entitlement/","excerpt":"iOS中使用entitlement文件来描述可执行文件的权限，例如，当我们在Xcode中勾选了推送的权限，就会看到生成了一个entitlement文件，里面包含下面内容 12&lt;key&gt;aps-environment&lt;/key&gt;&lt;string&gt;development&lt;/string&gt; 如果勾选了Sign With Apple，会出现 1234&lt;key&gt;com.apple.developer.applesignin&lt;/key&gt;&lt;array&gt; &lt;string&gt;Default&lt;/string&gt;&lt;/array&gt; 只有配置了对应的权限声明，并签名到可执行文件中，程序才有权限执行对应的功能，例如如果我们没有加上Sign With Apple，则苹果登录相关的接口会失败","text":"iOS中使用entitlement文件来描述可执行文件的权限，例如，当我们在Xcode中勾选了推送的权限，就会看到生成了一个entitlement文件，里面包含下面内容 12&lt;key&gt;aps-environment&lt;/key&gt;&lt;string&gt;development&lt;/string&gt; 如果勾选了Sign With Apple，会出现 1234&lt;key&gt;com.apple.developer.applesignin&lt;/key&gt;&lt;array&gt; &lt;string&gt;Default&lt;/string&gt;&lt;/array&gt; 只有配置了对应的权限声明，并签名到可执行文件中，程序才有权限执行对应的功能，例如如果我们没有加上Sign With Apple，则苹果登录相关的接口会失败 EntitlementiOS中可执行文件会包含entitlement来声明可执行文件有用哪些权限，默认的iOS开发的应用程序的权限有限，例如只能访问沙盒数据，不能访问系统目录，不能访问其他App，而系统程序却可以，主要差别在于可执行文件签名的权限，系统程序拥有更高的权限，例如SpringBoard 签名在Mac上，我们可以通过ldid工具，对可执行文件的权限重新签名，也可以导出可执行文件的entitlement描述 0. 安装ldid1brew install ldid 1. 导出entitlement描述使用ldid，导出可执行文件SpringBoard的权限到SpringBoard.entitlements 1ldid -e SpringBoard &gt; SpringBoard.entitlements 2. 重新签名entitlement把权限SpringBoard.entitlements签名到可执行文件TestTool中 1ldid -SSpringBoard.entitlements TestTool 此时，TestTool就拥有跟SpringBoard一样的执行权限 3. 使用codesign签名除ldid外，也可以通过codesign进行签名，codesign就有一个entitlement参数 1codesign -d --entitlements TestTool.entitlements TestTool 实践1. 导出SpringBoard程序的权限SpringBoard应用位于/System/Library/CoreServices/SpringBoard.app，我们先把他拷贝出来 1scp root@xx.xx.xx.xx:/System/Library/CoreServices/SpringBoard.app/SpringBoard ~/Desktop/SpringBoard 通过上面的ldid命令导出得到entitlement，如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;allow-obliterate-device&lt;/key&gt; &lt;true/&gt; &lt;key&gt;application-identifier&lt;/key&gt; &lt;string&gt;com.apple.springboard&lt;/string&gt; &lt;key&gt;aps-connection-initiate&lt;/key&gt; &lt;true/&gt; &lt;key&gt;backupd-connection-initiate&lt;/key&gt; &lt;true/&gt; &lt;key&gt;checklessPersistentURLTranslation&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.BTServer.allowRestrictedServices&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.BTServer.programmaticPairing&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.CallHistory.sync.allow&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.CommCenter.fine-grained&lt;/key&gt; &lt;array&gt; &lt;string&gt;spi&lt;/string&gt; &lt;string&gt;preferences-reset&lt;/string&gt; &lt;string&gt;voice&lt;/string&gt; &lt;string&gt;identity&lt;/string&gt; &lt;string&gt;phone&lt;/string&gt; &lt;string&gt;carrier-settings&lt;/string&gt; &lt;/array&gt; &lt;key&gt;com.apple.CompanionLink&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.Contacts.database-allow&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.CoreRoutine.LocationOfInterest&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.MobileInternetSharing.allow&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.QuartzCore.cache-asynchronous&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.QuartzCore.displayable-context&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.QuartzCore.global-capture&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.QuartzCore.secure-capture&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.QuartzCore.secure-mode&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.SystemConfiguration.SCDynamicStore-write-access&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.SystemConfiguration.SCPreferences-write-access&lt;/key&gt; &lt;array&gt; &lt;string&gt;com.apple.AutoWake.xml&lt;/string&gt; &lt;string&gt;preferences.plist&lt;/string&gt; &lt;string&gt;com.apple.radios.plist&lt;/string&gt; &lt;/array&gt; &lt;key&gt;com.apple.accounts.appleaccount.fullaccess&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.assistant.client&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.authkit.writer.internal&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.avfoundation.allow-identifying-output-device-details&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.avfoundation.allow-still-image-capture-shutter-sound-manipulation&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.avfoundation.allow-system-wide-context&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.avfoundation.allows-access-to-device-list&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.avfoundation.allows-set-output-device&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.backboard.client&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.backboard.display.archive&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.backboard.displaybrightness&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.backboardd.cancelsTouchesInHostedContent&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.backboardd.hostCanRequireTouchesFromHostedContent&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.backboardd.lastUserEventTime&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.backboardd.launchapplications&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.backboardd.touchDeliveryObservation&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.backboardd.virtualDisplay&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.bluetooth.system&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.bulletinboard&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.bulletinboard.dataprovider&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.bulletinboard.observer&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.bulletinboard.serverconduit&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.bulletinboard.settings&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.bulletinboard.systemstate&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.bulletinboard.utilities&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.cards.all-access&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.coreaudio.CanRecordPastData&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.coreaudio.allow-amr-decode&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.coreaudio.allow-opus-codec&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.coreaudio.allow-speex-codec&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.coreduetd.allow&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.coreduetd.batterysaver.allow&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.coreduetd.context&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.coremedia.allow-pre-wiring-pixel-buffers&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.coremedia.allow-protected-content-playback&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.coremedia.virtualdisplaysession&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.developer.extension-host.widget-extension&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.developer.homekit&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.developer.ubiquity-kvstore-identifier&lt;/key&gt; &lt;string&gt;com.apple.springboard&lt;/string&gt; &lt;key&gt;com.apple.duet.activityscheduler.allow&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.duet.expertcenter.consumer&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.fileprovider.enumerate&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.fileprovider.fetch-url&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.frontboard.app-badge-value-access&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.frontboard.launchapplications&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.frontboard.shutdown&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.frontboardservices.display-layout-monitor&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.geoservices.navigation_info&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.homekit.private-spi-access&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.iapd.accessibility&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.icloud.findmydeviced.access&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.icloud.fmfd.access&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.idle-timer-services&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.imagent&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.imagent.av&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.imagent.chat&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.intents.extension.discovery&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.intents.uiextension.discovery&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.itunesstored.private&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.keystore.device&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.keystore.lockassertion&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.keystore.stash.access&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.launchservices.clearadvertisingid&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.locationd.activity&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.locationd.authorizeapplications&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.locationd.effective_bundle&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.locationd.place_inference&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.locationd.prompt_behavior&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.locationd.region_proxy_service&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.locationd.status&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.locationd.usage_oracle&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.locationd.vehicle_data&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.logind.client.entitlement&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.lsapplicationproxy.deviceidentifierforvendor&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.managedconfiguration.mdmd-access&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.managedconfiguration.profiled-access&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.mediastream.mstreamd-access&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.messages.composeclient&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.mkb.usersession.info&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.mkb.usersession.loginwindow&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.mobile.deleted.AllowFreeSpace&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.mobile.keybagd.UserManager.logoutcritical&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.mobilemail.mailservices&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.multitasking.systemappassertions&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.multitasking.termination&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.nfcd.hwmanager&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.nfcd.seshat&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.notificationcenter.widgetcontrollerhascontent&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.osanalytics.otatasking-service-access&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.payment.configuration&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.payment.presentation&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.CallHistory.read&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.CoreAuthentication.SPI&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.InstallCoordination.allowed&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.MobileContainerManager.otherIdLookup&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.MobileGestalt.AllowedProtectedKeys&lt;/key&gt; &lt;array&gt; &lt;string&gt;InverseDeviceID&lt;/string&gt; &lt;/array&gt; &lt;key&gt;com.apple.private.SafariServices.PasswordPicker.setRemoteAppProperties&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.StarBoard.session&lt;/key&gt; &lt;string&gt;YES&lt;/string&gt; &lt;key&gt;com.apple.private.WebClips.read-write&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.accounts.allaccounts&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.airdrop.settings&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.appleaccount.app-hidden-from-icloud-settings&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.applecredentialmanager.allow&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.appstored&lt;/key&gt; &lt;array&gt; &lt;string&gt;Repair&lt;/string&gt; &lt;string&gt;TestFlightFeedback&lt;/string&gt; &lt;/array&gt; &lt;key&gt;com.apple.private.attentionawareness&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.attentionawareness.poll&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.bmk.allow&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.calendar.allow-suggestions&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.canGetAppLinkInfo&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.canModifyAppLinkPermissions&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.carkit&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.carkit.app&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.carkit.dnd&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.clouddocs.can-grant-access-to-document&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.contactsui&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.corerecents&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.coreservices.canopenactivity&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.coreservices.lsuseractivityd.bestappsuggestion&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.corespotlight.internal&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.corespotlight.search.internal&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.dmd.policy&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.donotdisturb.behavior.resolution.client-identifiers&lt;/key&gt; &lt;array&gt; &lt;string&gt;com.apple.springboard.SBNCSoundController&lt;/string&gt; &lt;string&gt;com.apple.springboard.SBNCScreenController&lt;/string&gt; &lt;string&gt;com.apple.springboard.SBNotificationBannerDestination&lt;/string&gt; &lt;string&gt;com.apple.springboard.SBNotificationLegacyCarDestination&lt;/string&gt; &lt;string&gt;com.apple.springboard.SBDashBoardCombinedListViewController&lt;/string&gt; &lt;string&gt;com.apple.springboard.SBBulletinSpokenObserverGateway&lt;/string&gt; &lt;/array&gt; &lt;key&gt;com.apple.private.donotdisturb.mode.assertion.client-identifiers&lt;/key&gt; &lt;array&gt; &lt;string&gt;com.apple.donotdisturb.control-center.module&lt;/string&gt; &lt;string&gt;com.apple.springboard.donotdisturb.notifications&lt;/string&gt; &lt;/array&gt; &lt;key&gt;com.apple.private.donotdisturb.mode.assertion.user-requested.client-identifiers&lt;/key&gt; &lt;array&gt; &lt;string&gt;com.apple.donotdisturb.control-center.module&lt;/string&gt; &lt;string&gt;com.apple.springboard.donotdisturb.notifications&lt;/string&gt; &lt;/array&gt; &lt;key&gt;com.apple.private.donotdisturb.settings.request.client-identifiers&lt;/key&gt; &lt;array&gt; &lt;string&gt;com.apple.springboard.donotdisturb.notifications&lt;/string&gt; &lt;/array&gt; &lt;key&gt;com.apple.private.donotdisturb.settings.updates.client-identifiers&lt;/key&gt; &lt;array&gt; &lt;string&gt;com.apple.springboard.donotdisturb.notifications&lt;/string&gt; &lt;/array&gt; &lt;key&gt;com.apple.private.donotdisturb.state.request.client-identifiers&lt;/key&gt; &lt;array&gt; &lt;string&gt;com.apple.springboard.SBStatusBarStateAggregator&lt;/string&gt; &lt;string&gt;com.apple.springboard.SBDashBoardCombinedListViewController&lt;/string&gt; &lt;string&gt;com.apple.donotdisturb.control-center.module&lt;/string&gt; &lt;string&gt;com.apple.springboard.donotdisturb.notifications&lt;/string&gt; &lt;string&gt;com.apple.springboard.donotdisturb.awdmetrics&lt;/string&gt; &lt;string&gt;com.apple.springboard.dashboard.bedtime&lt;/string&gt; &lt;string&gt;com.apple.accessibility.visual.alerts&lt;/string&gt; &lt;/array&gt; &lt;key&gt;com.apple.private.donotdisturb.state.updates.client-identifiers&lt;/key&gt; &lt;array&gt; &lt;string&gt;com.apple.springboard.SBStatusBarStateAggregator&lt;/string&gt; &lt;string&gt;com.apple.springboard.SBDashBoardCombinedListViewController&lt;/string&gt; &lt;string&gt;com.apple.donotdisturb.control-center.module&lt;/string&gt; &lt;string&gt;com.apple.springboard.donotdisturb.notifications&lt;/string&gt; &lt;string&gt;com.apple.springboard.donotdisturb.awdmetrics&lt;/string&gt; &lt;string&gt;com.apple.springboard.dashboard.bedtime&lt;/string&gt; &lt;string&gt;com.apple.accessibility.visual.alerts&lt;/string&gt; &lt;/array&gt; &lt;key&gt;com.apple.private.externalaccessory.showallaccessories&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.game-center&lt;/key&gt; &lt;array&gt; &lt;string&gt;Account&lt;/string&gt; &lt;string&gt;Games&lt;/string&gt; &lt;/array&gt; &lt;key&gt;com.apple.private.game-center.bypass-authentication&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.healthkit&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.healthkit.read_authorization_override&lt;/key&gt; &lt;array&gt; &lt;string&gt;HKCategoryTypeIdentifierSleepAnalysis&lt;/string&gt; &lt;/array&gt; &lt;key&gt;com.apple.private.healthkit.source_override&lt;/key&gt; &lt;string&gt;com.apple.mobiletimer&lt;/string&gt; &lt;key&gt;com.apple.private.healthkit.write_authorization_override&lt;/key&gt; &lt;array&gt; &lt;string&gt;HKCategoryTypeIdentifierSleepAnalysis&lt;/string&gt; &lt;/array&gt; &lt;key&gt;com.apple.private.hid.client.event-dispatch&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.hid.client.service-protected&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.hid.manager.client&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.homekit&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.icfcallserver&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.ids.idsquery&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.ids.messaging&lt;/key&gt; &lt;array&gt; &lt;string&gt;com.apple.private.alloy.bulletinboard&lt;/string&gt; &lt;string&gt;com.apple.private.alloy.donotdisturb&lt;/string&gt; &lt;string&gt;com.apple.madrid&lt;/string&gt; &lt;string&gt;com.apple.private.alloy.siri.phrasespotter&lt;/string&gt; &lt;/array&gt; &lt;key&gt;com.apple.private.ids.messaging.urgent-priority&lt;/key&gt; &lt;array&gt; &lt;string&gt;com.apple.private.alloy.bulletinboard&lt;/string&gt; &lt;string&gt;com.apple.private.alloy.donotdisturb&lt;/string&gt; &lt;string&gt;com.apple.private.alloy.siri.phrasespotter&lt;/string&gt; &lt;/array&gt; &lt;key&gt;com.apple.private.ids.registration-reset&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.imavcore.imavagent&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.imcore.imdpersistence.database-access&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.imcore.imremoteurlconnection&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.imcore.spi.database-access&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.in-app-payments&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.iokit.powersource-control&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.kernel.darkboot&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.kernel.jetsam&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.librarian.can-get-application-info&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.lockdown.finegrained-get&lt;/key&gt; &lt;array&gt; &lt;string&gt;NULL/ActivationState&lt;/string&gt; &lt;string&gt;NULL/BrickState&lt;/string&gt; &lt;string&gt;NULL/SBLockdownEverRegisteredKey&lt;/string&gt; &lt;string&gt;com.apple.xcode.developerdomain/DeveloperStatus&lt;/string&gt; &lt;string&gt;NULL/BuildExpireTime&lt;/string&gt; &lt;/array&gt; &lt;key&gt;com.apple.private.lockdown.finegrained-remove&lt;/key&gt; &lt;array&gt; &lt;string&gt;com.apple.mobile.iTunes.store/AppleID&lt;/string&gt; &lt;string&gt;com.apple.mobile.data_sync/Contacts&lt;/string&gt; &lt;string&gt;com.apple.mobile.data_sync/Calendars&lt;/string&gt; &lt;string&gt;com.apple.mobile.data_sync/Bookmarks&lt;/string&gt; &lt;string&gt;com.apple.mobile.data_sync/Mail Accounts&lt;/string&gt; &lt;/array&gt; &lt;key&gt;com.apple.private.mis.online_auth_agent&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.mobileinstall.allowedSPI&lt;/key&gt; &lt;array&gt; &lt;string&gt;UninstallForLaunchServices&lt;/string&gt; &lt;string&gt;SetCapabilities&lt;/string&gt; &lt;string&gt;Lookup&lt;/string&gt; &lt;/array&gt; &lt;key&gt;com.apple.private.mobilesafari.searchengine&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.mobilestoredemo.enabledemo&lt;/key&gt; &lt;array&gt; &lt;string&gt;Manage&lt;/string&gt; &lt;/array&gt; &lt;key&gt;com.apple.private.mobiletimerd&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.network.socket-delegate&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.networkextension.configuration&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.persona.read&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.photos.service.demo&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.replay-kit&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.screen-time&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.security.container-manager&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.security.storage.Photos&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.suggestions.contacts&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.suggestions.events&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.system-keychain&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.tcc.allow&lt;/key&gt; &lt;array&gt; &lt;string&gt;kTCCServiceAddressBook&lt;/string&gt; &lt;string&gt;kTCCServiceCalendar&lt;/string&gt; &lt;string&gt;kTCCServiceReminders&lt;/string&gt; &lt;string&gt;kTCCServicePhotos&lt;/string&gt; &lt;string&gt;kTCCServicePhotosAdd&lt;/string&gt; &lt;string&gt;kTCCServiceMediaLibrary&lt;/string&gt; &lt;string&gt;kTCCServiceMicrophone&lt;/string&gt; &lt;string&gt;kTCCServiceCamera&lt;/string&gt; &lt;string&gt;kTCCServiceWillow&lt;/string&gt; &lt;string&gt;kTCCServiceFaceID&lt;/string&gt; &lt;/array&gt; &lt;key&gt;com.apple.private.tcc.manager&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.tty.settings&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.ubiquity-kvstore-access&lt;/key&gt; &lt;array&gt; &lt;string&gt;com.apple.weather&lt;/string&gt; &lt;string&gt;com.apple.stocks&lt;/string&gt; &lt;string&gt;com.apple.backboardd&lt;/string&gt; &lt;string&gt;com.apple.Accessibility&lt;/string&gt; &lt;string&gt;com.apple.Accessibility.SwitchControl&lt;/string&gt; &lt;string&gt;com.apple.Accessibility.TouchAccommodations&lt;/string&gt; &lt;string&gt;com.apple.AssistiveTouch&lt;/string&gt; &lt;string&gt;com.apple.HearingAids&lt;/string&gt; &lt;string&gt;com.apple.SpeakSelection&lt;/string&gt; &lt;string&gt;com.apple.VoiceOverTouch&lt;/string&gt; &lt;string&gt;com.apple.ZoomTouch&lt;/string&gt; &lt;/array&gt; &lt;key&gt;com.apple.private.usernotifications.bundle-identifiers&lt;/key&gt; &lt;array&gt; &lt;string&gt;com.apple.donotdisturb&lt;/string&gt; &lt;string&gt;com.apple.mobiletimer&lt;/string&gt; &lt;string&gt;com.apple.usernotifications.example&lt;/string&gt; &lt;/array&gt; &lt;key&gt;com.apple.private.vfs.open-by-id&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.xpc.launchd.app-server&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.proactive.ActionPrediction.predictions&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.proactive.AppPrediction.predictions&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.purplebuddy.budd.access&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.remotenotification.access&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.remotenotification.preferences&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.rootless.storage.proactivepredictions&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.runningboard.hereditarygrantoriginator&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.runningboard.primitiveattribute&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.runningboard.process-state&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.runningboard.request.identity&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.runningboard.terminatemanagedprocesses&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.runningboard.underlyingassertion&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.securebackupd.access&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.security.application-groups&lt;/key&gt; &lt;array&gt; &lt;string&gt;group.com.apple.weather&lt;/string&gt; &lt;string&gt;group.com.apple.stocks&lt;/string&gt; &lt;/array&gt; &lt;key&gt;com.apple.security.enterprise-volume-access&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.security.exception.mach-lookup.global-name&lt;/key&gt; &lt;array&gt; &lt;string&gt;com.apple.siri.activation.service&lt;/string&gt; &lt;string&gt;com.apple.springboard.SBRendererService&lt;/string&gt; &lt;string&gt;com.apple.appstored.xpc&lt;/string&gt; &lt;string&gt;com.apple.appstored.xpc.request&lt;/string&gt; &lt;/array&gt; &lt;key&gt;com.apple.security.system-container&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.security.system-groups&lt;/key&gt; &lt;array&gt; &lt;string&gt;systemgroup.com.apple.sharedpclogging&lt;/string&gt; &lt;string&gt;systemgroup.com.apple.regulatory_images&lt;/string&gt; &lt;/array&gt; &lt;key&gt;com.apple.sharing.Client&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.sharing.CoordinatedAlerts&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.sharing.Diagnostics&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.sharing.Session&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.siri.VoiceShortcuts.xpc&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.siri.activation.service&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.siri.client_lite&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.siri.external_request&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.sos.trigger&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.springboard-ui.client&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.springboard.activateRemoteAlert&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.springboard.activateawayviewplugins&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.springboard.allowallcallurls&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.springboard.application-removability.proxy&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.springboard.lockScreenContentAssertion&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.springboard.multiwindow.triggerShowAllWindows&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.springboard.opensensitiveurl&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.springboard.openurlswhenlocked&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.springboard.setbadgestring&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.springboard.shortcutitems.fullaccess&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.springboard.statusbarstyleoverrides&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.springboard.statusbarstyleoverrides.coordinator&lt;/key&gt; &lt;array&gt; &lt;string&gt;UIStatusBarStyleOverrideAutoAirPlayReady&lt;/string&gt; &lt;string&gt;UIStatusBarStyleOverrideAutoAirPlayPlaying&lt;/string&gt; &lt;/array&gt; &lt;key&gt;com.apple.symptom_analytics.query&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.symptom_analytics.refresh&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.symptoms.NetworkOfInterest&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.telephonyutilities.callservicesd&lt;/key&gt; &lt;array&gt; &lt;string&gt;access-calls&lt;/string&gt; &lt;string&gt;modify-calls&lt;/string&gt; &lt;string&gt;access-call-providers&lt;/string&gt; &lt;string&gt;access-moments&lt;/string&gt; &lt;/array&gt; &lt;key&gt;com.apple.timed&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.tzlink.allow&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.ui-services-discovery&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.videoconference.allow-conferencing&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.visualvoicemail.client&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.voiceservices.tts.customvoice&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.voicetrigger.voicetriggerservice&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.watchlist.private&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.wifi.manager-access&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.wipedevice&lt;/key&gt; &lt;true/&gt; &lt;key&gt;fairplay-client&lt;/key&gt; &lt;string&gt;1172857363&lt;/string&gt; &lt;key&gt;keychain-access-groups&lt;/key&gt; &lt;array&gt; &lt;string&gt;apple&lt;/string&gt; &lt;string&gt;com.apple.preferences&lt;/string&gt; &lt;/array&gt; &lt;key&gt;vm-pressure-level&lt;/key&gt; &lt;true/&gt;&lt;/dict&gt;&lt;/plist&gt; 可以看到，包含的权限非常多，苹果并没有给出这些权限的说明，通常我们直接用就行了，这里有一篇文章做一些整理iOS Entitlement分析 1. 导出默认iOS应用程序的权限文件新建一个iOS工程，开启推送和Sign With Apple，编译，得到xxx.app，拿到可执行文件xxx，使用ldid导出得到 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;aps-environment&lt;/key&gt; &lt;string&gt;development&lt;/string&gt; &lt;key&gt;com.apple.developer.applesignin&lt;/key&gt; &lt;array&gt; &lt;string&gt;Default&lt;/string&gt; &lt;/array&gt; &lt;key&gt;com.apple.developer.team-identifier&lt;/key&gt; &lt;string&gt;9PCJKE8K5A&lt;/string&gt; &lt;key&gt;get-task-allow&lt;/key&gt; &lt;true/&gt;&lt;/dict&gt;&lt;/plist&gt; 其中get-task-allow为允许其他进程（如调试器）附加到您的应用程序。我们自己编译的App可以进行调试，而商店下载的App没有该选项 相比之下，默认的App权限少得可怜，我们可以吧SpringBoard的权限SpringBoard.entitlement签名到我们的程序XXX中，这样就可以有更多的操作权限了，例如访问沙盒外的路径 1ldid -SSpringBoard.entitlement XXX 引用 官方AboutEntitlements iOS Entitlement分析","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"},{"name":"逆向","slug":"逆向","permalink":"http://zhengbomo.github.io/tags/%E9%80%86%E5%90%91/"}]},{"title":"【iOS逆向】iOS动态库共享缓存","slug":"ios-dyld-shared-cache","date":"2019-07-18T08:16:20.000Z","updated":"2019-07-18T08:16:20.000Z","comments":true,"path":"2019-07-18/ios-dyld-shared-cache/","link":"","permalink":"http://zhengbomo.github.io/2019-07-18/ios-dyld-shared-cache/","excerpt":"我们在开发的过程中，经常会用到系统自带的库，如 Foundation，UIKit 等，这些库存放在什么地方呢，我们可以用 MachOView查看编译好的文件的Load Command看到依赖的动态库的路径","text":"我们在开发的过程中，经常会用到系统自带的库，如 Foundation，UIKit 等，这些库存放在什么地方呢，我们可以用 MachOView查看编译好的文件的Load Command看到依赖的动态库的路径 这里可以看到，动态库的路径为/System/Library/Frameworks/AVFoundation.framework/AVFoundation，我们连接到手机查看发现，framework 文件夹存在，但是并没有可执行文件 动态库共享缓存从iOS 3.1开始，为了提高系统的性能，所有的系统库文件都被打包合并成一个大的缓存文件中，而原来的动态库文件则被去除了，系统直接去缓存文件中加载动态库，该共享缓存文件保存在/System/Library/Caches/com.apple.dyld/目录下 可以看到，该缓存库有1547MB，我们把共享库拷贝到本地 1scp root@xx.xx.xx.xx:/System/Library/Caches/com.apple.dyld/dyld_shared_cache_arm64 ~/Desktop/dyld_shared_cache_arm64 我们通过工具dsc_extractor把系统库从共享缓存库分离出来，该工具也在dyld项目里面，在该项目中找到/launch-cache/dsc_extractor.cpp文件，我们需要自己编译一下，修改文件，只保留下面代码，其他删除 123456789101112131415161718192021222324252627282930313233343536// #if 0#if 1// test program#include &lt;stdio.h&gt;#include &lt;stddef.h&gt;#include &lt;dlfcn.h&gt;typedef int (*extractor_proc)(const char* shared_cache_file_path, const char* extraction_root_path, void (^progress)(unsigned current, unsigned total));int main(int argc, const char* argv[])&#123; if ( argc != 3 ) &#123; fprintf(stderr, &quot;usage: dsc_extractor &lt;path-to-cache-file&gt; &lt;path-to-device-dir&gt;\\n&quot;); return 1; &#125; //void* handle = dlopen(&quot;/Volumes/my/src/dyld/build/Debug/dsc_extractor.bundle&quot;, RTLD_LAZY); void* handle = dlopen(&quot;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/usr/lib/dsc_extractor.bundle&quot;, RTLD_LAZY); if ( handle == NULL ) &#123; fprintf(stderr, &quot;dsc_extractor.bundle could not be loaded\\n&quot;); return 1; &#125; extractor_proc proc = (extractor_proc)dlsym(handle, &quot;dyld_shared_cache_extract_dylibs_progress&quot;); if ( proc == NULL ) &#123; fprintf(stderr, &quot;dsc_extractor.bundle did not have dyld_shared_cache_extract_dylibs_progress symbol\\n&quot;); return 1; &#125; int result = (*proc)(argv[1], argv[2], ^(unsigned c, unsigned total) &#123; printf(&quot;%d/%d\\n&quot;, c, total); &#125; ); fprintf(stderr, &quot;dyld_shared_cache_extract_dylibs_progress() =&gt; %d\\n&quot;, result); return 0;&#125;#endif 使用clang++编译该源文件 1clang++ -o dsc_extractor dsc_extractor.cpp 编译后得到dsc_extractor，创建文件夹dyld_shared_cache，存放分离出来的动态库 1./dsc_extractor dyld_shared_cache_arm64 dyld_shared_cache 在dyld_shared_cache/System/Library/Frameworks可以看到动态缓存库中的所有合并的系统库，找到UIKit.framework/UIKit，这个就是真实的UIKit，但是只有8kb 使用MachOView工具查看，可以看到，UIKit引用UIKitCore，核心代码在PrivateFrameworks/UIKitCore.framework/UIKitCore，有30MB 可以通过hopper分析系统库的代码 动态库的加载在Mac&#x2F;iOS中，使用/usr/lib/dyld加载动态库，[NSBundle loadBundle]内部也是使用dyld dyld加载过程可细分为九步： 设置运行环境：主要设置运行参数，环境变量，检查进程权限 在Product -&gt; Scheme -&gt; Edit Scheme -&gt; Argument可以配置dyld参数，如: DYLD_PRINT_ENV 加载共享缓存：也就是dyld_shared_cache_arm64 实例化主程序：读取mach-o文件，加载链接库，segment等信息 加载插入的动态库DYLD_INSERT_LIBRARIES 链接主程序 链接插入的动态库 执行弱符号绑定 执行初始化方法。 查找入口点并返回。 引用 dyld详解","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"},{"name":"逆向","slug":"逆向","permalink":"http://zhengbomo.github.io/tags/%E9%80%86%E5%90%91/"}]},{"title":"【iOS逆向】使用Cycript调试应用","slug":"ios-cycript","date":"2019-07-03T12:36:24.000Z","updated":"2019-07-03T12:36:24.000Z","comments":true,"path":"2019-07-03/ios-cycript/","link":"","permalink":"http://zhengbomo.github.io/2019-07-03/ios-cycript/","excerpt":"Cycript是由Cydia创始人Saurik推出的一款脚本语言，Cycript混合了OC、JavaScript语法的解释器，这意味着我们能够在一个命令中使用Oc或者JavaScript，甚至两者并用。它能够附加到正在运行的进程，能够查看和修改运行时的数据","text":"Cycript是由Cydia创始人Saurik推出的一款脚本语言，Cycript混合了OC、JavaScript语法的解释器，这意味着我们能够在一个命令中使用Oc或者JavaScript，甚至两者并用。它能够附加到正在运行的进程，能够查看和修改运行时的数据 基本使用 通过cydia安装，自带的源https://apt.bingner.com/就有cycript 打开 App ，通过 ssh 连接设备，然后进入Cycrypt调试模式 12345678# 调试进程（PID=323）cycript -p 323# 调试进程（进程名）cycript -p SpringBoardcycript -p neteasemusic# `Control+D`退出cycript模式 获取进程Id 需要先安装插件：adv-cmds（在自带源https://apt.bingner.com/可找到） 12345# 查看所有进程ps -A# 搜索进程ps -A | grep neteasemusic 常用语法 UIApp：[UIApplication sharedApplication] 定义变量：var 变量名 = 变量值 通过内存获得对象：#内存地址 查看对象的所有成员：*对象 获取所有已加载的OC类：ObjectiveC.classes 获取当前内存中所有UITableViewCell（包含子类）的实例：choose(UITableViewCell) 递归打印所有的子控件：[view recursiveDescription].toString() 查看 bundleId: [[NSBundle mainBundle] bundleIdentifier] 函数 12345678910function KenPrintIvars(objc)&#123; var x = &#123;&#125;; for(i in *objc)&#123; try &#123; x[i] = (*objc)[i]; &#125; catch(e) &#123; &#125; &#125; return x;&#125; 引用外部脚本这里使用mjcript作为外部脚本引入，下载得到mjcript.cy 把文件拷贝到手机上 1scp mjcript.cy root@xx.xx.xx.xx:/usr/lib/cycript0.9/mjcript.cy 把手机的文件拷贝到本地 1scp root@xx.xx.xx.xx:/usr/lib/cycript0.9/mjcript.cy ~/Desktop/mjcript.cy 加载脚本 123456789# 附加到进程cycript -p XXX# 加载cy# @import mjcript# 使用脚本cy# MJFrontVc()#&quot;&lt;ZTPersonCenterViewController: 0x10520ba00&gt;&quot; mjcript功能列表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 包名MJAppId;// bundle pathMJAppPath;// document pathMJDocPath;// caches pathMJCachesPath;// 加载系统动态库（/System/Library/Frameworks/xxx.framework，/System/Library/Private/Frameworks/xxx.framework）MJLoadFramework(&quot;BluetoothManager&quot;);// keyWindowMJKeyWin();// 根控制器MJRootVc();// 找到显示在最前面的控制器MJFrontVc();// 递归打印UIViewController view的层级结构MJVcSubviews(vc);// 递归打印最上层UIViewController view的层级结构MJFrontVcSubViews();// 获取按钮绑定的所有TouchUpInside事件的方法名MJBtnTouchUpEvent(btn);// CG函数MJPointMake(x, y);MJSizeMake(w, h);MJRectMake(x, y, w, h);// 递归打印controller的层级结构MJChildVcs(vc);// 递归打印view的层级结构MJSubviews(view);// 判断是否为字符串 &quot;str&quot; @&quot;str&quot;MJIsString(value);// 判断是否为数组 []、@[]MJIsArray(value);// 判断是否为数字 666 @666MJIsNumber(value);// 打印所有的子类MJSubclasses(className, reg);// 打印所有的对象方法MJInstanceMethods(className, reg);// 打印所有的对象方法名字MJInstanceMethodNames(className, reg);// 打印所有的类方法MJClassMethods(className, reg);// 打印所有的类方法名字MJClassMethodNames(className, reg);// 打印所有的成员变量MJIvars(obj, reg);// 打印所有的成员变量名字MJIvarNames(obj, reg); Cycript默认不支持中文，可以使用 unicode 字符表示中文\\**\\**\\**\\**技巧：使用python把中文转成unicode字符 1unicode(&quot;登录&quot;, &quot;UTF-8&quot;) 封装cycript脚本123456789(function(exports) &#123; exports.sum = function(a, b) &#123; return a + b; &#125;; exports.minus = function(a, b) &#123; return a - b; &#125;; exports.age = 10;&#125;)(exports); 导入(/usr/lib/cycript0.9/test.cy)，并引用 1234@import testtest.sum(1, 30) // 31test.minus(6, 2) // 4 通过目录引用/usr/lib/cycript0.9/com/mj/cycript.cy 1@import com.mj.mjcript 小结Cycript 可以直接附加到App 进行内存调试，可以查看和修改 UIViewController，UIView，可以动态修改和分析应用的业务逻辑，用起来非常方便 引用 Cycript 官网","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"},{"name":"逆向","slug":"逆向","permalink":"http://zhengbomo.github.io/tags/%E9%80%86%E5%90%91/"}]},{"title":"【iOS逆向】使用Reveal查看AppUI结构","slug":"ios-reveal","date":"2019-06-25T15:37:56.000Z","updated":"2019-06-25T15:37:56.000Z","comments":true,"path":"2019-06-25/ios-reveal/","link":"","permalink":"http://zhengbomo.github.io/2019-06-25/ios-reveal/","excerpt":"在开发中，我们可能需要参考其它app界面的实现方式来寻找开发思路，通过Reveal工具，我们可以很方便的查看App在内存中的视图结构，如下(AppStore)","text":"在开发中，我们可能需要参考其它app界面的实现方式来寻找开发思路，通过Reveal工具，我们可以很方便的查看App在内存中的视图结构，如下(AppStore) 准备 一台越狱的手机 Reveal，推荐使用v4以上的版本，支持USB链接，速度快 手机安装Reveal2Loader插件在Cydia搜索Reveal2Loader，该插件在BissBoss源，直接就能搜到，安装 安装完成后重启SpringBoard 拷贝Reveal服务文件到iPhone中打开mac上的Reveal，Help-&gt;Show Reveal Library in Finder-&gt;iOS Library 进入目录/Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries/RevealServer.framework，也可以直接打开这个目录 将RevealServer.framework库中的RevealServer拷贝到手机Library/RHRevealLoader/并重命名为libReveal.dylib 12345# 进入目录cd /Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries/RevealServer.framework# 如果手机上没有/Library/RHRevealLoader这个目录，需要先创建一下scp RevealServer root@xx.xx.xx.xx:/Library/RHRevealLoader/libReveal.dylib 将RevealServer.framework复制到手机的/System/Library中 12345# 进入目录cd /Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries# 远程拷贝目录scp -r RevealServer.framework root@xx.xx.xx.xx://System/Library/RevealServer.framework 重启手机1killall SpringBoard 这时候设置里面会出现Reveal选项 我们进入Enabled Applications打开AppStore 打开Mac上的Reveal，打开手机上的AppStore，可以看到Reveal识别到AppStore 进入查看视图 Reveal可以看到视图结构，内存地址，还能看到View对应的ViewController","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"},{"name":"逆向","slug":"逆向","permalink":"http://zhengbomo.github.io/tags/%E9%80%86%E5%90%91/"},{"name":"Reveal","slug":"Reveal","permalink":"http://zhengbomo.github.io/tags/Reveal/"}]},{"title":"【iOS逆向】使用Theos编写CydiaSubstrate插件","slug":"ios-theos","date":"2019-06-03T15:37:09.000Z","updated":"2019-06-03T15:37:09.000Z","comments":true,"path":"2019-06-03/ios-theos/","link":"","permalink":"http://zhengbomo.github.io/2019-06-03/ios-theos/","excerpt":"常用的逆向手段有 通过Reveal查看App的视图和ViewController 通过cycript动态调试正在运行的App 通过class-dump导出脱壳后的可执行文件的头文件 通过IDA或Hopper反编译脱壳后的可执行文件","text":"常用的逆向手段有 通过Reveal查看App的视图和ViewController 通过cycript动态调试正在运行的App 通过class-dump导出脱壳后的可执行文件的头文件 通过IDA或Hopper反编译脱壳后的可执行文件 通过逆向确定了实现逻辑，可以通过Theos的tweak编写hook插件 安装Theos1. 下载1sudo git clone --recursive https://github.com/theos/theos.git ~/theos 2. 添加环境变量编辑~/.bash_profile 12export THEOS=~/theosexport PATH=$THEOS/bin:$PATH 打开终端，这时候可以使用命令了nic.pl 123456789101112131415$ nic.plNIC 2.0 - New Instance Creator------------------------------ [1.] iphone/activator_event [2.] iphone/application_modern [3.] iphone/application_swift [4.] iphone/flipswitch_switch [5.] iphone/framework [6.] iphone/library [7.] iphone/preference_bundle_modern [8.] iphone/tool [9.] iphone/tool_swift [10.] iphone/tweak [11.] iphone/xpc_serviceChoose a Template (required): 3. 创建tweak项目1234567891011121314# 选择 [10.] iphone/tweakChoose a Template (required): 10# 项目名Project Name (required): mytweak# 唯一标识bundleId（自己定）Package Name [com.yourcompany.mytweak]: com.bomo.mytweak# 作者Author/Maintainer Name [bomo]: bomo# 需要hook的App包名[iphone/tweak] MobileSubstrate Bundle filter [com.apple.springboard]: com.bomo.demo# 安装完成后需要重启的App（貌似没用，可以生成后手动改）[iphone/tweak] List of applications to terminate upon installation (space-separated, &#x27;-&#x27; for none) [SpringBoard]:Instantiating iphone/tweak in mytweak/...Done. 得到4个文件 1234controlMakefilemytweak.plistTweak.x Tweak.x就是源码文件，编写tweak代码 12345678910111213141516171819202122232425262728%hook ClassName// Hooking a class method+ (id)sharedInstance &#123; return %orig;&#125;// Hooking an instance method with an argument.- (void)messageName:(int)argument &#123; %log; // Write a message about this call, including its class, name and arguments, to the system log. %orig; // Call through to the original function with its original arguments. %orig(nil); // Call through to the original function with a custom argument. // If you use %orig(), you MUST supply all arguments (except for self and _cmd, the automatically generated ones.)&#125;// Hooking an instance method with no arguments.- (id)noArguments &#123; %log; id awesome = %orig; [awesome doSomethingElse]; return awesome;&#125;// Always make sure you clean up after yourself; Not doing so could have grave consequences!%end 编写TweakLogos语法其实是CydiaSubstruct框架提供的一组宏定义。便于开发者使用宏进行HOOK操作。语法简单，功能强大且稳定。 Logos语法分为三大类 Top level Block level Function level Top level这个TopLevel指令不放在BlockLevel中。%config全局配置%hookf：用于hook符号（C&#x2F;C++方法）%ctor会在动态库(dylib)被加载的时候调用，用于初始化%dtor会在程序结束的时候调用，通常用于回收资源 Block level这一类型的指令会开辟一个代码块，以%end结束 %group与%init配合使用，%group用于给代码块分组，%init用于让代码块生效 12345678910111213141516171819%group iOS8%hook IOS8ClassName // TODO: your code here%end%end%group iOS9%hook IOS9ClassName // TODO: your code here%end%end%ctor &#123; if (kCFCoreFoundationVersionNumber &gt; 1200) &#123; %init(iOS9); &#125; else &#123; %init(iOS8); &#125;&#125; %hook用于hook类方法，%new用于声明新方法 1234567891011121314151617%hook SBApplicationController// hook实例方法-(NSInteger)method:(NSString *)name &#123; // 调用原来方法 NSInteger result = %orig; // 修改返回值 return result + 1;&#125;// 新增类方法%new+ (NSInteger)someNewMethod &#123; return 1 + 1;&#125;%end %subclass用于新增类，新增方法都要加上%new 12345678910111213141516171819202122232425%subclass MyNewObject : NSObject// 声明属性%property (nonatomic, copy) id someValue2;// 构造方法- (id)init &#123; self = %orig; [self setSomeValue:@&quot;value&quot;]; return self;&#125;// someValue和setSomeValue:方法等价于声明属性// `@property (nonatomic, retain) id someValue;`%new- (id)someValue &#123; return objc_getAssociatedObject(self, @selector(someValue));&#125;%new- (void)setSomeValue:(id)value &#123; objc_setAssociatedObject(self, @selector(someValue), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;%end 使用新类MyNewObject 12MyNewObject *myObject = [[%c(MyNewObject) alloc] init];NSLog(@&quot;myObject: %@&quot;, [myObject someValue]); Function level这一块的指令就放在方法中。%init：如上，与%group配合使用%class：废弃不用%c(className)：生成一个Class对象，如：%c(NSObject)，相当于NSObject.class%orig：调用方法原来的实现，包括参数%log：打印方法和参数 编译编译配置再Makefile配置编译选项和设备信息 1234567891011121314151617181920212223# 安装完成后重启SBafter-install:: install.exec &quot;killall -9 SpringBoard&quot;# 如果是RELEASE，设置DEBUG=0DEBUG = 0# 越狱iPhone的ip地址和端口(也可以配置到 ~/.bash_profile 上)THEOS_DEVICE_IP = 192.168.1.2THEOS_DEVICE_PORT = 22# 指定支持的处理器架构ARCHS = armv7 arm64# 指定需要的SDK版本iphone:Base SDK:Deployment TargetTARGET = iphone:latest:9.0 //最新的SDK，程序发布在iOS9.0以上# 导入框架，多个框架时用空格隔开mytweak_FRAMEWORKS = UIKitmytweak_PRIVATE_FRAMEWORKS = AppSupport# 链接libsqlite3.0.dylib、libz.dylib和dylib1.omytweak_LDFLAGS = -lz –lsqlite3.0 –dylib1.o 安装到手机123456# 编译（make package包含了make，这个也可以省略）make# 打包（release）make packages debug=0# 安装到手机上（需要设置环境变量THEOS_DEVICE_IP和THEOS_DEVICE_PORT）make install 合并起来 1make packages debug=0 &amp;&amp; make install 包会被安装到/Library/MobileSubstrate/DynamicLibraries/目录下 12/Library/MobileSubstrate/DynamicLibraries/xxx.plist（存放要hook App的bundleId）/Library/MobileSubstrate/DynamicLibraries/xxx.dylib 资源处理有时候我们有一些资源需要添加到插件中，例如图片在tweak中使用到的资源，可以放到工程的layout/Library/PreferenceLoader/Preferences/xxx下面，在代码中通过绝对路径读取，工程中的layout路径相当于手机的根路径，该路径下的文件会被安装到手机对应的路径下 123456- Makefile- control- tweakxxx.plist- layout/Library/PreferenceLoader/Preferences |- mytweak |- icon.png 上面icon.png资源会被安装到手机的/Library/PreferenceLoader/Preferences/mytweak/icon.png路径下 多文件插件代码多的时候，可能会有多个源文件（Person.m, Tweak1.mx, Tweak2.mx），如下 123456789- Makefile- control- tweakxxx.plist- src |- Tweak1.mx |- Tewak2.mx |- Model |- Person.h |- Person.m 需要在Makefile里面配置需要编译的文件，使用空格隔开 1tweakwechat_FILES = src/Tweak1.xm src/Tweak2.xm src/Model/Person.m 如果文件多，可以使用通配符* 1tweakwechat_FILES = src/*.xm src/Model/*.m 在Tweak1.mx中引用其他头文件的时候需要使用相对路径，如下 1#import &quot;Model/Person.h&quot; Theos-Tweak原理 make编译代码为动态库dylib make package将 dylib 和资源打包成 deb make install将 deb 发送到手机上，并通过 cydia 安装 deb 插件会安装到/Library/MobileSubstrate/DynamicLibraries 启动App，Cydia Substrate会根据已装插件的plist里面配置的bundleId与App的bundleId一致，就会自动注入对应的dylib dylib会根据编写的代码自动hook对应的类和方法 卸载插件只需要删除/Library/MobileSubstrate/DynamicLibraries里面对应的xxx.dylib和xxx.plist即可，如果有包含资源的话，还需要把对应的资源删掉 未脱壳的App也可以注入dylib在内存中修改逻辑，不修改原来的App 引用 http://iphonedevwiki.net/index.php/Logos","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"},{"name":"逆向","slug":"逆向","permalink":"http://zhengbomo.github.io/tags/%E9%80%86%E5%90%91/"}]},{"title":"iOS 签名机制","slug":"ios-sign","date":"2019-05-21T02:46:11.000Z","updated":"2019-05-21T02:46:11.000Z","comments":true,"path":"2019-05-21/ios-sign/","link":"","permalink":"http://zhengbomo.github.io/2019-05-21/ios-sign/","excerpt":"我们都知道，iOS 有非常严格的签名机制，来限制App的安装方式，iOS 用户（不越狱）只能通过（开发者证书，AppStore）安装应用，iOS 的签名机制与 https 的有写类似，理解了 https 就能理解 iOS 的签名机制","text":"我们都知道，iOS 有非常严格的签名机制，来限制App的安装方式，iOS 用户（不越狱）只能通过（开发者证书，AppStore）安装应用，iOS 的签名机制与 https 的有写类似，理解了 https 就能理解 iOS 的签名机制 基础先做一些知识储备 加解密 对称加密：AES，DES，3DES（其中DES，3DES已经不推荐使用了） 非对称加密：RSA（使用公钥加密私钥解密，或者私钥解密公钥加密） 对称加密：解决明文传输的问题非对称加密：解决对称加密带来的密钥配送问题，即使密钥被窃听数据也不会被解密 由于非对称加密的效率比对称加密的效率要慢很多，所以通常使用混合密码解决（主流的安全协议都使用这种方式，如https） 使用非对称加密交换密钥 然后使用对称加密传输数据 上面还是存在1个问题 如何确保收到的数据是原始的数据，而不是被篡改的数据 使用了非对称加密，可以保证数据不会被解密，但是由于公钥可以被监听用于加密数据，中间人可以伪造公钥对数据掉包 数据验证数据验证通常使用单向散列函数生成数据指纹，用于唯一标识数据，常见的算法有 MD5 SHA-1 SHA-2 SHA-3 数字签名数字签名就是数据指纹的一个应用，用于验证数据的完整性（是否被篡改） 上面我们知道了非对称加密，可以用私钥加密，公钥解密，在数据传输工程中由于验证操作并不敏感，通常发送者可以使用私钥签名数据指纹，然后接受者使用公钥解密由于私钥只有发送者拥有，所以能确定数据指纹一定是发送者发送的 证书由于上面数据传输用到的公钥是公开传输的，所以数据可能被掉包，我们需要确保拿到的公钥就是真正的发送者发过来的，而不是中间人伪造的，这个时候就需要证书机构（Certificate Authority，CA）参与公钥的交换，以保证传输过程的公钥的正确 由于 CA 的公钥是公开的，所以 CA 的公钥可以认为不会被伪造，所以可以认为发送方和接收方的通信是安全的因为任何人都可以充当 CA 的角色，这里所说的 CA 是指权威（可信任）的机构 权威证书机构这里有两点可以确定的 发送者和接收者都有有 CA 的公钥，可以验证 CA 发送的数据，这就确保了 CA 的通信过程是安全的 接收方（公钥） -&gt; CA -&gt; 发送方 发送方利用接收方的公钥就能安全的发送（公钥）数据给接收方了，这个过程公钥交换也是安全的 HTTPS在 https通信过程中，证书会从服务端发给客户端，而不是从 CA 发送给客户端 服务器会先向 CA 发送公钥和申请信息（资格，身份信息），CA 把服务器公钥和颁发信息（颁发机构，证书有效期等）打包并用私钥签名给服务器，然后走下面流程 苹果证书苹果的证书的认证就类似于上面说到的 https，我们知道，苹果的开发证书有下面几个文件 *.certSigningRequest: Mac用 Mac公钥 生成*.certSigningRequest文件 *.cer: Apple使用 Apple私钥 签名 Mac公钥，生成 cer 文件 *.mobileprovision: Apple 使用Apple 私钥签名应用信息(bundleId、entitlement、deviceId)和 Mac公钥，生成mobileprovision文件 *.p12: 包含 Mac公钥和Mac私钥，确保多台设备的密钥对是一样的 上面是开发时候的证书处理流程，如果是 AppStore 下载的包，则没有mobileprovision文件，经过苹果审核的App，能确保下载来源只需要，不需要再进行多余的验证操作，只需要验证App 是使用Apple私钥签名的就行 上面流程可以看出来，Mac公钥并没有直接传给iOS设备，而是通过苹果的签名的证书来，这里的苹果就相当于 CA 的角色，整个流程的密钥都是安全的，修改这个流程中的任何数据都会导致无法验证通过，理解了 https 的安全加密就能很好的理解苹果的签名","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"},{"name":"https","slug":"https","permalink":"http://zhengbomo.github.io/tags/https/"}]},{"title":"iOS旋转屏幕","slug":"ios-orientation","date":"2019-05-06T04:55:16.000Z","updated":"2019-05-06T04:55:16.000Z","comments":true,"path":"2019-05-06/ios-orientation/","link":"","permalink":"http://zhengbomo.github.io/2019-05-06/ios-orientation/","excerpt":"iOS屏幕旋转控制，自动旋转，手动旋转，锁定屏幕","text":"iOS屏幕旋转控制，自动旋转，手动旋转，锁定屏幕 1. 设置App支持的旋转方向（2种方式）1. 通过工程设置General-&gt;Deployment Info-&gt;Device Orientation，勾选支持的方向 2. 通过代码设置（AppDelegate）123func application(_ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?) -&gt; UIInterfaceOrientationMask &#123; return .allButUpsideDown&#125; 方式1存在一个问题：如果勾选了多个方向，如果横屏进入App，会出现首页横屏的情况，即使设置了VC只支持竖屏，推荐使用方式2 2. \bViewController旋转控制通常在需要旋转的ViewController，重写下面三个方法即可 123456789101112131415/// 控制是否支持自动旋转，回根据设备方向自动调整布局，例如视频横屏播放，微信公众号文章横屏阅读等override var shouldAutorotate: Bool &#123; return true&#125;/// 设置首次进入ViewController时的方向，之后再根据设备方向变动调整，例如可以保证无论设备是否横屏，首次进入一个ViewController的时候为竖屏/// 注意：这里的设置仅对第二个页面有效，第一个页面无效override var preferredInterfaceOrientationForPresentation: UIInterfaceOrientation &#123; return .portrait&#125;/// 设置支持旋转的方向override var supportedInterfaceOrientations: UIInterfaceOrientationMask &#123; return .landscape&#125; 3. 容器如果ViewController在容器控制器里面的话（UINavigationController和UITabBarController）需要重写容器，让其指向子控制器 TabBarController 123456789101112131415import UIKitclass TabBarController: UITabBarController &#123; override var shouldAutorotate: Bool &#123; return self.selectedViewController?.shouldAutorotate ?? false &#125; override var supportedInterfaceOrientations: UIInterfaceOrientationMask &#123; return self.selectedViewController?.supportedInterfaceOrientations ?? UIInterfaceOrientationMask.portrait &#125; override var preferredInterfaceOrientationForPresentation: UIInterfaceOrientation &#123; return self.selectedViewController?.preferredInterfaceOrientationForPresentation ?? .portrait &#125;&#125; NavigationController 123456789101112131415import UIKitclass NavigationController: UINavigationController &#123; override var shouldAutorotate: Bool &#123; return self.topViewController?.shouldAutorotate ?? false &#125; override var supportedInterfaceOrientations: UIInterfaceOrientationMask &#123; return self.topViewController?.supportedInterfaceOrientations ?? UIInterfaceOrientationMask.portrait &#125; override var preferredInterfaceOrientationForPresentation: UIInterfaceOrientation &#123; return self.topViewController?.preferredInterfaceOrientationForPresentation ?? .portrait &#125;&#125; 4. 强制旋转iOS没有提供公开的API直接修改屏幕方向，通常我们用kvc的方式实现 12345// 强制竖屏UIDevice.current.setValue(UIInterfaceOrientation.portrait.rawValue, forKey: &quot;orientation&quot;)// 强制左横屏UIDevice.current.setValue(UIInterfaceOrientation.landscapeLeft.rawValue, forKey: &quot;orientation&quot;) 5. 方向锁定通过控制VC支持supportedInterfaceOrientations的方向，就可以控制锁定了，只返回一种方向，就能实现锁定的功能 1234567891011121314151617181920212223242526272829303132333435363738/// 定义锁定的方向private var lookOrientation: UIInterfaceOrientation?// 设置当前的方向（锁定屏幕方向）self.lookOrientation = UIApplication.shared.statusBarOrientation// 取消当前的方向（解锁）self.lookOrientation = nil/// 重载用于控制锁定override var supportedInterfaceOrientations: UIInterfaceOrientationMask &#123; if let orientation = self.lookOrientation &#123; // 锁定方向 return orientation.orientationMask &#125; else &#123; // 默认可选旋转 return .allButUpsideDown &#125;&#125;extension UIInterfaceOrientation &#123; // UIInterfaceOrientation转换为UIInterfaceOrientationMask var orientationMask: UIInterfaceOrientationMask &#123; switch self &#123; case .unknown: return .allButUpsideDown case .portrait: return .portrait case .portraitUpsideDown: return .portraitUpsideDown case .landscapeLeft: return .landscapeLeft case .landscapeRight: return .landscapeRight @unknown default: return .allButUpsideDown &#125; &#125;&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"}]},{"title":"StafulWidget自动释放资源Mixin","slug":"flutter-dispose-mixin","date":"2019-04-25T13:48:37.000Z","updated":"2019-04-25T13:48:37.000Z","comments":true,"path":"2019-04-25/flutter-dispose-mixin/","link":"","permalink":"http://zhengbomo.github.io/2019-04-25/flutter-dispose-mixin/","excerpt":"平常开发中，经常会用到释放资源的问题，最常见的就是网络请求了，也是最经常被忽略的问题，例如，我们进入一个新的页面会请求数据，在请求回来之前，这个时候如果用户退出了该页面，就需要及时的释放资源（cancel掉之前的请求），避免资源被释放带来的其他问题，例如空指针，而页面中，可能不止网络请求，可能有定时器，动画，等资源都需要及时的释放，这使得我们管理起来非常麻烦","text":"平常开发中，经常会用到释放资源的问题，最常见的就是网络请求了，也是最经常被忽略的问题，例如，我们进入一个新的页面会请求数据，在请求回来之前，这个时候如果用户退出了该页面，就需要及时的释放资源（cancel掉之前的请求），避免资源被释放带来的其他问题，例如空指针，而页面中，可能不止网络请求，可能有定时器，动画，等资源都需要及时的释放，这使得我们管理起来非常麻烦 我们用一个网络请求的例子来，我们进入页面后，点击按钮，请求github首页，请求成功或失败后更新文字，网络请求使用dio库 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:dio/dio.dart&#x27;;class TestPage extends StatefulWidget &#123; @override _TestPageState createState() =&gt; _TestPageState();&#125;class _TestPageState extends State&lt;TestPage&gt; &#123; CancelToken _token = CancelToken(); String _content = &quot;&quot;; @override void dispose() &#123; // 如果没有被释放，则释放掉 if (_token != null &amp;&amp; !_token.isCancelled) &#123; _token.cancel(); &#125; super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(&quot;test cancel&quot;) ), body: Center( child: Column( children: &lt;Widget&gt;[ RaisedButton( onPressed: () async &#123; try &#123; var url = &quot;https://www.github.com&quot;; _token = CancelToken(); Dio dio = new Dio(); Response response = await dio.get(url, cancelToken: _token); int code = response.statusCode; if (code == 200) &#123; setState(() &#123; _content = &quot;请求成功&quot;; &#125;); &#125; else &#123; setState(() &#123; _content = &quot;请求失败&quot;; &#125;); &#125; &#125; catch (e) &#123; if (!CancelToken.isCancel(e)) &#123; setState(() &#123; _content = &quot;请求失败&quot;; &#125;); &#125; &#125; &#125;, child: Text(&quot;请求数据&quot;) ), Text(_content) ], ) ) ); &#125;&#125; 如果我们不在dispose取消请求的话，用户离开页面后，由于请求没有被cancel，当网络请求回来后，会出现资源被释放导致崩溃 上面例子可以看到，我们需要管理CancelToken，在dispose的时候进行释放，如果需要dispose的对象比较多的时候，管理起来是崩溃的，我们可以把释放的操作封装到mixin中进行统一管理，释放对象（例如：CancelToken）通过闭包管理，而不需要单独维护 1234567891011121314151617import &#x27;package:flutter/material.dart&#x27;;@optionalTypeArgsmixin AutomaticDisposeStatefulWidgetMixin&lt;T extends StatefulWidget&gt; on State&lt;T&gt; &#123; List&lt;Function&gt; _disposeFunc = List&lt;Function&gt;(); void addToDispose(Function func) &#123; _disposeFunc.add(func); &#125; @override void dispose() &#123; // dispose all func _disposeFunc.forEach((f) =&gt; f()); super.dispose(); &#125;&#125; 上面代码可以改为 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class TestPage extends StatefulWidget &#123; @override _TestPageState createState() =&gt; _TestPageState();&#125;class _TestPageState extends State&lt;TestPage&gt; with AutomaticDisposeStatefulWidgetMixin &#123; String _content = &quot;&quot;; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(&quot;test&quot;) ), body: Center( child: Column( children: &lt;Widget&gt;[ RaisedButton( onPressed: () async &#123; try &#123; var url = &quot;https://www.github.com&quot;; var token = CancelToken(); // 在widget释放时候执行 addToDispose(() &#123; token.cancel(); &#125;); Dio dio = new Dio(); Response response = await dio.get(url, cancelToken: token); int code = response.statusCode; if (code == 200) &#123; setState(() &#123; _content = &quot;请求成功&quot;; &#125;); &#125; else &#123; setState(() &#123; _content = &quot;请求失败&quot;; &#125;); &#125; &#125; catch (e) &#123; if (!CancelToken.isCancel(e)) &#123; setState(() &#123; _content = &quot;请求失败&quot;; &#125;); &#125; &#125; &#125;, child: Text(&quot;请求数据&quot;) ), Text(_content) ], ) ) ); &#125;&#125; 当然，除了dispose网络请求，可以在block做任何操作，例如关闭streamController，关闭通知监听等 对于网络请求的释放，一定要在不需要的时候释放对于网络请求的释放，一定要在不需要的时候释放对于网络请求的释放，一定要在不需要的时候释放","categories":[{"name":"flutter","slug":"flutter","permalink":"http://zhengbomo.github.io/categories/flutter/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"http://zhengbomo.github.io/tags/flutter/"}]},{"title":"flutter实现一个ProgressHUD","slug":"flutter-hud","date":"2019-04-24T15:02:17.000Z","updated":"2019-04-24T15:02:17.000Z","comments":true,"path":"2019-04-24/flutter-hud/","link":"","permalink":"http://zhengbomo.github.io/2019-04-24/flutter-hud/","excerpt":"用惯了iOS的SVProgressHUD，但是在flutter pub上的并没有找到类似的实现，于是自己实现一个","text":"用惯了iOS的SVProgressHUD，但是在flutter pub上的并没有找到类似的实现，于是自己实现一个 主要实现四个基本功能 Loading显示 成功显示 错误显示 进度显示：环形进度条和文字 库地址https://pub.dartlang.org/packages/bmprogresshud 12dependencies: bmprogresshud: ^0.0.2 实现效果 由于HUD是盖在视图上面的，通常是整个页面，故考虑直接在目标Widget上套一层ProgressHUD 我们需要在特定的地方获取ProgressHUD进行操作，这个有点类似Navigator，参考Navigator的用法，通过of方法获得 实际效果如下 123456789101112131415161718192021Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(&quot;hud demo&quot;), ), body: ProgressHud( child: Container( child: Builder(builder: (context) &#123; return RaisedButton( onPressed: () async &#123; ProgressHud.of(context).show(ProgressHudType.loading, &quot;加载中...&quot;); await Future.delayed(const Duration(seconds: 1)); ProgressHud.of(context).dismiss(); &#125;, child: Text(&quot;加载数据&quot;), ); &#125;), ), ) );&#125; 实现效果1. 显示和隐藏渐变通过属性opacity和AnimationController控制透明度，当透明度为0时候，通过Offstage控制控件的隐藏 12345678910111213141516171819202122232425262728class ProgressHudState extends State&lt;ProgressHud&gt; with SingleTickerProviderStateMixin &#123; AnimationController _animation; var _opacity = 0.0; var _isVisible = false; @override void initState() &#123; _animation = AnimationController( duration: const Duration(milliseconds: 200), vsync: this )..addListener(() &#123; setState(() &#123; // 修改透明度 _opacity = _animation.value; &#125;); &#125;)..addStatusListener((status) &#123; if (status == AnimationStatus.dismissed) &#123; setState(() &#123; // 隐藏动画结束，隐藏控件 _isVisible = false; &#125;); &#125; &#125;); super.initState(); &#125; ...&#125; 我们通过动画的执行方向控制动画 12345678// 显示动画_animation.forward();setState(() &#123; _isVisible = true;&#125;);// 隐藏动画_animation.reverse(); 2. 通过BuildContext获得Element树的ProgressHUD1234567class ProgressHud extends StatefulWidget &#123; static ProgressHudState of(BuildContext context) &#123; return context.ancestorStateOfType(const TypeMatcher&lt;ProgressHudState&gt;()); &#125; ...&#125; 3. 创建HUD12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849Widget _createHudView(Widget child) &#123; return Stack( children: &lt;Widget&gt;[ // 如果不想屏蔽用户操作，ignoring设置为true，这里设置为无法响应 IgnorePointer( ignoring: false, child: Container( color: Colors.transparent, width: double.infinity, height: double.infinity, ), ), Center( child: Container( // 这里设置一定的偏移，因为iPhoneX有下方安全区域，看起来会偏下 margin: EdgeInsets.fromLTRB(10, 10, 10, 10 - widget.offsetY * 2), decoration: BoxDecoration( color: Color.fromARGB(255, 33, 33, 33), borderRadius: BorderRadius.circular(5) ), // 设置最小宽高，如果文字比较多，可以自适应 constraints: BoxConstraints( minHeight: 130, minWidth: 130 ), child: Padding( padding: EdgeInsets.all(12), child: Column( mainAxisSize: MainAxisSize.min, children: &lt;Widget&gt;[ Container( padding: EdgeInsets.all(15), child: child, ), Container( child: Text( _text, textAlign: TextAlign.center, style: TextStyle(color: Colors.white, fontSize: 16) ), ) ], ), ), ), ), ], );&#125; 4. 环形进度通过Painter画两个圆 12345678910111213141516171819202122232425262728293031323334353637import &#x27;dart:math&#x27;;import &#x27;package:flutter/material.dart&#x27;;class CircleProgressBarPainter extends CustomPainter &#123; final double progress; final double strokeWidth; final Color color; final Color fillColor; const CircleProgressBarPainter(&#123; this.progress = 0, this.strokeWidth = 3, this.color = Colors.grey, this.fillColor = Colors.white &#125;); @override void paint(Canvas canvas, Size size) &#123; final paint = new Paint() ..color = this.color ..style = PaintingStyle.stroke ..strokeWidth = strokeWidth; final double diam = min(size.width, size.height); final centerX = size.width * 0.5; final centerY = size.height * 0.5; final radius = diam / 2.0; canvas.drawCircle(Offset(centerX, centerY), radius, paint); paint.color = this.fillColor; // draw in center var rect = Rect.fromLTWH((size.width - diam) * 0.5, 0, diam, diam); canvas.drawArc(rect, -0.5 * pi, progress * 2 * pi, false, paint); &#125; @override bool shouldRepaint(CustomPainter oldDelegate) =&gt; false;&#125; 完整代码见这里：","categories":[{"name":"flutter","slug":"flutter","permalink":"http://zhengbomo.github.io/categories/flutter/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"},{"name":"flutter","slug":"flutter","permalink":"http://zhengbomo.github.io/tags/flutter/"}]},{"title":"flutter切换tab后保留tab状态","slug":"flutter-tab-keep-alive","date":"2019-02-23T04:43:52.000Z","updated":"2019-02-23T04:43:52.000Z","comments":true,"path":"2019-02-23/flutter-tab-keep-alive/","link":"","permalink":"http://zhengbomo.github.io/2019-02-23/flutter-tab-keep-alive/","excerpt":"前言最近在用flutter写一个小项目，在写主页面（底部导航栏+子页面）时遇到的一个问题：当点击底部item切换到另一页面, 再返回此页面时会重走它的initState方法（我们一般在initState中发起网络请求，或者初始化的操作），导致不必要的开销","text":"前言最近在用flutter写一个小项目，在写主页面（底部导航栏+子页面）时遇到的一个问题：当点击底部item切换到另一页面, 再返回此页面时会重走它的initState方法（我们一般在initState中发起网络请求，或者初始化的操作），导致不必要的开销 根据Tab动态加载页面我们先定义两个页面PageA和PageB 1234567891011121314151617181920212223242526272829303132333435363738394041424344class PageA extends StatefulWidget &#123; _PageAState createState() =&gt; _PageAState();&#125;class _PageAState extends State&lt;PageA&gt; &#123; @override void initState() &#123; super.initState(); print(&quot;pageA init state&quot;); &#125; @override Widget build(BuildContext context) &#123; return Container( color: Colors.orangeAccent, child: Center( child: Text(&quot;page A&quot;), ), ); &#125;&#125;class PageB extends StatefulWidget &#123; _PageBState createState() =&gt; _PageBState();&#125;class _PageBState extends State&lt;PageB&gt; &#123; @override void initState() &#123; super.initState(); print(&quot;pageB init state&quot;); &#125; @override Widget build(BuildContext context) &#123; return Container( color: Colors.blueAccent, child: Center( child: Text(&quot;page B&quot;), ), ); &#125;&#125; 定义Tab主页面 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import &#x27;package:flutter/material.dart&#x27;;void main() =&gt; runApp(MyApp());class MyApp extends StatefulWidget &#123; _MyAppState createState() =&gt; _MyAppState();&#125;class _MyAppState extends State&lt;MyApp&gt; &#123; int _tabIndex = 0; List&lt;Widget&gt; _tabWidget = [ PageA(), PageB() ]; @override Widget build(BuildContext context) &#123; return MaterialApp( title: &#x27;tab demo&#x27;, home: Scaffold( bottomNavigationBar: BottomNavigationBar( items: _createBottomItems(), currentIndex: this._tabIndex, onTap: (index) &#123; setState(() &#123; this._tabIndex = index; &#125;); &#125;, ), body: this._tabWidget.elementAt(this._tabIndex), ), ); &#125;&#125;// 创建底部导航itemList&lt;BottomNavigationBarItem&gt; _createBottomItems() &#123; return [ BottomNavigationBarItem( icon: Icon(Icons.home), title: Text(&quot;首页&quot;) ), BottomNavigationBarItem( icon: Icon(Icons.insert_emoticon), title: Text(&quot;我的&quot;) ) ];&#125; 运行后发现，每次切换tab都会调用initState，这显然不符合我们的正常的需求，有下面两种解决方式 IndexedStackIndexedStack可以控制子元素的显示和隐藏，并且会缓存所有的元素，不会每次都重新创建子元素 123456789101112131415161718192021@overrideWidget build(BuildContext context) &#123; return MaterialApp( title: &#x27;tab demo&#x27;, home: Scaffold( bottomNavigationBar: BottomNavigationBar( items: _createBottomItems(), currentIndex: this._tabIndex, onTap: (index) &#123; setState(() &#123; this._tabIndex = index; &#125;); &#125;, ), body: IndexedStack( children: this._tabWidget, index: this._tabIndex, ) ), );&#125; 运行后发现还是有个问题，IndexedStack在初始化的时候会初始化所有的子元素，pageA和pageB的initState会同时调用，这明显还是不符合我们的需求 正确来说应该是切换到具体页面的时候才进行初始化，而不是一开始就加载所有的页面的数据，避免资源浪费 PageView + AutomaticKeepAliveClientMixin使用PageView支持多个view切换，并且不会一次加载完所有的页面 12345678910111213141516171819202122232425262728293031 PageController _pageController; @override void initState() &#123; super.initState(); this._pageController =PageController(initialPage: this._tabIndex, keepPage: true); &#125; @override Widget build(BuildContext context) &#123; return MaterialApp( title: &#x27;tab demo&#x27;, home: Scaffold( bottomNavigationBar: BottomNavigationBar( items: _createBottomItems(), currentIndex: this._tabIndex, onTap: (index) &#123; setState(() &#123; this._tabIndex = index; _pageController.jumpToPage(index); &#125;); &#125;, ), body: PageView( children: this._tabWidget, controller: _pageController, ), ), ); &#125;&#125; 使用PageView可以正常切换，但是每次切换Tab的时候还是会重复调用initState，我们还需要在子页面实现AutomaticKeepAliveClientMixin 123456789101112class _PageAState extends State&lt;PageA&gt; with AutomaticKeepAliveClientMixin &#123; @override bool get wantKeepAlive =&gt; true; ...&#125;class _PageBState extends State&lt;PageB&gt; with AutomaticKeepAliveClientMixin &#123; @override bool get wantKeepAlive =&gt; true; ...&#125; 实现了AutomaticKeepAliveClientMixin就不会每次切换Tab都调用initState了，这也是google推荐的方式 最后发现PageView可以左右滑动切换，这个可以通过设置physics为NeverScrollableScrollPhysics()来禁止滑动 12345PageView( children: this._tabWidget, controller: _pageController, physics: NeverScrollableScrollPhysics(),)","categories":[{"name":"flutter","slug":"flutter","permalink":"http://zhengbomo.github.io/categories/flutter/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"http://zhengbomo.github.io/tags/flutter/"}]},{"title":"flutter给控件设置圆角","slug":"flutter-radius-corner","date":"2019-02-20T11:51:44.000Z","updated":"2019-02-20T11:51:44.000Z","comments":true,"path":"2019-02-20/flutter-radius-corner/","link":"","permalink":"http://zhengbomo.github.io/2019-02-20/flutter-radius-corner/","excerpt":"Flutter给控件设置圆角有几种方式，可以通过裁切Widget包装，也可以通过装饰器设置","text":"Flutter给控件设置圆角有几种方式，可以通过裁切Widget包装，也可以通过装饰器设置 裁切控件Clip123456789101112131415161718// 圆角new ClipRRect( borderRadius: BorderRadius.circular(6.0), child: Container( width: 100, height: 100, color: Colors.redAccent, ))// 圆形new ClipOval( child: Container( width: 100, height: 100, color: Colors.redAccent, ),) 装饰器BoxDecoration123456789101112131415161718192021222324252627// 圆角DecoratedBox( decoration: BoxDecoration( border: new Border.all(color: Colors.black54, width: 0.5), color: Colors.greenAccent, shape: BoxShape.rectangle, borderRadius: BorderRadius.circular(12.0), ), child: Container( padding: EdgeInsets.all(12), child: Text(&quot;内容&quot;), ),)// 圆形DecoratedBox( decoration: BoxDecoration( border: new Border.all(color: Colors.black54, width: 0.5), color: Colors.greenAccent, shape: BoxShape.circle, ), child: Container( padding: EdgeInsets.all(12), child: Text(&quot;内容&quot;), ),) 注意：DecoratedBox与Clip控件不同，这里只进行装饰，不进行裁切，如果child的内容超出了范围，装饰器不会进行裁切，BoxDecoration通常可以用来设置边框，例如标签列表等 对于圆形头像我们也用的比较多，这里有一个圆形头像的控件，效果与BoxDecoration一致 1234CircleAvatar( radius: 100, backgroundImage: NetworkImage(&quot;https://flutter.io/images/intellij/hot-reload.gif&quot;),)","categories":[{"name":"flutter","slug":"flutter","permalink":"http://zhengbomo.github.io/categories/flutter/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"http://zhengbomo.github.io/tags/flutter/"}]},{"title":"frp内网穿透","slug":"frp-start","date":"2018-10-18T02:34:11.000Z","updated":"2023-06-11T03:02:51.863Z","comments":true,"path":"2018-10-18/frp-start/","link":"","permalink":"http://zhengbomo.github.io/2018-10-18/frp-start/","excerpt":"最近用斐讯N1刷了Ubuntu系统，作为一个小型的服务器，偶尔需要在外网访问，内网穿透的工具有很多，例如花生壳，frp，ngrok等，这里使用一个比较简单配置的frp，是一个可用于内网穿透的高性能的反向代理应用，支持多端口多协议，而且是开源的，能满足大部分的需求","text":"最近用斐讯N1刷了Ubuntu系统，作为一个小型的服务器，偶尔需要在外网访问，内网穿透的工具有很多，例如花生壳，frp，ngrok等，这里使用一个比较简单配置的frp，是一个可用于内网穿透的高性能的反向代理应用，支持多端口多协议，而且是开源的，能满足大部分的需求 准备 我们需要一台公网IP的服务器（linux），下面称为服务器 局域网设备一台（linux），下面称为客户端 域名（可选） 配置到这里找到对应的版本和系统我用的是谷歌云，我用的是frp_0.20.0_linux_amd64.tar.gz 12345678# 下载wget https://github.com/fatedier/frp/releases/download/v0.20.0/frp_0.20.0_linux_amd64.tar.gz# 解压tar -zxvf frp_0.20.0_linux_amd64.tar.gz# 进入目录cd frp_0.20.0_linux_amd64 客户端和服务端一样，我用的N1是arm架构的，下载的是frp_0.20.0_linux_arm64.tar.gz 服务器端配置 先删除客户端用的文件 12rm frpcrm frpc.ini 配置frps.ini 1234vim frps.ini[common]bind_port = 7000 通常不需要修改 开启服务 1./frps -c ./frps.ini 服务端需要监听7000端口给客户端访问，如果用是云服务器，需要看一下入站规则是否允许7000端口，否则客户端会报连接超时 客户端配置客户端配置与服务端基本相同 先删除服务端用的文件 12rm frpsrm frps.ini 配置frpc.ini, vim frps.ini 123456789101112131415161718192021[common]server_addr = 35.221.xx.xxserver_port = 7000[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 6000[http1]type = httplocal_port = 80remote_port = 6001custom_domains = n1.bombox.org[http2]type = httplocal_port = 8080remote_port = 6002custom_domains = n1.bombox.org 【server_addr】为服务器公网IP 【server_port】为服务器配置的端口 【remote_port】为通过服务端访问的端口，例如我们通过35.221.xx.xx:6000访问客户端的ssh，通过n1.bombox.org:6001访问客户端的80端口 【custom_domains】可以绑定自己的子域名，需要在域名解析后台添加一条A记录即可，记录值为服务器IP35.221.xx.xx，如下 启动 1./frpc -c ./frpc 接着我们就通过域名访问客户端了 123ssh -p 6000 root@35.221.xx.xxhttp://h1.bombox.org:6001http://h1.bombox.org:6002 后台启动和开机启动如果上面测试没有问题，我们可以通过后台启动并设置成开机启动 后台运行12345# 服务端（注意后面有个`&amp;`）nohup /home/bomo/app/frp/frps -c /home/bomo/app/frp/frps.ini &amp;# 客户端（注意后面有个`&amp;`）nohup /home/bomo/app/frp/frpc -c /home/bomo/app/frp/frpc.ini &amp; 运行后会返回进程号，也可以通过ps命令查看进程信息 1ps -aux | grep frp 杀掉进程 1kill -9 进程号 开机自动启动使用systemctl来控制启动，先添加frps服务，这里演示服务端的，客户端类似 1vim /lib/systemd/system/frps.service 写入下面内容，并保存 1234567891011[Unit]Description=fraps serviceAfter=network.target syslog.targetWants=network.target[Service]Type=simpleExecStart=/path/to/frps -c /path/to/frps.ini[Install]WantedBy=multi-user.target 启动服务 1234567891011121314# 启动frps服务systemctl start frps.service# 设置开机自启动systemctl enable frps.service# 停止开机自启动systemctl disable frps.service# 查看服务当前状态systemctl status frps.service# 重新启动某服务systemctl restart frps.service","categories":[{"name":"路由器","slug":"路由器","permalink":"http://zhengbomo.github.io/categories/%E8%B7%AF%E7%94%B1%E5%99%A8/"}],"tags":[{"name":"路由器","slug":"路由器","permalink":"http://zhengbomo.github.io/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"},{"name":"frp","slug":"frp","permalink":"http://zhengbomo.github.io/tags/frp/"}]},{"title":"斐讯N1刷Armbian Linux做服务器","slug":"n1-run-armbian","date":"2018-10-15T03:48:43.000Z","updated":"2023-06-11T03:02:51.863Z","comments":true,"path":"2018-10-15/n1-run-armbian/","link":"","permalink":"http://zhengbomo.github.io/2018-10-15/n1-run-armbian/","excerpt":"N1上了不到两个月，斐讯就翻车了，现在N1也挖不了矿，作为NAS又太鸡肋，看到可以刷Armbian系统还是很激动的，可以作为服务器折腾一下，这里记录一下刷机的过程","text":"N1上了不到两个月，斐讯就翻车了，现在N1也挖不了矿，作为NAS又太鸡肋，看到可以刷Armbian系统还是很激动的，可以作为服务器折腾一下，这里记录一下刷机的过程 工具准备 双公头USB线，可以3.9淘宝一根，https://detail.tmall.com/item.htm?id=13036924933 adb调试工具：https://dl.google.com/android/repository/platform-tools-latest-windows.zip DiskImager: 降img文件写入U盘的工具 降级分区：boot.img, bootloader.img, recovery.img U盘一个：用于写入系统 PC一台：我这里用的是Win10 USB键盘一个：用于连接N1座一些初始化设置 HDMI线和显示器一台：用于连接N1做一些初始化设置 armbian固件下载：https://yadi.sk/d/pHxaRAs-tZiei，我选的是这个 Armbian_5.62_Aml-s9xxx_Ubuntu_xenial_default_4.18.7_desktop_20181012.img.xz 降级先降级，然后刷入比较保险，有些帖子说不用降级，但我没成功，还是先降级稳妥些 先打开adb模式：在N1的主界面的【固件版本】点击4次，会看到adb打开的提示 N1与PC需要在同一个局域网，我的N1的IP是：10.10.10.120 测试连接是否成功：在终端输入 1234# 进入adb工具目录cd path/to/adbadb connect 10.10.10.120 会看到返回connected to 10.10.10.120的提示，说明连接成功 使用双公头链接N1和PC：连接N1靠近HDMI的USB口 用下面命令让N1重启为fastboot模式 1adb shell reboot fastboot 这时候N1会重启，重启后没什么变化，可以通过fastboot devices -l命令查看设备 刷机刷入降级分区123456# 进入工具目录cd /path/to/fastbootfastboot flash boot boot.imgfastboot flash bootloader bootloader.imgfastboot flash recovery recovery.img 如果没有错误提示，说明写入成功，接下来重启 1fastboot reboot 重启完成后，就可以刷新固件了 制作U盘启动固件 插入U盘，并格式化 打开Win32DiskImager，选择img文件和U盘盘符 点击写入，等待几分钟后写入成功 写入完成后，可以看到有个Boot的磁盘 5.62后的版本：修改根目录下的uEnv.ini文件，将meson-gxl-s905x-khadas-vim.dtb换成N1对应的meson-gxl-s905d-p230.dtb 之前的版本：复制dtb/meson-gxl-s905d-p230.dtb到根目录，并重命名为dtb.img 弹出U盘 U盘插入N1靠近HDMI的USB口 写入系统到N1 连接N1的HDMI到显示器，N1断电重连 显示器可以看到N1从U盘启动，加载U盘的ubuntu系统 跟进提示配置即可，默认用户：root，密码：1234 在/root/目录下，有两个文件install.sh和install-2018.sh，运行这个会把U盘的系统写到N1的eMMC，就可以脱离U盘使用了 1./install.sh 写入完成后重启系统，关机的时候拔出U盘 12345# 重启reboot# 关机poweroff 初始化配置先使用armbian-config配置系统和网络，我们先配置网络就行，其他根据需要配置 卸载红外模块N1不支持红外线，下面命令关闭和删除红外服务 1234# 关闭红外服务systemctl stop lircd.service lircd-setup.service lircd.socket lircd-uinput.service lircmd.service# 卸载红外模块apt remove -y lirc &amp;&amp; apt autoremove -y 更新软件包1apt update &amp;&amp; apt upgrade -y 挂在外置存储插入外置硬盘或U盘，通过fdisk -l查看磁盘信息和分区 123456789101112131415161718192021Disk /dev/mmcblk1: 7.3 GiB, 7818182656 bytes, 15269888 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisklabel type: dosDisk identifier: 0x91950000Device Boot Start End Sectors Size Id Type/dev/mmcblk1p1 1368064 1617919 249856 122M c W95 FAT32 (LBA)/dev/mmcblk1p2 1619968 15269887 13649920 6.5G 83 LinuxDisk /dev/sda: 931.5 GiB, 1000204886016 bytes, 1953525168 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisklabel type: dosDisk identifier: 0xa32f3aa6Device Boot Start End Sectors Size Id Type/dev/sda1 2 1953525167 1953525166 931.5G 7 HPFS/NTFS/exFAT 通过上面，看到硬盘分区为/dev/sda1通过mount挂在分区 12345# 如果不存在就创建mkdir /mnt/usb_disk# 挂载分区mount /dev/sda1 /mnt/usb_disk 进入/mnt/usb_disk可以看到硬盘分区的文件 配置frp用于公网连接参考这里：frp内网穿透","categories":[{"name":"路由器","slug":"路由器","permalink":"http://zhengbomo.github.io/categories/%E8%B7%AF%E7%94%B1%E5%99%A8/"}],"tags":[{"name":"路由器","slug":"路由器","permalink":"http://zhengbomo.github.io/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"},{"name":"斐讯","slug":"斐讯","permalink":"http://zhengbomo.github.io/tags/%E6%96%90%E8%AE%AF/"}]},{"title":"斐讯K3N通过ttl刷K3固件","slug":"k3n-ttl-flashing","date":"2018-10-15T00:01:56.000Z","updated":"2023-06-11T03:02:51.863Z","comments":true,"path":"2018-10-15/k3n-ttl-flashing/","link":"","permalink":"http://zhengbomo.github.io/2018-10-15/k3n-ttl-flashing/","excerpt":"K3N刚发布，斐讯就翻车了，K3N基本没有讨论的帖子，论坛基本是K3的帖子，好在K3和K3N的固件是通用的，通过TTL可以直接刷入K33的固件，在这里记录一下刷机的过程","text":"K3N刚发布，斐讯就翻车了，K3N基本没有讨论的帖子，论坛基本是K3的帖子，好在K3和K3N的固件是通用的，通过TTL可以直接刷入K33的固件，在这里记录一下刷机的过程 准备 K3N和K3的固件是通用的 K3N目前只能通过TTL刷机（需要拆机） TTL刷机需要用到USB转TTL刷机板，由于K3主板上的TTL是圆孔的，所以还需要插针，淘宝，下面是我购买的链接： 刷机板：https://detail.tmall.com/item.htm?id=577003848649 插针：https://detail.tmall.com/item.htm?id=41428876908 PC一台 工具 固件：只要是k3的固件都可以，我用的abcc的官改固件（其他K3固件也可以），下载后得到k3_v18.binhttp://www.right.com.cn/forum/thread-259012-1-1.html， Tftpd64：用于从PC传输固件到路由器上 SecureCRT: 用于连接刷机板 单片机驱动，购买了刷机板的可以找厂家要，我这里用的是CH340：http://www.winchiphead.com/download/CH341/CH341SER.ZIP，需要先卸载驱动，再安装 工具打包：链接: https://pan.baidu.com/s/185d8QLJNuF88pXIjJNaLhA 提取码: 6dxm 拆机第一步肯定是要拆机了，下面是几个K3的拆机贴，跟K3N是一样的，可以参考下 小白K3拆机教程，易 K3拆机高清图片，给即将拆机的朋友一些参考 斐讯k3拆机 ttl救砖 教程 最后得到主板如下 非接口一端有四个圆孔 四个孔分别是TX, RX, GND, VCC，我们通过这四个孔连接刷机版 刷机板也有这四个接口 连接 插入刷机版到电脑（注意先安装驱动，安装驱动的时候不要插刷机板），在设备管理器中可以看到，我这里是COM3 打开SecureCRT，选择快速连接，设置如下，然后点击连接 Protocol -&gt; Serial Port -&gt; COM3 USB-SERIAL CH340 Baud rate -&gt; 115200 Data bits -&gt; 8 3. 这个时候可以可以看到session为绿色，是连上了，但是没有数据 连接刷机版，刷机板一端连接PC，另一端连接路由器的TTL 123RXD -&gt; RXTXD -&gt; TXGND -&gt; GND 还有一种接线方式GND接GND，RXD接TX，TXD接RX，我的板就是这种，如果接反了，会读不到数据 我在刷机板的线接了四个插针，插入K3N主板的四个孔，用东西卡住，避免接触不良，可以不用焊接 只需要接三条线，`VCC`口不用接 路由器接上网线（网线连接PC）和电源，电源先不要开，路由器主板最好把屏幕也连接上，方便看进度 刷机 按住reset键，打开路由器电源可以看到SecureCRT有数据输出，并且可以看到路由器的IP（172.16.10.1）不同路由器IP可能不一样，最后一行为CFE&gt;，这时候可以放开reset键 如果能看到IP地址，就说明成功不远了 电脑设置网卡的IP，如下，ip地址可以设置为172.16.10.100，不要跟路由器的IP一样，这时候电脑的网卡可能显示没有网络或者断开，不用管，设置就行了 打开Tftpd64，选择固件的目录和网卡，如下之前准备的固件k3_18.bin放在选择的目录下，并改名为k3.trx选择网卡的时候可以看到刚刚设置的IP（172.16.10.100） 在SecureCRT输入下面命令注意替换成上面设置的IP，文件名我们改为了k3.trx 1flash -noheader 172.16.10.100:k3.trx nflash0.trx 这个过程有点久，路由器会先从PC下载固件（通过Tftpd64），可以在Tftpd64看到进度 下载完成后在SecureCRT会看到输出 执行完成之后路由器会重启，如果连接了显示器，可以看到路由器缓慢的启动，启动完会提示系统升级，然后再重启，到这里刷机完成，可以愉快的玩耍了 附件提供的固件是官改固件，也可以根据情况刷其他固件","categories":[{"name":"路由器","slug":"路由器","permalink":"http://zhengbomo.github.io/categories/%E8%B7%AF%E7%94%B1%E5%99%A8/"}],"tags":[{"name":"路由器","slug":"路由器","permalink":"http://zhengbomo.github.io/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"},{"name":"斐讯","slug":"斐讯","permalink":"http://zhengbomo.github.io/tags/%E6%96%90%E8%AE%AF/"}]},{"title":"iOS内购掉单问题","slug":"ios-iap","date":"2018-07-14T00:13:06.000Z","updated":"2018-07-14T00:13:06.000Z","comments":true,"path":"2018-07-14/ios-iap/","link":"","permalink":"http://zhengbomo.github.io/2018-07-14/ios-iap/","excerpt":"1. 背景 iOS IAP 的机制是有问题的。并不是金融级别的支付校对流程 iOS IAP是在客户端完成的，是单向的过程，使用 IAP 内购会有可能导致订单丢失","text":"1. 背景 iOS IAP 的机制是有问题的。并不是金融级别的支付校对流程 iOS IAP是在客户端完成的，是单向的过程，使用 IAP 内购会有可能导致订单丢失 2. 支付状态 SKPaymentTransactionStatePurchasing：正在支付 SKPaymentTransactionStatePurchased：已支付 SKPaymentTransactionStateFailed：支付失败 SKPaymentTransactionStateRestored：恢复购买，例如非消耗商品在iPad已经购买了，在iPhone恢复，或者卸载了App，重装没有及时更新状态，可以用这个恢复，用于非消耗品 SKPaymentTransactionStateDeferred：未确定状态，由于外部原因导致的（如家长控制，未测试） 3. IAP支付流程 根据productId（com.nsdk.sdk.6）获取SKProduct 把SKProductId加到购买队列里面，并且把外部的orderId，绑定到SKPayment的applicationUsername上 从SKPaymentTransactionObserver监听支付结果，在监听到支付成功后，可以拿到SKPayment绑定的CustomOrderId，把苹果的订单和我们订单绑定上（根据网上描述的掉单情况，有一定概率是在回调的地方获取不到CustomOrderId，这个时候就会出现掉单的情况，而如果这个时候绑定了一个其他的orderId，就会出现串单的情况，但是没有验证成功） 当客户端调用finishTransaction时，则表示订单已经完成，则客户端不再接收到支付成功的回调，如果没有finishTransaction，则苹果会一直回调（每次打开App(监听)就会回调，直到调用finishTransaction完成订单） 4. 调研汇总 同一个商品，如果上次支付用户支付成功SKPaymentTransactionStatePurchased，但是没有调用finishTransaction），再次下单购买的时候，会提示恢复购买，只会调用Purchasing，不会监听到其他状态，并且用户不会扣钱，如果重新打开App，重新监听SKPaymentTransactionObserver，会收到多条回调，并且对应的transactionId一样，也就是同一个商品，再未完成前，不会重复扣款，只有上一个订单完成后，才会继续支付扣款 purchasing状态下还没有唯一标识transactionIdentifier，只有在purchased和restore状态下才有 在iOS7以后，苹果的支付票据保存在Bundle.main.appStoreReceiptURL，票据只有一份，并且是加密的，\b无法再客户端进行拆分订单，用户支付成功后，信息会存在票据中，当订单完成（finishTransaction），会从票据中把相应的订单删除，客户端无法知道票据包含哪些支付成功的订单，同一个票据里面，会有多个订单，可以从苹果的验证接口返回数据，看到票据包含哪些订单，通常情况下只有一个，不排除有多个，如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#123; &quot;status&quot;: 0, &quot;environment&quot;: &quot;Sandbox&quot;, &quot;receipt&quot;: &#123; &quot;receipt_type&quot;: &quot;ProductionSandbox&quot;, &quot;adam_id&quot;: 0, &quot;app_item_id&quot;: 0, &quot;bundle_id&quot;: &quot;com.nsdk.sdk&quot;, &quot;application_version&quot;: &quot;1&quot;, &quot;download_id&quot;: 0, &quot;version_external_identifier&quot;: 0, &quot;receipt_creation_date&quot;: &quot;2018-07-05 12:31:44 Etc/GMT&quot;, &quot;receipt_creation_date_ms&quot;: &quot;1530793904000&quot;, &quot;receipt_creation_date_pst&quot;: &quot;2018-07-05 05:31:44 America/Los_Angeles&quot;, &quot;request_date&quot;: &quot;2018-07-05 12:32:20 Etc/GMT&quot;, &quot;request_date_ms&quot;: &quot;1530793940135&quot;, &quot;request_date_pst&quot;: &quot;2018-07-05 05:32:20 America/Los_Angeles&quot;, &quot;original_purchase_date&quot;: &quot;2013-08-01 07:00:00 Etc/GMT&quot;, &quot;original_purchase_date_ms&quot;: &quot;1375340400000&quot;, &quot;original_purchase_date_pst&quot;: &quot;2013-08-01 00:00:00 America/Los_Angeles&quot;, &quot;original_application_version&quot;: &quot;1.0&quot;, &quot;in_app&quot;: [&#123; &quot;quantity&quot;: &quot;1&quot;, &quot;product_id&quot;: &quot;com.nsdk.sdk.6&quot;, &quot;transaction_id&quot;: &quot;1000000414405534&quot;, &quot;original_transaction_id&quot;: &quot;1000000414405534&quot;, &quot;purchase_date&quot;: &quot;2018-07-05 12:23:43 Etc/GMT&quot;, &quot;purchase_date_ms&quot;: &quot;1530793423000&quot;, &quot;purchase_date_pst&quot;: &quot;2018-07-05 05:23:43 America/Los_Angeles&quot;, &quot;original_purchase_date&quot;: &quot;2018-07-05 12:23:43 Etc/GMT&quot;, &quot;original_purchase_date_ms&quot;: &quot;1530793423000&quot;, &quot;original_purchase_date_pst&quot;: &quot;2018-07-05 05:23:43 America/Los_Angeles&quot;, &quot;is_trial_period&quot;: &quot;false&quot; &#125;, &#123; &quot;quantity&quot;: &quot;1&quot;, &quot;product_id&quot;: &quot;com.nsdk.sdk.12&quot;, &quot;transaction_id&quot;: &quot;1000000414404413&quot;, &quot;original_transaction_id&quot;: &quot;1000000414404413&quot;, &quot;purchase_date&quot;: &quot;2018-07-05 12:20:20 Etc/GMT&quot;, &quot;purchase_date_ms&quot;: &quot;1530793220000&quot;, &quot;purchase_date_pst&quot;: &quot;2018-07-05 05:20:20 America/Los_Angeles&quot;, &quot;original_purchase_date&quot;: &quot;2018-07-05 12:20:20 Etc/GMT&quot;, &quot;original_purchase_date_ms&quot;: &quot;1530793220000&quot;, &quot;original_purchase_date_pst&quot;: &quot;2018-07-05 05:20:20 America/Los_Angeles&quot;, &quot;is_trial_period&quot;: &quot;false&quot; &#125; ] &#125;&#125; 用户购买了”元宝6”和”元宝12”两个商品，并且支付成功，但由于网络原因，回调的时候没有同步到服务器（还没finishTransaction），下次启动（监听SKPaymentTransactionObserver）时，两个订单都会回调支付成功 如果用户购买了”元宝6”，并且支付成功，但是由于网络原因，回调的时候没有同步到服务器（还没finishTransaction），用户又重新购买了几次（提示已购买，此项目将免费恢复），然后重启App，SKPaymentTransactionObserver将会回调多次，并且订单transactionIdentifier相同（这里是个坑，用户在SDK下单多次，但是在苹果支付只一次，而回调成功会多次，而客户端逻辑会以为多次下单都成功了，需要服务端做去重控制） 刚打开App的时候，通常会监听订单状态，之前没有同步成功的订单会收到通知，由于苹果的票据只有一份，每个订单都会使用同一个票据去服务端校验（有可能同一个订单会回调多次），服务端需要考虑去重的问题（transactionId），避免同一个票据刷多次 如果支付没有完成，卸载App，重装，也能收到回调 正常情况下下单，update回调会先触发purchasing，然后触发purchased或failed 由于情况1的存在，如果已存在一个已支付但是未完成的订单，这个时候再下一个新的单（productId相同），监听回调只有一次purchasing，不会有purchased或failed回调（巨坑） 这个时候调用的地方就不知道用户什么时候支付完成了，造成的问题是支付前显示Loading，而没有关闭回调，导致loading一直显示 推荐解决方案：在监听paymentQueue:updatedTransactions方法时，使用queue.transactions，而不是用参数transaction，如下123456789101112131415161718192021- (void)paymentQueue:(SKPaymentQueue *)queue updatedTransactions:(NSArray&lt;SKPaymentTransaction *&gt; *)transactions &#123; // 原 // for (SKPaymentTransaction *transaction in transactions) &#123; // 改 for (SKPaymentTransaction *transaction in queue.transactions) &#123; // TODO: switch (transaction.transactionState) &#123; case SKPaymentTransactionStateFailed: break; case SKPaymentTransactionStateDeferred: break; case SKPaymentTransactionStateRestored: break; case SKPaymentTransactionStatePurchased: break; case SKPaymentTransactionStatePurchasing: break; &#125; &#125;&#125; TODO：上面还有一个问题，由于取的是数组，可能会有多个，导致触发回调多次，发货也触发多次，就是可能会回调多次 5. 常见问题串单由于正在处理的订单可能不止一个，如果使用单例共用状态orderId，如果时机不对（多个单一起出现），会出现orderId和苹果订单对应不上应该通过applicationUsername把苹果订单和我们的orderId绑定起来，避免关系错乱，导致串单由于苹果票据只有一份，多个订单也会使用同一个票据，而验证通过，这一点需要服务端也做相关的去重处理 掉单客户端把票据传给服务器后，就标识订单finish，服务端校验苹果票据是异步的，如果校验失败，则会调单由于票据只有一份，并且可能包含多个订单，服务端验证票据时，需要进行分别判断，很多人的做法是只取第一个，导致校验失败，从而调单 刷单如果服务器端对苹果平局没有做去重校验，同一个票据可以被校验多次，用户可能会因为这个无意刷单，支付一次，发货多次（概率很低，但是有） 6. 措施 添加applicationUsername用于绑定苹果订单和SDK订单，去除共用orderId 服务端优化订单校验，校验失败的处理（改为同步，并返回给客户端？） 由于苹果票据可能含有多个订单，服务端在做订单校验的时候需要针对指定的订单处理 由于苹果一个票据对应多个订单，客户端可能多个订单使用同一个票据，服务端需要做苹果订单去重处理，同一个票据不应该校验两次（根据transactionId） 7. 不可避免问题 苹果订单和SDK订单的绑定关系丢失（\b\b网上很多丢单问题这么说，我没用重现出来，只是可能，不能确定，考虑埋点统计）（orderId &#x3D;&#x3D; null） 补救：后台做记录，根据用户反馈手动补单 8. 其他上面描述不包含订阅类型 9 引用 https://stackoverflow.com/questions/25510678/how-to-test-skpaymenttransactionstatedeferred/27367749","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"},{"name":"IAP","slug":"IAP","permalink":"http://zhengbomo.github.io/tags/IAP/"}]},{"title":"swift泛型笔记","slug":"swift-generic","date":"2018-06-13T23:41:49.000Z","updated":"2018-06-13T23:41:49.000Z","comments":true,"path":"2018-06-14/swift-generic/","link":"","permalink":"http://zhengbomo.github.io/2018-06-14/swift-generic/","excerpt":"泛型可以让代码处理类型更加灵活，在某些场景下可以很大程度的重用代码，泛型是什么，使用泛型的好处，这里不多说，网上有很多文章介绍的很详细，这里只讨论用法，Swift的泛型与其他语言有些类型，又有些不一样，搜了一下发现，网上的文章只描述了一点，并不全面，看完后依然没能很全面的说明泛型的用法，在这里记录完整的用法","text":"泛型可以让代码处理类型更加灵活，在某些场景下可以很大程度的重用代码，泛型是什么，使用泛型的好处，这里不多说，网上有很多文章介绍的很详细，这里只讨论用法，Swift的泛型与其他语言有些类型，又有些不一样，搜了一下发现，网上的文章只描述了一点，并不全面，看完后依然没能很全面的说明泛型的用法，在这里记录完整的用法 定义泛型swift的泛型定义方式有两种，一种通过&lt;T&gt;指定泛型参数，而在属性或方法，使用指定的泛型类型，下面是一个泛型方法的声明 泛型方法12345678910111213/// 交换两个同类型的变量func swap&lt;T&gt;(a: inout T, b: inout T) &#123; let c = a a = b b = c&#125;var (a, b) = (2, 1)swap(&amp;a, &amp;b)print(a, b) // 1, 2swap(&amp;a, &amp;b) print(a, b) // 2, 1 泛型类上面是泛型方法的定义，如果在类里面，可以对类声明泛型 123456789101112131415161718192021222324252627282930313233class Test&lt;T&gt; &#123; /// 泛型属性 var testObj: T? /// 泛型方法，可以直接使用类的泛型参数T func swap&lt;T&gt;(a: inout T, b: inout T) &#123; let c = a a = b b = c &#125; /// 方法的泛型定义可以不依赖于类的泛型参数 func swap2&lt;TK&gt;(a: inout TK, b: inout TK) &#123; let c = a a = b b = c &#125;&#125;// 属性let t = Test&lt;Int&gt;()t.testObj = 12print(t.testObj) // 12var a: Int? = 2var b: Int? = 1t.swap(a: &amp;a, b: &amp;b)print(a, b) // 1, 2var s1: String? = &quot;a&quot;var s2: String? = &quot;b&quot;t.swap2(a: &amp;s1, b: &amp;s2)print(s1, s2) // b, a 泛型参数泛型可以支持多个类型参数，在声明处用逗号分开 12345678910class Test &#123; /// 多个泛型参数 func test&lt;T1, T2&gt;(t1: T1, t2: T2) -&gt; Int &#123; print(&quot;t1: \\(t1), t2: \\(t2)&quot;) return 1 &#125;&#125;let t = Test()let result = t.test(t1: NSObject(), t2: &quot;abc&quot;) 泛型约束类型约束定义在\b\b泛型声明处，支持类约束和protocol约束，如下 123456789101112131415161718protocol Run &#123; func run()&#125;protocol Fly &#123; func fly()&#125;/// 单协议约束func test&lt;T: Run&gt;(animal: T) &#123; animal.run()&#125;/// 类型和多协议约束func test&lt;T: NSObject &amp; Fly &amp; Run&gt;(bird: T) &#123; bird.fly() bird.run()&#125; 泛型可以用在方法参数，方法返回值，属性上 协议泛型除了类，结构体和枚举也支持泛型，用法与类一样，但是协议protocol不能像上面一样使用协议只能通过关联类型associatedtype来实现泛型的功能，相当于泛型声明为协议的成员，而泛型的成员在实现的时候指定 123456789101112131415protocol Write &#123; /// 关联类型Element，相当于上面的T associatedtype Element func write(_ element: Element)&#125;class File: Write &#123; // 在实现关联类型的协议的时候，需要指定关联类型 typealias Element = String // 实现协议方法 func write(_ element: File.Element) &#123; print(element) &#125;&#125; 关联类型的约束关联类型的约束与普通泛型约束一样，在声明的地方后面添加，通过逗号隔开 1234 protocol Write &#123; associatedtype Element: NSObject, Encodable func write(_ element: Element)&#125; 关联自身类型protocol利用associatedtype关联自身类型 12345678910111213141516171819protocol Equalable &#123; func equal(_ a: Self) -&gt; Bool&#125;class Test: Equalable &#123; var id: Int = 0 init(id: Int) &#123; self.id = id &#125; func equal(_ a: Test) -&gt; Bool &#123; return self.id == a.id &#125;&#125;let a = Test(id: 1)let b = Test(id: 2)a.equal(b) // false associatedtype冲突associatedtype有另一个问题没有解决，就是类型冲突，如下 123456789101112131415161718protocol Read &#123; associatedtype Element func read() -&gt; Element&#125;protocol Write &#123; associatedtype Element func write(a: Element)&#125;// 两个Element名字相同，无法指定class ReadWrite: Read, Write &#123; func read() -&gt; Int &#123; return 5 &#125; func write(a: String) &#123; print(&quot;writing \\(a)&quot;) &#125;&#125; 在stackoverflow上有个不完美的解决方案:https://stackoverflow.com/questions/37736457/protocol-with-same-associated-type-name 123456789101112131415protocol ReadInt: Read &#123; associatedtype Element = Int&#125;protocol WriteString: Write &#123; associatedtype Element = String&#125;class ReadWrite: ReadInt, WriteString &#123; func read() -&gt; Int &#123; return 5 &#125; func write(a: String) &#123; print(&quot;writing \\(a)&quot;) &#125;&#125; 关于associatedtype对于其他语言大多都使用直接指定类型&lt;T&gt;的方式声明泛型，而swift为什么还要搞出一个associatedtype呢，这篇文章有分析：http://www.cocoachina.com/swift/20160726/17188.html 使用关联类型，类似于类型当成成员属性使用，可以解耦依赖，如果需要使用对象的关联的类型，而类型与当前对象并没有直接关系，则通过成员的关联类型引用可以避免直接依赖对象类型，如下例子：机动车(Automobile)、燃料(Fuel)、尾气(Exhaust) 1234567891011121314151617/// 机动车public protocol Automobile &#123; associatedtype FuelType associatedtype ExhaustType func drive(fuel: FuelType) -&gt; ExhaustType&#125;/// 燃料public protocol Fuel &#123; associatedtype ExhaustType func consume() -&gt; ExhaustType&#125;/// 尾气public protocol Exhaust &#123; func emit()&#125; 实现 123456789101112131415161718public struct UnleadedGasoline: Fuel &#123; public func consume() -&gt; E &#123; print(&quot;consuming unleaded gas...&quot;) return E() &#125;&#125;public struct CleanExhaust: Exhaust &#123; public func emit() &#123; print(&quot;this is some clean exhaust...&quot;) &#125;&#125;public class Car: Automobile &#123; public func drive(fuel: F) -&gt; E &#123; return fuel.consume() &#125;&#125; 实际依赖关系：机动车 -&gt; 燃料燃料 -&gt; 尾气 但是代码有个问题是在定义Car的时候，必须声明尾气的类型E，而实际上机动车是不依赖于尾气的类型的，尾气的类型取决于燃料，如果Car支持两种燃料FuelA和FuelB，而两种燃料产生的尾气E1和E2，drive方法无法同时满足，只能定义两个方法 123456789public class Car: Automobile &#123; public func drive(fuel: F1) -&gt; E1 &#123; return fuel.consume() &#125; public func drive(fuel: F2) -&gt; E2 &#123; return fuel.consume() &#125;&#125; 如果使用关联类型的话可以解决这个问题，把尾气关联到燃料上 12345public class Car: Automobile &#123; public func drive(fuel: F) -&gt; F.ExhaustType &#123; return fuel.consume() &#125;&#125; 以上就是Swift泛型的全部要点","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://zhengbomo.github.io/tags/Swift/"}]},{"title":"block学习笔记","slug":"block-start","date":"2017-07-02T16:22:13.000Z","updated":"2017-07-02T16:22:13.000Z","comments":true,"path":"2017-07-03/block-start/","link":"","permalink":"http://zhengbomo.github.io/2017-07-03/block-start/","excerpt":"引用计数内存管理 所有的对象都存放在堆上，需要手动管理内存 iOS内存管理通过retainCount进行管理，通过引用计数+&#x2F;-1来控制内存的的声明周期，通常来说，我们在一个代码块中，我们会对需要用到的对象的引用计数+1，在离开代码块时，对引用计数-1，通过这种机制，我们只需要关心在我们的代码中需要的时候retain，不需要的时候release，而不用关心对象什么时候释放，当引用计数为0，即之后再也没有对该内存的引用，对象内存就会被释放，这个由系统框架来做","text":"引用计数内存管理 所有的对象都存放在堆上，需要手动管理内存 iOS内存管理通过retainCount进行管理，通过引用计数+&#x2F;-1来控制内存的的声明周期，通常来说，我们在一个代码块中，我们会对需要用到的对象的引用计数+1，在离开代码块时，对引用计数-1，通过这种机制，我们只需要关心在我们的代码中需要的时候retain，不需要的时候release，而不用关心对象什么时候释放，当引用计数为0，即之后再也没有对该内存的引用，对象内存就会被释放，这个由系统框架来做 autorelease与runlooprunloop在每一个调用周期（消息循环）外部都会添加一个autoreleasepool，对于autorelease的对象，并不是在离开作用域就马上释放的，而是在离开autoreleasepool的时候才被释放 1234567891011121314151617@property (nonatomic, weak) NSArray *array1;@property (nonatomic, weak) NSArray *array2;- (IBAction)btnClick:(id)sender &#123; [self test]; NSLog(@&quot;%@&quot;, self.array1); // 这里可以打印出来array1对象的值 NSLog(@&quot;%@&quot;, self.array2); // 这里打印出来array2为nil&#125;- (void)test &#123; self.array1 = [NSMutableArray arrayWithObjects:@1, @2, @3, nil]; // 1. self.array1指向的对象是用autorelease修饰的 // 2. 虽然array使用weak修饰的，但是离开了test方法，array依然不会被释放，直到离开当前的autoreleasepool NSMutableArray *array = [[NSMutableArray alloc] initWithObjects:@1, @2, @3, nil]; self.array2 = array;&#125; 函数与blockblock就是对闭包的实现，block的本质其实就是函数，只是在函数的基础上加上了捕获变量列表编译之后会变成一个结构体，包含捕获参数，和函数指针，后面我们看看block编译之后的代码 block的编译1. 不捕获变量先定义一个test.m文件 123456789#include &lt;stdio.h&gt;int main() &#123; void (^blk)(void) = ^&#123; printf(&quot;Block\\n&quot;); &#125;; blk(); return 0;&#125; 通过clang命令生成预编译后的代码 1clang -rewrite-objc test.m 生成如下代码 12345678910111213141516171819202122232425262728293031323334353637383940// block类描述，相当于OC的类描述struct __block_impl &#123; void *isa; int Flags; int Reserved; void *FuncPtr;&#125;;// block实现的结构体，可以看成__block_impl的子类struct __main_block_impl_0 &#123; struct __block_impl impl; // block类的描述 struct __main_block_desc_0* Desc; // block的描述 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123; // 结构体构造方法 impl.isa = &amp;_NSConcreteStackBlock; // block的类型，共有3种 impl.Flags = flags; impl.FuncPtr = fp; // block的实现，最后被赋值为block编译后的方法 Desc = desc; // block描述 &#125;&#125;;// block的描述，描述block实现的结构体的大小（框架用，我们用不到）static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;// block方法实现static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; printf(&quot;Block\\n&quot;);&#125;int main() &#123; // 1. 构造block结构体__main_block_impl_0，并且结构体存放在栈上的 void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA)); // 2. 通过__main_block_impl_0.FuncPtr调用block指向的方法 ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk); return 0;&#125; 可以看到，block被编译成一个静态方法，和一个block描述的结构体 2. 捕获不可变变量12345678910111213#include &lt;stdio.h&gt;#import &lt;Foundation/Foundation.h&gt;int main() &#123; NSObject *obj = [[NSObject alloc] init]; int a = 10; void (^blk)(void) = ^&#123; printf(&quot;Block：%d\\n&quot;, a); NSLog(@&quot;%@&quot;, obj); &#125;; blk(); return 0;&#125; 编译之后的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// __block_impl 一样// 生成的__main_block_impl_0多了一个捕获字段a和对象objstruct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int a; NSObject *obj; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, NSObject *_obj, int flags=0) : a(_a), obj(_obj) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;// block的实现方法，通过__cself拿到捕获的变量static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; // 这里通过block捕获的结构体引用a字段 int a = __cself-&gt;a; // bound by copy NSObject *obj = __cself-&gt;obj; // bound by copy printf(&quot;Block：%d\\n&quot;, a); NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_h8_fm423vjj5mlgb636xh5b44n80000gn_T_test_e9e5ff_mi_0, obj);&#125;// block描述多了两个变量，copy和dispose方法，用于持有和释放block捕获的对象static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;int main() &#123; // 1. 声明自由变量 NSObject *obj = ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;)); int a = 10; // 2. 构造block结构体__main_block_impl_0，并且结构体存放在栈上 void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a, obj, 570425344)); // 3. 通过__main_block_impl_0.FuncPtr调用block指向的方法 ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk); return 0;&#125; 这里用到了一个对象obj，__main_block_desc_0多了两个方法（__main_block_copy_0, __main_block_dispose_0），用于持有和释放block捕获的对象，如果只有int，没有对对象的捕获，则不会生成这两个成员 3. 捕获可变变量12345678910#include &lt;stdio.h&gt;int main() &#123; __block int a = 10; void (^blk)(void) = ^&#123; printf(&quot;Block：%d\\n&quot;, a); &#125;; blk(); return 0;&#125; 编译后 12345678910111213141516171819202122232425262728293031// 新增一个结构体，对可变成员进行包装struct __Block_byref_a_0 &#123; void *__isa; __Block_byref_a_0 *__forwarding; int __flags; int __size; int a; // 原来的成员&#125;;// block实现，捕获的成员不是int a, 而是__Block_byref_a_0 *a, 其实就是`__block`修饰的成员包装成对象了struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_a_0 *a; // by ref // 这里是捕获的成员，与上面一样 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, int flags=0) : a(_a-&gt;__forwarding) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;int main() &#123; // 1. 创建__Block_byref_a_0包装原来的成员a __attribute__((__blocks__(byref))) __Block_byref_a_0 a = &#123;(void*)0,(__Block_byref_a_0 *)&amp;a, 0, sizeof(__Block_byref_a_0), 10&#125;; // 2. 同上面捕获的 void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344)); ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk); return 0;&#125; block捕获可变对象其实与捕获普通变量一样，只是对原有变量包装成一个新的对象而已 4. 捕获static变量这里例子就省了，直接上结论 如果是局部static变量，block会当成普通局部变量一样处理，即会捕获该局部变量 如果是全局static变量，block会直接使用该全局变量，不进行变量捕获处理 block类型上面我们看到的block的实现__main_block_impl_0包含一个_isa字段，用于标识block的类型，block有三种类型 _NSConcreteStackBlock：存放在Stack上 _NSConcreteGlobalBlock：与全局变量一样，存放在全局区 _NSConcreteMallocBlock：存放在堆上 看下面三种代码 12345678910111213141516171819202122typedef long (^BlkSum)(int, int);BlkSum blk1 = ^ long (int a, int b) &#123; return a + b;&#125;;// 当block不捕获外部变量，就会被声明成__NSGlobalBlockNSLog(@&quot;blk1 = %@&quot;, blk1); // blk1 = &lt;__NSGlobalBlock__: 0xce3347d0&gt;NSLog(@&quot;blk1 = %@&quot;, [blk1 copy]); // blk1 = &lt;__NSGlobalBlock__: 0xce3347d0&gt;int base = 100;BlkSum blk2 = ^ long (int a, int b) &#123; return base + a + b;&#125;;// 当block捕获外部变量，就会被声明成__NSStackBlock__NSLog(@&quot;blk2 = %@&quot;, blk2); // blk2 = &lt;__NSStackBlock__: 0xbfffddf8&gt;NSLog(@&quot;blk2 = %@&quot;, [blk2 copy]); // blk2 = &lt;__NSMallocBlock__: 0xbfffcef8&gt;BlkSum blk3 = [[blk2 copy] autorelease];NSLog(@&quot;blk3 = %@&quot;, blk3); // blk3 = &lt;__NSMallocBlock__: 0x902fda0&gt;NSLog(@&quot;blk3 = %@&quot;, [blk3 copy]); // blk3 = &lt;__NSMallocBlock__: 0x902fda0&gt; 当block存放在全局时，始终只有一份，调用copy&#x2F;retain&#x2F;release，返回的是同一个对象当block存放在栈上时，如果进行copy，block会被拷贝到堆上，调用retain或release无效当block存放在堆上时，如果进行copy&#x2F;retain&#x2F;release，内存管理与对象一样，引用计数+&#x2F;-1 上面是MRC的行为，而在ARC上即使是block没有进行拷贝，也会被拷贝到堆上，所以在ARC上的block只有堆区和全局区，在ARC上，如果block会自动在需要的时候进行copy，如block作为返回值时，block作为参数传给另一个函数时 前向引用当我们在block使用可变变量__block的时候，编译器会生成__Block_byref_a_0内部有一个__forwarding字段指向自己 1234567struct __Block_byref_a_0 &#123; void *__isa; __Block_byref_a_0 *__forwarding; // 指向自己 int __flags; int __size; int a; // 原来的成员&#125;; 为什么要用一个变量指向自己，看下面这个例子 123456789&#123; __block int val = 0; void (^blk)(void) = [^&#123; ++val; &#125; copy]; ++val; blk(); NSLog(@&quot;%d&quot;, val);&#125; 根据上面编译的代码，我们可以分析转换成的代码大致如下 12345678910111213141516171819&#123; // 1. 创建byref对象包装int val __Block_byref_a_0 val; // 2. 创建block对象__main_block_impl_0，这个时候block是存放在栈上的 __main_block_impl_0 blk = __main_block_impl_0(...) // 3. 拷贝block，返回新的block，新的block存放在堆上 __main_block_impl_0 newBlk = _Block_copy(blk) // 对变量＋1 ++(val-&gt;__forwarding-&gt;val) // 调用函数 newBlk-&gt;FuncP(); // 打印 NSLog(@&quot;%d&quot;, val);&#125; 上面有两个block（blk和newBlk）一个存放在栈上，一个存放在堆上上面也有两个__Block_byref_a_0，当进行拷贝时，栈上的val也会被拷贝一份到堆上 当离开函数作用域时，栈上的内存会被释放，所以当block从栈拷贝到堆上时，会把堆上变量的__forwarding指针，指向堆，故后面及时我们使用局部变量val，实际上内部使用的已经是拷贝到堆上的变量了，这时候和block内部使用的变量是统一变量 循环引用常见问题 NSTimer：https://blog.bombox.org/2017-05-08/nstimer-notes/ CADisplayLink: 注意事项和用法与NSTimer类似 block：任何使用block的地方都需要考虑几个问题 是否造成循环引用 对于异步操作是否因为强持有导致延后释放（例如网路请求） 除了self，被self强持有的变量也会导致循环引用 多层循环引用","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"},{"name":"block","slug":"block","permalink":"http://zhengbomo.github.io/tags/block/"}]},{"title":"NSTimer学习笔记","slug":"nstimer-notes","date":"2017-05-08T06:22:13.000Z","updated":"2017-05-08T06:22:13.000Z","comments":true,"path":"2017-05-08/nstimer-notes/","link":"","permalink":"http://zhengbomo.github.io/2017-05-08/nstimer-notes/","excerpt":"NSTimer是iOS最常用的定时器工具之一，在使用的时候常常会遇到各种各样的问题，最常见的是内存泄漏，通常我们使用NSTimer的一般流程是这样的 在ViewController初始化或加载的地方创建NSTimer，并且通过属性持有（为了关闭） 在ViewController的dealloc方法关闭定时器（invalidate），并且把NSTimer置为nil 上面做法可能会造成内存泄漏，invalidate方法通常不能放在NStimer.target.dealloc里面，因为NSTimer会对target强引用，而如果target对NSTimer强引用就会造成循环引用","text":"NSTimer是iOS最常用的定时器工具之一，在使用的时候常常会遇到各种各样的问题，最常见的是内存泄漏，通常我们使用NSTimer的一般流程是这样的 在ViewController初始化或加载的地方创建NSTimer，并且通过属性持有（为了关闭） 在ViewController的dealloc方法关闭定时器（invalidate），并且把NSTimer置为nil 上面做法可能会造成内存泄漏，invalidate方法通常不能放在NStimer.target.dealloc里面，因为NSTimer会对target强引用，而如果target对NSTimer强引用就会造成循环引用 1. 构造函数NSTimer只有被添加的Runloop才能生效，NSTimer有下面两种类型的构造函数 initWithFireDate timerWithTimeInterval scheduledTimerWithTimeInterval scheduledTimerWithTimeInterval除了构造timer，还会把timer添加到当前线程的runloop，所以我们通常使用scheduledTimerWithTimeInterval构造NSTimer而不是timerWithTimeInterval 没有添加到runloop的timer，调用fire的时候会直接触发，并且只触发一次（如果repeat:YES） 12345678910111213141516171819202122232425262728- (void)viewDidLoad &#123; [super viewDidLoad]; [self timer1]; //[self timer2]; //[self timer3]; //[self timer4];&#125;- (void)timer1 &#123; self.timer = [NSTimer timerWithTimeInterval:2 target:self selector:@selector(timerTest:) userInfo:nil repeats:YES]; // 不会触发&#125;- (void)timer2 &#123; self.timer = [NSTimer timerWithTimeInterval:2 target:self selector:@selector(timerTest:) userInfo:nil repeats:YES]; // 正常触发 [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSDefaultRunLoopMode];&#125;- (IBAction)invalidate:(id)sender &#123; [self.timer invalidate]; self.timer = nil;&#125;- (void)timerTest:(NSObject *)obj &#123; NSLog(@&quot;time fire&quot;);&#125; 如果使用timerWithTimeInterval或initWithFireDate构造，需要手动添加到runloop上，使用scheduledTimerWithTimeInterval则不需要 12345678910- (void)timer3 &#123; self.timer = [[NSTimer alloc] initWithFireDate:[NSDate dateWithTimeIntervalSinceNow:3] interval:3 target:self selector:@selector(timerTest:) userInfo:nil repeats:YES]; // 需要添加到runloop才能触发 [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSDefaultRunLoopMode];&#125;- (void)timer4 &#123; // 自动添加到runloop self.timer = [NSTimer scheduledTimerWithTimeInterval:2 target:self selector:@selector(timerTest:) userInfo:nil repeats:YES];&#125; 2. NSTimer的触发 NSTimer在添加到runloop时，timer开始计时，即使runloop没有开启（run），在构造NSTimer的时候，如果不是马上开始计时，可以先使用timerWithTimeInterval再手动加入runloop上 调用fire的时候，立即触发timer的方法，该方法触发不影响计时器原本的计时，只是新增一次触发 当NSTimer进入后台的时，NSTimer计时暂停，进入前台继续 3. NSTimer和Runloop上面构造函数我们可以看到，当我们把timer添加到runloop的时候会指定NSRunLoopMode（scheduledTimerWithTimeInterval默认使用NSDefaultRunLoopMode），iOS支持的有下面两种模式 NSDefaultRunLoopMode：默认的运行模式，用于大部分操作，除了NSConnection对象事件。 NSRunLoopCommonModes：是一个模式集合，当绑定一个事件源到这个模式集合的时候就相当于绑定到了集合内的每一个模式。 下面三种是内部框架支持（AppKit） NSConnectionReplyMode：用来监控NSConnection对象的回复的，很少能够用到。 NSModalPanelRunLoopMode：用于标明和Mode Panel相关的事件。 NSEventTrackingRunLoopMode：用于跟踪触摸事件触发的模式（例如UIScrollView上下滚动）。 当timer添加到主线程的runloop时，某些UI事件（如：UIScrollView的拖动操作）会将runloop切换到NSEventTrackingRunLoopMode模式下，在这个模式下，NSDefaultRunLoopMode模式注册的事件是不会被执行的，也就是通过scheduledTimerWithTimeInterval方法添加到runloop的NSTimer这时候是不会被执行的 为了让NSTimer不被UI事件干扰，我们需要将注册到runloop的timer的mode设为NSRunLoopCommonModes，这个模式等效于NSDefaultRunLoopMode和NSEventTrackingRunLoopMode的结合 123// 主线程self.timer = [NSTimer timerWithTimeInterval:2 target:self selector:@selector(timerTest:) userInfo:nil repeats:YES];[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes]; 4. 循环引用循环引用是最经常遇到的问题之一 NSTimer在构造函数会对target强引用，在调用invalidate时，会移除去target的强引用 123456789NSLog(@&quot;Retain count is %ld&quot;, CFGetRetainCount((__bridge CFTypeRef)self));NSTimer *timer = [NSTimer timerWithTimeInterval:2 target:self selector:@selector(timerTest:) userInfo:@&quot;ghi&quot; repeats:YES];NSLog(@&quot;Retain count is %ld&quot;, CFGetRetainCount((__bridge CFTypeRef)self));[timer invalidate];NSLog(@&quot;Retain count is %ld&quot;, CFGetRetainCount((__bridge CFTypeRef)self)); 输出如下 1232017-05-09 10:41:45.071 NSTimerTest[6861:914021] Retain count is 62017-05-09 10:41:46.056 NSTimerTest[6861:914021] Retain count is 72017-05-09 10:41:47.848 NSTimerTest[6861:914021] Retain count is 6 NSTimer被加到Runloop的时候，会被runloop强引用持有，在调用invalidate的时候，会从runloop删除 1234567891011NSTimer *timer = [NSTimer timerWithTimeInterval:2 target:self selector:@selector(timerTest:) userInfo:@&quot;ghi&quot; repeats:YES];NSLog(@&quot;Retain count is %ld&quot;, CFGetRetainCount((__bridge CFTypeRef)timer));[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];NSLog(@&quot;Retain count is %ld&quot;, CFGetRetainCount((__bridge CFTypeRef)timer));[timer invalidate];NSLog(@&quot;Retain count is %ld&quot;, CFGetRetainCount((__bridge CFTypeRef)timer)); 输出如下 1232017-05-09 09:37:30.573 NSTimerTest[6505:883666] Retain count is 12017-05-09 09:37:33.177 NSTimerTest[6505:883666] Retain count is 22017-05-09 09:38:19.111 NSTimerTest[6505:883666] Retain count is 1 当定时器是不重复的（repeat&#x3D;NO），在执行完触发函数后，会自动调用invalidate解除runloop的注册和接触对target的强引用 由于NSTimer被加到runloop的时候会被runloop强引用，故如果使用scheduledTimerWithTimeInterval构造函数时，我们可以在viewcontroller使用weak引用NSTimer 123456789101112131415@property (nonatomic, weak) NSTimer *timer;...- (void)viewDidLoad &#123; [super viewDidLoad]; // 由于timer会被当前线程的runloop持有，故可以使用weak引用，而当调用invalidate时，self.timer会被自动置为nil self.timer = [NSTimer scheduledTimerWithTimeInterval:2 target:self selector:@selector(timerTest:) userInfo:nil repeats:YES]; // 或者 NSTimer *timer2 = [NSTimer timerWithTimeInterval:2 target:self selector:@selector(timerTest:) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] addTimer:timer2 forMode:NSDefaultRunLoopMode]; self.timer = timer;&#125; 所以通常我们不能在dealloc方法让[timer invalidate], 因为timer在invalidate之前，会引用self（通常是ViewController），导致self无法释放，可以在viewDidDisappear或显式调用timer的invalidate方法 invalidate是唯一让timer从runloop删除的方法，也是唯一去除对target强引用的方法 5. 多线程如果我们不在主线程使用Timer的时候，即使我们把timer添加到runloop，也不能被触发，因为主线程的runloop默认是开启的，而其他线程的runloop默认没有实现runloop，并且在后台线程使用NSTimer不能通过fire启动定时器，只能通过runloop不断的运行下去 1234567891011121314151617- (void)viewDidLoad &#123; [super viewDidLoad]; // 使用新线程 [NSThread detachNewThreadSelector:@selector(startNewThread) toTarget:self withObject:nil];&#125;- (void)startNewThread &#123; self.timer = [NSTimer timerWithTimeInterval:2 target:self selector:@selector(timerTest:) userInfo:nil repeats:YES]; // 添加到runloop NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addTimer:self.timer forMode:NSDefaultRunLoopMode]; // 非主线程需要手动运行runloop，run方法会阻塞，直到没有输入源的时候返回（例如：timer从runloop中移除，invalidate） [runLoop run]&#125; 6. NSTimer准确性通常我们使用NSTimer的时候都是在主线程使用的，主线程负责很多复杂的操作，例如UI处理，UI时间响应，并且iOS上的主线程是优先响应UI事件的，而NSTimer的优先级较低，有时候NSTimer的触发并不准确，例如当我们在滑动UIScrollView的时候，NSTimer就会延迟触发，主线优先响应UI的操作，只有UIScrollView停止了才触发NSTimer的事件解决方案NSTimer加入到runloop默认的Mode为NSDefaultRunLoopMode， 我们需要手动设置Mode为NSRunLoopCommonModes这时候，NSTimer即使在UI持续操作过程中也能得到触发，当然，会降低流畅度 NSTimer触发是不精确的，如果由于某些原因错过了触发时间，例如执行了一个长时间的任务，那么NSTimer不会延后执行，而是会等下一次触发，相当于等公交错过了，只能等下一趟车，tolerance属性可以设置误差范围 123NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:2 target:self selector:@selector(timerTest:) userInfo:nil repeats:YES];// 误差范围1s内timer.tolerance = 1; 如果对精度有要求，可以使用GCD的定时器 7 NSTimer暂停&#x2F;继续NSTimer不支持暂停和继续，如果需要可以使用GCD的定时器 8. 后台运行NSTimer不支持后台运行（真机），但是模拟器上App进入后台的时候，NSTimer还会持续触发 如果需要后台运行可以通过下面两种方式支持 让App支持后台运行（运行音频）（在后台可以触发） 记录离开和进入App的时间，手动控制计时器（在后台不能触发） 第一种控制起来比较麻烦，通常建议手动控制，不在后台触发计时 9. performSelectorNSObject对象有一个performSelector可以用于延迟执行一个方法，其实该方法内部是启用一个Timer并添加到当前线程的runloop，原理与NSTimer一样，所以在非主线程使用的时候，需要保证线程的runloop是运行的，否则不会得到执行 如下 1234567891011121314- (void)viewDidLoad &#123; [super viewDidLoad]; [NSThread detachNewThreadSelector:@selector(startNewThread) toTarget:self withObject:nil];&#125;- (void)startNewThread &#123; // test方法不会触发，因为runloop默认不开启 [self performSelector:@selector(test) withObject:nil afterDelay:1];&#125;- (void)test &#123; NSLog(@&quot;test trigger&quot;);&#125; 10. 总结总的来说使用NSTimer有两点需要注意 NSTimer只有被注册到runloop才能起作用，fire不是开启定时器的方法，只是触发一次定时器的方法 NSTimer会强引用target invalidate取消runloop的注册和target的强引用，如果是非重复的定时器，则在触发时会自动调用invalidate 通常我们自己封装GCD定时器使用起来更为方便，不会有这些问题","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"}]},{"title":"python-pip-upgrade","slug":"python-pip-upgrade","date":"2017-04-27T06:52:45.000Z","updated":"2017-04-27T06:52:45.000Z","comments":true,"path":"2017-04-27/python-pip-upgrade/","link":"","permalink":"http://zhengbomo.github.io/2017-04-27/python-pip-upgrade/","excerpt":"","text":"升级单个类库1$ pip install --upgrade flask 升级所有类库由于pip不支持批量操作，这里通过python代码升级 12345import pipfrom subprocess import callfor dist in pip.get_installed_distributions(): call(&quot;pip install --upgrade &quot; + dist.project_name, shell=True) 导出已安装的类库配置1$ pip freeze &gt; requirements.txt 安装类库配置1$ pip install -r requirements.txt","categories":[{"name":"python","slug":"python","permalink":"http://zhengbomo.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://zhengbomo.github.io/tags/python/"}]},{"title":"flask+nginx+gunicorn部署","slug":"flask-nginx-gunicorn-deploy","date":"2016-11-02T02:43:09.000Z","updated":"2016-11-02T02:43:09.000Z","comments":true,"path":"2016-11-02/flask-nginx-gunicorn-deploy/","link":"","permalink":"http://zhengbomo.github.io/2016-11-02/flask-nginx-gunicorn-deploy/","excerpt":"最近学习了flask，准备把flask部署到服务器上，这里记录部署的过程和期间遇到的一些问题","text":"最近学习了flask，准备把flask部署到服务器上，这里记录部署的过程和期间遇到的一些问题 一、安装1. flask我们建立一个最简单的flask应用，目录如下 1234/home/ubuntu/python/flask www app run.py 为run.py模块添加一个helloworld示例代码 123456789from flask import Flaskapp = Flask(__name__)@app.route(&quot;/&quot;)def hello(): return &quot;Hello World!&quot;if __name__ == &quot;__main__&quot;: app.run() 通常我们的应用是放在virtualenv环境下的，这里我的虚拟环境路径为 1$ cd /home/ubuntu/python/env 2. nginxnginx不用多介绍，高性能web服务器，通常用来在前端做反向代理服务器，下面是安装 123# 先更新一下源$ sudo apt-get update$ sudo apt-get install nginx 安装完成后重启nginx服务 12345$ sudo service nginx restart# 其他命令$ sudo service nginx stop$ sudo service nginx restart 就可以通过ip访问了，如果是外网并绑定了域名，也可以通过域名访问，nginx默认访问的是/usr/share/nginx/html这个文件 3. gunicornflask自带的服务器只适合在开发调试时候用，并不能满足性能的要求，我们这里采用 gunicorn做wsgi容器，用来部署python，安装很简单，进入虚拟环境安装，使用pip安装 1(env) $ sudo pip install gunicorn 安装完后运行 123# 先进到目录(env) $ cd /home/ubuntu/python/flask/www/app(env) $ gunicorn -w 4 -b 127.0.0.1:8080 run:app 后面的run:app的run表示模块，app表示模块里面的对象，即Flask实例，接着就可以访问了：http://127.0.0.1:8080 二、配置gunicorn到nginx1. 配置nginx修改nginx默认配置之前，我们先备份一下 1$ sudo cp /etc/nginx/site-avalidable/default /etc/nginx/site-avalidable/default.bak 修改配置 1$ sudo vim /etc/nginx/site-avalidable/default 内容如下 1234567891011121314server &#123; listen 80 default_server; listen [::]:80 default_server; # 这是HOST机器的外部域名，用地址也行 server_name example.org; location / &#123; # 这里是指向 gunicorn host 的服务地址 proxy_pass http://127.0.0.1:8080; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125; 配置完重启nginx 1$ sudo service nginx restart 当访问ip或域名的时候，nginx会自动代理到http://127.0.0.1:8080，即gunicorn服务 2. 将gunicorn作为系统服务启动上面配置完成后需要启动gunicorn才能看到hello world页面，我们需要让gunicorn在后台运行，而不是在控制台手动启动 2.1 Ubuntu15.04系统版本以上由于这里用到了virtualenv，为了减少一些配置的问题，这里我把gunicorn服务的启动包装到一个myflask.sh文件里面 12345678910111213#!/bin/sh# 进入主目录cd /home/ubuntu/python/# 进入virtualenv环境source env/bin/activate;# 进入flask项目目录cd flask/www/app;# 启动gunicorn服务gunicorn -w 4 -b 127.0.0.1:8080 run:app; 这里我用的是Ubuntu16.04，需要通过systemd来配置系统服务，我们先定义一个服务配置myflask.service 12345678910[Unit]Description=The myflask serviceAfter=network.target[Service]WorkingDirectory=/home/ubuntu/python/flask/www/appExecStart=/bin/bash myflask.shRestart=always[Install]WantedBy=multi-user.target 拷贝服务到/etc/systemd/system/目录下 1$ sudo cp myflask.service /etc/systemd/system/myflask.service 启动服务 1234567891011121314151617# 重载所有修改过的配置文件$ sudo systemctl daemon-reload# 启动服务$ sudo systemctl start myflask.service# 停止服务$ sudo systemctl stop myflask.service# 重启服务$ sudo systemctl restart myflask.service# 杀死一个服务的所有子进程$ sudo systemctl kill myflask.service# 查看服务的状态，可以看到一些错误$ sudo systemctl status myflask.service 启动完后访问成功 2.2 Ubuntu 15.05系统版本以下如果系统为12.04的版本，可以把服务配置文件加到/etc/init.d/目录中，服务配置myflaskserver如下 12345678910111213141516171819202122description &quot;The myflask service&quot;# 关于runlevel(运行级别)的更多说明，参见：http://www.cnblogs.com/dkblog/archive/2011/08/30/2160191.html# 在下面4种级别的时候开启start on runlevel [2345]# 在非下面4种级别的时候关闭stop on runlevel [!2345]respawnsetuid rootsetgid www-data# 设置虚拟环境路径env PATH= /home/ubuntu/python/env/bin# 修改当前目录chdir /home/ubuntu/python/flask/www/app# 执行gunicorn服务exec gunicorn -w 4 -b 127.0.0.1:8080 run:app 拷贝到/etc/init.d/目录 12345678$ sudo cp myflaskserver /etc/init.d/myflaskserver# 为文件添加可执行权限$ sudo chmod +x /etc/init.d/myflaskserver# 链接到启动目录，系统启动的时候会运行# S99表示优先级，系统核心服务用 0-19，20-39 是一般系统服务，40-59 好像是进行系统设置居多，60-79 是一些核心应用服务，80-99 就是最终用户接触的应用服务。$ sudo ln -sf /etc/init.d/myflaskserver /etc/rc3.d/S99myflaskserver","categories":[{"name":"python","slug":"python","permalink":"http://zhengbomo.github.io/categories/python/"}],"tags":[{"name":"flask","slug":"flask","permalink":"http://zhengbomo.github.io/tags/flask/"},{"name":"python","slug":"python","permalink":"http://zhengbomo.github.io/tags/python/"}]},{"title":"使用crontab运行python脚本","slug":"crontab-python","date":"2016-10-06T14:52:00.000Z","updated":"2023-06-11T03:02:51.863Z","comments":true,"path":"2016-10-06/crontab-python/","link":"","permalink":"http://zhengbomo.github.io/2016-10-06/crontab-python/","excerpt":"之前使用crontab经常遇到一些问题，例如脚本不执行的问题，报错问题，在这里记录一下过程，先介绍一个python工具，可以自动更改和生成crontab运行脚本，使用起来非常友好：plan","text":"之前使用crontab经常遇到一些问题，例如脚本不执行的问题，报错问题，在这里记录一下过程，先介绍一个python工具，可以自动更改和生成crontab运行脚本，使用起来非常友好：plan 一、安装1$ pip install plan 二、创建任务脚本1234567891011from plan import Plancron = Plan()# register one command, script or module# cron.command(&#x27;command&#x27;, every=&#x27;1.day&#x27;)# cron.script(&#x27;script.py&#x27;, path=&#x27;/web/yourproject/scripts&#x27;, every=&#x27;1.month&#x27;)# cron.module(&#x27;calendar&#x27;, every=&#x27;feburary&#x27;, at=&#x27;day.3&#x27;)if __name__ == &quot;__main__&quot;: cron.run() 也可以使用下面命令自动创建，会在schedule目录下生成一个schedule.py文件 123$ mkdir schedule$ cd schedule$ plan-quickstart 三、使用直接在crontab配置文件中使用执行python脚本遇到了好多坑，最后还是使用sh脚本来运行，我们在schedule目录下创建一个文件夹bash，新增一个sh脚本文件OneMinitesTask.sh 123456789101112#!/bin/sh# 当前路径为: schedule/bashcd ..;# 激活虚拟环境source env/bin/activate;# 执行python脚本python OneMinitesTask.py# 退出虚拟环境deactivate 创建完后我们还需要保证添加可执行权限 1$ chmod +x OneMinitesTask.sh 下面是schedule.py 1234567891011121314151617from plan import Plan# 获取bash路径（由于这里依赖于getcwd方法，所以要确保运行目录为当前目录）bash_path = os.path.abspath(os.path.join(os.getcwd(), &quot;bash&quot;))cron = Plan()# 添加一个任务，每分钟执行一次TenMinutesTask.sh脚本# 这里的every参数详细介绍见官网：http://plan.readthedocs.io/job_definition.html#everyjob = Job(&#x27;./OneMinutesTask.sh &gt; hello.txt&#x27;, path=bash_path, every=&#x27;1.minute&#x27;)# 添加到plan上，可以添加多个jobcron.job(job)if __name__ == &quot;__main__&quot;: # 输出到文件，覆盖原有的任务，这里还有其他的参数，详情见官网：http://plan.readthedocs.io/run_types.html cron.run(&#x27;white&#x27;) 运行脚本 123$ cd schedule$ python schedule.py[write] crontab file written 查看crontab任务 1234$ crontab -l# Begin Plan generated jobs for: main* * * * * cd /home/ubuntu/schedule/bash &amp;&amp; ./OneMinutesTask.sh# End Plan generated jobs for: main ok，测试运行成功，使用python脚本配置crontab运行脚本可读性更强，更好维护 四、常见问题1. 不确定任务是否运行，可以到/var/log/cron.log查看crontab的运行日志1$ vim /var/log/cron.log 使用Shift+G跳到最后一行 如果没有日志也可能是log服务没有开启，到/etc/rsyslog.d/50-default.conf查看cron.* /var/log/cron.log一行是否被注释掉了，如果注释掉了，把注释关了 1234sudo vim /etc/rsyslog.d/50-default.conf# 修改完后重启rsyslog$ sudo service rsyslog restart 2. 关闭crontab任务如果要关闭定时crontab，使用下面命令 12# 删除crontab任务，删除后通过crontab -l查看则提示无任务$ crontab -r 如果crontab的定时任务启动了，由于crontab只负责定时调用任务，crontab本身不支持任务的管理，如果需要关闭后台正在运行的任务，可以通过ps aux命令查看任务的PID，然后找到我们的任务，然后使用kill &#123;PID&#125;杀掉任务即可","categories":[{"name":"python","slug":"python","permalink":"http://zhengbomo.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://zhengbomo.github.io/tags/python/"},{"name":"crontab","slug":"crontab","permalink":"http://zhengbomo.github.io/tags/crontab/"}]},{"title":"2016学习书单","slug":"book-2016","date":"2016-09-20T16:06:30.000Z","updated":"2016-09-24T16:06:30.000Z","comments":true,"path":"2016-09-21/book-2016/","link":"","permalink":"http://zhengbomo.github.io/2016-09-21/book-2016/","excerpt":"最近拖延症又犯了，事情总是一拖再拖，一个人学习很容易堕落，在家里，一不小心，刷刷微博，看看新闻，一天就过去了，今年只剩下4个月了，想做的事情总是半途而废，虽然有时候很尽力去控制，但还是浪费了不少时间，下决心在剩余时间里，给自己定一些目标，计划+实施，定好时间点，这里记录一下今年需要看的书和计划","text":"最近拖延症又犯了，事情总是一拖再拖，一个人学习很容易堕落，在家里，一不小心，刷刷微博，看看新闻，一天就过去了，今年只剩下4个月了，想做的事情总是半途而废，虽然有时候很尽力去控制，但还是浪费了不少时间，下决心在剩余时间里，给自己定一些目标，计划+实施，定好时间点，这里记录一下今年需要看的书和计划 一、目标 学习python 完成PaiPaiDai自动化策略管理 学习scrapy，用scrapy框架写一个项目，并通过博客记录过程（十月之前） 学习flask，用flask写一个项目，并通过博客写出搭建过程（十一月之前） 学习机器学习常用分类器和训练算法，通过项目实战（十二月之前） 学一门乐器（布鲁斯口琴），每天练习20-30分钟 二、技术今年的目标以python为主，Web服务器，爬虫（简单数据挖掘+机器学习） 《FlaskWeb开发：基于Python的Web应用开发实战》 《编写高质量代码 改善Python程序的91个建议》 三、非技术 《纽约摄影学院教材-上》 《纽约摄影学院教材-下》 《黑客与画家》 《数学之美》 四、选读 《五行大义》：阴阳五行基础 《中国房地产到底该怎么办》 《亲密行为》 《牛奶可乐经济学》","categories":[{"name":"技术","slug":"技术","permalink":"http://zhengbomo.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"scrapy学习笔记","slug":"scrapy-start","date":"2016-09-11T08:56:45.000Z","updated":"2016-09-11T08:56:45.000Z","comments":true,"path":"2016-09-11/scrapy-start/","link":"","permalink":"http://zhengbomo.github.io/2016-09-11/scrapy-start/","excerpt":"scrapy是python最有名的爬虫框架之一，可以很方便的进行web抓取，并且提供了很强的定制型，这里记录简单学习的过程和在实际应用中会遇到的一些常见问题","text":"scrapy是python最有名的爬虫框架之一，可以很方便的进行web抓取，并且提供了很强的定制型，这里记录简单学习的过程和在实际应用中会遇到的一些常见问题 一、安装在安装scrapy之前有一些依赖需要安装，否则可能会安装失败，scrapy的选择器依赖于lxml，还有Twisted网络引擎，下面是ubuntu下安装的过程 1. linux下安装12345678910111213141516# 1. 安装xml依赖库$ sudo apt-get install libxml2 libxml2-dev$ sudo apt-get install libxslt1-dev$ sudo apt-get install python-libxml2# 2. 安装lxml$ sudo pip install lxml# 3. 安装Twisted（版本可以换成最新的），用pip也可以，如果失败的话下载源码安装，如下$ wget https://pypi.python.org/packages/6b/23/8dbe86fc83215015e221fbd861a545c6ec5c9e9cd7514af114d1f64084ab/Twisted-16.4.1.tar.bz2#md5=c6d09bdd681f538369659111f079c29d$ tar xjf Twisted-16.4.1.tar.bz2$ cd Twisted-16.4.1$ sudo python setup.py install# 3. 安装scrapy$ sudo pip install scrapy http://lxml.de/installation.html 2. Mac下安装12345# 安装xml依赖库$ xcode-select —install# 其实相关依赖pip会自动帮我们装上$ pip install scrapy mac下安装有时候会失败，建议使用virtualenv安装在独立的环境下，可以减少一些问题，因为mac系统自带python，例如一些依赖库依赖的一些新的版本，而升级新版本会把旧版本卸载掉，卸载可能会有权限的问题 二、基本使用1. 初始化scrapy项目我们可以使用命令行初始化一个项目 1$ scrapy startproject tutorial 这里可以查看scrapy更多其他的命令 初始化完成后，我们得到下面目录结构 123456scrapy.cfg: 项目的配置文件tutorial/: 该项目的python模块, 在这里添加代码 items.py: 项目中的item文件 pipelines.py: 项目中的pipelines文件. settings.py: 项目全局设置文件. spiders/ 爬虫模块目录 我们先看一下scrapy的处理流程图 scrapy由下面几个部分组成 spiders：爬虫模块，负责配置需要爬取的数据和爬取规则，以及解析结构化数据 items：定义我们需要的结构化数据，使用相当于dict pipelines：管道模块，处理spider模块分析好的结构化数据，如保存入库等 middlewares：中间件，相当于钩子，可以对爬取前后做预处理，如修改请求header，url过滤等 我们先来看一个例子，在spiders目录下新建一个模块DmozSpider.py 1234567891011121314151617import scrapyclass DmozSpider(scrapy.Spider): # 必须定义 name = &quot;dmoz&quot; # 初始urls start_urls = [ &quot;http://www.dmoz.org/Computers/Programming/Languages/Python/Books/&quot;, &quot;http://www.dmoz.org/Computers/Programming/Languages/Python/Resources/&quot; ] # 默认response处理函数 def parse(self, response): # 把结果写到文件中 filename = response.url.split(&quot;/&quot;)[-2] with open(filename, &#x27;wb&#x27;) as f: f.write(response.body) 打开终端进入根目录，执行下面命令 1$ scrapy crawl dmoz 爬虫开始爬取start_urls定义的url，并输出到文件中，最后输出爬去报告，会输出爬取得统计结果 1234567891011121314151617181920212223242016-09-13 10:36:43 [scrapy] INFO: Spider opened2016-09-13 10:36:43 [scrapy] INFO: Crawled 0 pages (at 0 pages/min), scraped 0 items (at 0 items/min)2016-09-13 10:36:43 [scrapy] DEBUG: Telnet console listening on 127.0.0.1:60232016-09-13 10:36:44 [scrapy] DEBUG: Crawled (200) &lt;GET http://www.dmoz.org/Computers/Programming/Languages/Python/Resources/&gt; (referer: None)2016-09-13 10:36:45 [scrapy] DEBUG: Crawled (200) &lt;GET http://www.dmoz.org/Computers/Programming/Languages/Python/Books/&gt; (referer: None)2016-09-13 10:36:45 [scrapy] INFO: Closing spider (finished)2016-09-13 10:36:45 [scrapy] INFO: Dumping Scrapy stats:&#123;&#x27;downloader/request_bytes&#x27;: 548, &#x27;downloader/request_count&#x27;: 2, &#x27;downloader/request_method_count/GET&#x27;: 2, &#x27;downloader/response_bytes&#x27;: 16179, &#x27;downloader/response_count&#x27;: 2, &#x27;downloader/response_status_count/200&#x27;: 2, &#x27;finish_reason&#x27;: &#x27;finished&#x27;, &#x27;finish_time&#x27;: datetime.datetime(2016, 9, 13, 2, 36, 45, 585113), &#x27;log_count/DEBUG&#x27;: 3, &#x27;log_count/INFO&#x27;: 7, &#x27;response_received_count&#x27;: 2, &#x27;scheduler/dequeued&#x27;: 2, &#x27;scheduler/dequeued/memory&#x27;: 2, &#x27;scheduler/enqueued&#x27;: 2, &#x27;scheduler/enqueued/memory&#x27;: 2, &#x27;start_time&#x27;: datetime.datetime(2016, 9, 13, 2, 36, 43, 935790)&#125;2016-09-13 10:36:45 [scrapy] INFO: Spider closed (finished) 这里我们完成了简单的爬取和保存的操作，会在根目录生成两个文件Resources和Books 2. 通过代码运行爬虫每次进入控制台运行爬虫还是比较麻烦的，而且不好调试，我们可以通过CrawlerProcess通过代码运行爬虫，新建一个模块run.py 12345678910111213141516from scrapy.crawler import CrawlerProcessfrom scrapy.utils.project import get_project_settingsfrom spiders.DmozSpider import DmozSpider# 获取settings.py模块的设置settings = get_project_settings()process = CrawlerProcess(settings=settings)# 可以添加多个spider# process.crawl(Spider1)# process.crawl(Spider2)process.crawl(DmozSpider)# 启动爬虫，会阻塞，直到爬取完成process.start() 参考：http://doc.scrapy.org/en/latest/topics/practices.html#run-scrapy-from-a-script 三、Scrapy类如上面的DmozSpider类，爬虫类继承自scrapy.Spider，用于构造Request对象给Scheduler 1. 常用属性与方法属性 name：爬虫的名字，必须唯一（如果在控制台使用的话，必须配置） start_urls：爬虫初始爬取的链接列表 parse：response结果处理函数 custom_settings：自定义配置，覆盖settings.py中的默认配置 方法 start_requests：启动爬虫的时候调用，默认是调用make_requests_from_url方法爬取start_urls的链接，可以在这个方法里面定制，如果重写了该方法，start_urls默认将不会被使用，可以在这个方法里面定制一些自定义的url，如登录，从数据库读取url等，本方法返回Request对象 make_requests_from_url：默认由start_requests调用，可以配置Request对象，返回Request对象 parse：response到达spider的时候默认调用，如果在Request对象配置了callback函数，则不会调用，parse方法可以迭代返回Item或Request对象，如果返回Request对象，则会进行增量爬取 2. Request与Response对象每个请求都是一个Request对象，Request对象定义了请求的相关信息（url, method, headers, body, cookie, priority）和回调的相关信息（meta, callback, dont_filter, errback），通常由spider迭代返回 其中meta相当于附加变量，可以在请求完成后通过response.meta访问 请求完成后，会通过Response对象发送给spider处理，常用属性有（url, status, headers, body, request, meta, ） 详细介绍参考官网 https://doc.scrapy.org/en/latest/topics/request-response.html#request-objects https://doc.scrapy.org/en/latest/topics/request-response.html#response-objects 看下面这个例子 1234567891011121314151617181920212223from scrapy import Spiderfrom scrapy import Requestclass TestSpider(Spider): name = &#x27;test&#x27; start_urls = [ &quot;http://www.qq.com/&quot;, ] def login_parse(self, response): &quot;&quot;&quot; 如果登录成功,手动构造请求Request迭代返回 &quot;&quot;&quot; print(response) for i in range(0, 10): yield Request(&#x27;http://www.example.com/list/1?page=&#123;0&#125;&#x27;.format(i)) def start_requests(self): &quot;&quot;&quot; 覆盖默认的方法(忽略start_urls),返回登录请求页,制定处理函数为login_parse &quot;&quot;&quot; return Request(&#x27;http://www.example.com/login&#x27;, method=&quot;POST&quot; body=&#x27;username=bomo&amp;pwd=123456&#x27;, callback=self.login_parse) def parse(self, response): &quot;&quot;&quot; 默认请求处理函数 &quot;&quot;&quot; print(response) 四、Selector上面我们只是爬取了网页的html文本，对于爬虫，我们需要明确我们需要爬取的结构化数据，需要对原文本进行解析，解析的方法通常有下面这些 普通文本操作 正则表达式：re Dom树操作：BeautifulSoup XPath选择器：lxml scrapy默认支持选择器的功能，自带的选择器构建与lxml之上，并对其进行了改进，使用起来更为简洁明了 1. XPath选择器XPpath是标准的XML文档查询语言，可以用于查询XML文档中的节点和内容，关于XPath语法，可以参见这里 先看一个例子，通过html或xml构造Selector对象，然后通过xpath查询节点，并解析出节点的内容 1234567from scrapy import Selectorhtml = &#x27;&lt;html&gt;&lt;body&gt;&lt;span&gt;good&lt;/span&gt;&lt;span&gt;buy&lt;/span&gt;&lt;/body&gt;&lt;/html&gt;&#x27;sel = Selector(text=html)nodes = sel.xpath(&#x27;//span&#x27;)for node in nodes: print(node.extract()) Selector相当于节点，通过xpath去到子节点集合（SelectorList），可以继续搜索，通过extract方法可以取出节点的值，extract方法也可以作用于SelectorList，对于SelectorList可以通过extract_first取出第一个节点的值 通过text()取出节点的内容 通过@href去除节点属性值（这里是取出href属性的值） 直接对节点取值，则是输出节点的字符串 2. CSS选择器除了XPath选择器，scrapy还支持css选择器 123456789101112131415161718192021222324html = &quot;&quot;&quot; &lt;html&gt; &lt;body&gt; &lt;span&gt;good&lt;/span&gt; &lt;span&gt;buy&lt;/span&gt; &lt;ul&gt; &lt;li class=&quot;video_part_lists&quot;&gt;aa&lt;li&gt; &lt;li class=&quot;video_part_lists&quot;&gt;bb&lt;li&gt; &lt;li class=&quot;audio_part_lists&quot;&gt;cc&lt;li&gt; &lt;li class=&quot;video_part_lists&quot;&gt; &lt;a href=&quot;/&quot;&gt;主页&lt;/a&gt; &lt;li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; &quot;&quot;&quot;sel = Selector(text=html)# 选择class为video_part_lists的li节点lis = sel.css(&#x27;li.video_part_lists&#x27;)for li in lis: # 选择a节点的属性 print(li.css(&#x27;a::attr(href)&#x27;).extract()) 关于css选择器更多的规则，可以见w3c官网 https://www.w3.org/TR/selectors/ 五、Item类上面我们只是爬取了网页的html文本，对于爬虫，我们需要明确我们需要爬取的结构化数据，我们定义一个item存储分类信息，scrapy的item继承自scrapy.Item 123456from scrapy import Item, Fieldclass DmozItem(Item): title = Field() link = Field() desc = Field() scrapy.Item的用法与python中的字典用法基本一样，只是做了一些安全限制，属性定义使用Field，这里只是进行了声明，而不是真正的属性，使用的时候通过键值对操作，不支持属性访问 what, 好坑爹，这意味着所有的属性赋值都得用字符串了，这里有解释（还是没太明白） why-is-scrapys-field-a-dict 修改DmozSpider的parse方法 123456789class DmozSpider(scrapy.Spider): ... def parse(self, response): for sel in response.xpath(&#x27;//ul/li&#x27;): dmoz_item = DmozItem() dmoz_item[&#x27;title&#x27;] = sel.xpath(&#x27;a/text()&#x27;).extract() dmoz_item[&#x27;link&#x27;] = sel.xpath(&#x27;a/@href&#x27;).extract() dmoz_item[&#x27;desc&#x27;] = sel.xpath(&#x27;text()&#x27;).extract() print(dmoz_item) 六、Pipelinespider负责爬虫的配置，item负责声明结构化数据，而对于数据的处理，在scrapy中使用管道的方式进行处理，只要注册过的管道都可以处理item数据（处理，过滤，保存） 下面看看管道的声明方式，这里定义一个预处理管道PretreatmentPipeline.py，如果item的title为None，则设置为空字符串 123456class PretreatmentPipeline(object): def process_item(self, item, spider): if item[&#x27;title&#x27;]: # 不让title为空 item[&#x27;title&#x27;] = &#x27;&#x27; return item 再定义一个过滤重复数据的管道DuplicatesPipeline.py，当link重复，则丢弃 12345678910111213from scrapy.exceptions import DropItemclass DuplicatesPipeline(object): def __init__(self): self.links = set() def process_item(self, item, spider): if item[&#x27;link&#x27;] in self.links: # 跑出DropItem表示丢掉数据 raise DropItem(&quot;Duplicate item found: %s&quot; % item) else: self.links.add(item[&#x27;link&#x27;]) return item 最后可以定义一个保存数据的管道，可以把数据保存到数据库中 123456789101112from scrapy.exceptions import DropItemfrom Database import Databaseclass DatabasePipeline(object): def __init__(self): self.db = Database def process_item(self, item, spider): if self.db.item_exists(item[&#x27;id&#x27;]): self.db.update_item(item) else: self.db.insert_item(item) 定义好管道之后我们需要配置到爬虫上，我们在settings.py模块中配置，后面的数字表示管道的顺序 1234ITEM_PIPELINES = &#123; &#x27;pipelines.DuplicatesPipeline.DuplicatesPipeline&#x27;: 1, &#x27;pipelines.PretreatmentPipeline.PretreatmentPipeline&#x27;: 2,&#125; 我们也可以为spider配置单独的pipeline 123456789class TestSpider(Spider): # 自定义配置 custom_settings = &#123; # item处理管道 &#x27;ITEM_PIPELINES&#x27;: &#123; &#x27;tutorial.pipelines.FangDetailPipeline.FangDetailPipeline&#x27;: 1, &#125;, &#125; ... 除了process_item方法外，pipeline还有open_spider和spider_closed两个方法，在爬虫启动和关闭的时候调用 七、Rule爬虫的通常需要在一个网页里面爬去其他的链接，然后一层一层往下爬，scrapy提供了LinkExtractor类用于对网页链接的提取，使用LinkExtractor需要使用CrawlSpider爬虫类中，CrawlSpider与Spider相比主要是多了rules，可以添加一些规则，先看下面这个例子，爬取链家网的链接 1234567891011121314151617181920212223from scrapy.spiders import CrawlSpider, Rulefrom scrapy.linkextractors import LinkExtractorclass LianjiaSpider(CrawlSpider): name = &quot;lianjia&quot; allowed_domains = [&quot;lianjia.com&quot;] start_urls = [ &quot;http://bj.lianjia.com/ershoufang/&quot; ] rules = [ # 匹配正则表达式,处理下一页 Rule(LinkExtractor(allow=(r&#x27;http://bj.lianjia.com/ershoufang/pg\\s+$&#x27;,)), callback=&#x27;parse_item&#x27;), # 匹配正则表达式,结果加到url列表中,设置请求预处理函数 # Rule(FangLinkExtractor(allow=(&#x27;http://www.lianjia.com/client/&#x27;, )), follow=True, process_request=&#x27;add_cookie&#x27;) ] def parse_item(self, response): # 这里与之前的parse方法一样，处理 pass 1. Rule对象Role对象有下面参数 link_extractor：链接提取规则 callback：link_extractor提取的链接的请求结果的回调 cb_kwargs：附加参数，可以在回调函数中获取到 follow：表示提取的链接请求完成后是否还要应用当前规则（boolean），如果为False则不会对提取出来的网页进行进一步提取，默认为False process_links：处理所有的链接的回调，用于处理从response提取的links，通常用于过滤（参数为link列表） process_request：链接请求预处理（添加header或cookie等） 2. LinkExtractorLinkExtractor常用的参数有： allow：提取满足正则表达式的链接 deny：排除正则表达式匹配的链接（优先级高于allow） allow_domains：允许的域名（可以是str或list） deny_domains：排除的域名（可以是str或list） restrict_xpaths：提取满足XPath选择条件的链接（可以是str或list） restrict_css：提取满足css选择条件的链接（可以是str或list） tags：提取指定标签下的链接，默认从a和area中提取（可以是str或list） attrs：提取满足拥有属性的链接，默认为href（类型为list） unique：链接是否去重（类型为boolean） process_value：值处理函数（优先级大于allow） 关于LinkExtractor的详细参数介绍见官网 注意：如果使用rules规则，请不要覆盖或重写CrawlSpider的parse方法，否则规则会失效，可以使用parse_start_urls方法 八、Middleware从最开始的流程图可以看到，爬去一个资源链接的流程，首先我们配置spider相关的爬取信息，在启动爬取实例后，scrapy_engine从Spider取出Request（经过SpiderMiddleware），然后丢给Scheduler（经过SchedulerMiddleware），Scheduler接着把请求丢给Downloader（经过DownloadMiddlware），Downloader把请求结果丢还给Spider，然后Spider把分析好的结构化数据丢给Pipeline，Pipeline进行分析保存或丢弃，这里面有4个角色 scrapy有下面三种middlewares SpiderMiddleware：通常用于配置爬虫相关的属性，引用链接设置，Url长度限制，成功状态码设置，爬取深度设置，爬去优先级设置等 DownloadMiddlware：通常用于处理下载之前的预处理，如请求Header（Cookie,User-Agent），登录验证处理，重定向处理，代理服务器处理，超时处理，重试处理等 SchedulerMiddleware（已经废弃）：为了简化框架，调度器中间件已经被废弃，使用另外两个中间件已经够用了 1. SpiderMiddleware爬虫中间件有下面几个方法 process_spider_input：当response通过spider的时候被调用，返回None（继续给其他中间件处理）或抛出异常（不会给其他中间件处理，当成异常处理） process_spider_output：当spider有item或Request输出的时候调动 process_spider_exception：处理出现异常时调用 process_start_requests：spider当开始请求Request的时候调用 下面是scrapy自带的一些中间件（在scrapy.spidermiddlewares命名空间下） UrlLengthMiddleware RefererMiddleware OffsiteMiddleware HttpErrorMiddleware DepthMiddleware 我们自己实现一个SpiderMiddleware 1TODO 参考链接：http://doc.scrapy.org/en/latest/topics/spider-middleware.html 2. DownloaderMiddleware下载中间件有下面几个方法 process_request：请求通过下载器的时候调用 process_response：请求完成后调用 process_exception：请求发生异常时调用 from_crawler：从crawler构造的时候调用 from_settings：从settings构造的时候调用 &#96;&#96; 更多详细的参数解释见这里 在爬取网页的时候，使用不同的User-Agent可以提高请求的随机性，定义一个随机设置User-Agent的中间件RandomUserAgentMiddleware 123456789101112131415161718192021import randomclass RandomUserAgentMiddleware(object): &quot;&quot;&quot;Randomly rotate user agents based on a list of predefined ones&quot;&quot;&quot; def __init__(self, agents): self.agents = agents # 从crawler构造，USER_AGENTS定义在crawler的配置的设置中 @classmethod def from_crawler(cls, crawler): return cls(crawler.settings.getlist(&#x27;USER_AGENTS&#x27;)) # 从settings构造，USER_AGENTS定义在settings.py中 @classmethod def from_settings(cls, settings): return cls(settings.getlist(&#x27;USER_AGENTS&#x27;)) def process_request(self, request, spider): # 设置随机的User-Agent request.headers.setdefault(&#x27;User-Agent&#x27;, random.choice(self.agents)) 在settings.py设置USER_AGENTS参数 123456789101112131415161718USER_AGENTS = [ &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)&quot;, &quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)&quot;, &quot;Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)&quot;, &quot;Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)&quot;, &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)&quot;, &quot;Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)&quot;, &quot;Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30)&quot;, &quot;Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0&quot;, &quot;Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5&quot;, &quot;Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11&quot;, &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20&quot;, &quot;Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52&quot;,] 配置爬虫中间件的方式与pipeline类似，第二个参数表示优先级 123456789101112# 配置爬虫中间件SPIDER_MIDDLEWARES = &#123; &#x27;myproject.middlewares.CustomSpiderMiddleware&#x27;: 543, # 如果想禁用默认的中间件的话，可以设置其优先级为None &#x27;scrapy.spidermiddlewares.offsite.OffsiteMiddleware&#x27;: None,&#125;# 配置下载中间件DOWNLOADER_MIDDLEWARES = &#123; &#x27;myproject.middlewares.RandomUserAgentMiddleware&#x27;: 543, &#x27;scrapy.contrib.downloadermiddleware.useragent.UserAgentMiddleware&#x27;: None,&#125; 3. 代理服务器爬虫最怕的就是封ip，这时候就需要代理服务器来爬取，scrapy设置代理服务器非常简单，只需要在请求前设置Request对象的meta属性，添加proxy值即可，通常我们可以通过中间件来做 1234class ProxyMiddleware(object): def process_request(self, request, spider): proxy = &#x27;https://178.33.6.236:3128&#x27; # 代理服务器 request.meta[&#x27;proxy&#x27;] = proxy 九、缓存scrapy默认已经自带了缓存的功能，通常我们只需要配置即可，打开settings.py 1234567891011121314# 打开缓存HTTPCACHE_ENABLED = True# 设置缓存过期时间（单位：秒）#HTTPCACHE_EXPIRATION_SECS = 0# 缓存路径(默认为：.scrapy/httpcache)HTTPCACHE_DIR = &#x27;httpcache&#x27;# 忽略的状态码，例如：302HTTPCACHE_IGNORE_HTTP_CODES = []# 缓存模式(文件缓存)HTTPCACHE_STORAGE = &#x27;scrapy.extensions.httpcache.FilesystemCacheStorage&#x27; 更多参数参见这里 十、多线程scrapy网络请求是基于Twisted，而Twisted默认支持多线程，而且scrapy默认也是通过多线程请求的，并且支持多核CPU的并发，通常只需要配置一些参数即可 1234567891011# 默认Item并发数：100CONCURRENT_ITEMS = 100# 默认Request并发数：16CONCURRENT_REQUESTS = 16# 默认每个域名的并发数：8CONCURRENT_REQUESTS_PER_DOMAIN = 8# 每个IP的最大并发数：0表示忽略CONCURRENT_REQUESTS_PER_IP = 0 更多参数参见这里 十一、常见问题1. 项目名称问题在使用的时候遇到过一个问题，在初始化scrapy startproject tutorial的时候，如果使用了一些特殊的名字，如：test, fang等单词的话，通过get_project_settings方法获取配置的时候会出错，改成tutorial或一些复杂的名字的时候不会 1ImportError: No module named tutorial.settings 这是一个bug，在github上有提到：https://github.com/scrapy/scrapy/issues/428，但貌似没有完全修复，修改一下名字就好了（当然scrapy.cfg和settings.py里面也需要修改） 2. 为每个pipeline配置spider上面我们是在settings.py里面配置pipeline，这里的配置的pipeline会作用于所有的spider，我们可以为每一个spider配置不同的pipeline，设置Spider的custom_settings对象 12345678class LianjiaSpider(CrawlSpider): ... # 自定义配置 custom_settings = &#123; &#x27;ITEM_PIPELINES&#x27;: &#123; &#x27;tutorial.pipelines.TestPipeline.TestPipeline&#x27;: 1, &#125; &#125; 3. 获取提取链接的节点信息通过LinkExtractor提取的scrapy.Link默认不带节点信息，有时候我们需要节点的其他attribute属性，scrapy.Link有个text属性保存从节点提取的text值，我们可以通过修改lxmlhtml._collect_string_content变量为etree.tostring，这样可以在提取节点值就变味渲染节点scrapy.Link.text，然后根据scrapy.Link.text属性拿到节点的html，最后提取出我们需要的值 123from lxml import etreeimport scrapy.linkextractors.lxmlhtmlscrapy.linkextractors.lxmlhtml._collect_string_content = etree.tostring 4. 从数据库中读取urls有时候我们已经把urls下载到数据库了，而不是在start_urls里配置，这时候可以重载spider的start_requests方法 123def start_requests(self): for u in self.db.session.query(User.link): yield Request(u.link) 我们还可以在Request添加元数据，然后在response中访问 123456def start_requests(self): for u in self.db.session.query(User): yield Request(u.link, meta=&#123;&#x27;name&#x27;: u.name&#125;)def parse(self, response): print(response.url, response.meta[&#x27;name&#x27;]) 5. 如何进行循环爬取有时候我们需要爬取的一些经常更新的页面，例如：间隔时间为2s，爬去一个列表前10页的数据，从第一页开始爬，爬完成后重新回到第一页 目前的思路是，通过parse方法迭代返回Request进行增量爬取，由于scrapy默认由缓存机制，需要修改 6. 关于去重scrapy默认有自己的去重机制，默认使用scrapy.dupefilters.RFPDupeFilter类进行去重，主要逻辑如下 1234567891011121314151617if include_headers: include_headers = tuple(to_bytes(h.lower()) for h in sorted(include_headers))cache = _fingerprint_cache.setdefault(request, &#123;&#125;)if include_headers not in cache: fp = hashlib.sha1() fp.update(to_bytes(request.method)) fp.update(to_bytes(canonicalize_url(request.url))) fp.update(request.body or b&#x27;&#x27;) if include_headers: for hdr in include_headers: if hdr in request.headers: fp.update(hdr) for v in request.headers.getlist(hdr): fp.update(v) cache[include_headers] = fp.hexdigest()return cache[include_headers] 默认的去重指纹是sha1(method + url + body + header)，这种方式并不能过滤很多，例如有一些请求会加上时间戳的，基本每次都会不同，这时候我们需要自定义过滤规则 1234567891011121314from scrapy.dupefilter import RFPDupeFilterclass CustomURLFilter(RFPDupeFilter): &quot;&quot;&quot; 只根据url去重&quot;&quot;&quot; def __init__(self, path=None): self.urls_seen = set() RFPDupeFilter.__init__(self, path) def request_seen(self, request): if request.url in self.urls_seen: return True else: self.urls_seen.add(request.url) 配置setting 1DUPEFILTER_CLASS = &#x27;tutorial.custom_filters.CustomURLFilter&#x27; 7. 如何在Pipeline中处理不同的Itemscrapy所有的迭代出来的的Item都会经过所有的Pipeline，如果需要处理不同的Item，只能通过isinstance()方法进行类型判断，然后分别进行处理，暂时没有更好的方案 8. url按顺序执行我们可以通过Request的priority控制url的请求的执行顺序，但由于网络请求的不确定性，不能保证返回也是按照顺序进行的，如果需要进行逐个url请求的话，吧url列表放在meta对象里面，在response的时候迭代返回下一个Request对象到调度器，达到顺序执行的目的，暂时没有更好的方案 十二、总结scrapy虽然是最有名的python爬虫框架，但是还是有很多不足，例如，item不能单独配置给制定的pipeline，每一个爬取的所有item都会走遍所有的管道，需要在管道里面去判断不同类型的item，如果在pipelines和items比较多的项目，将会让项目变得非常臃肿 如有问题欢迎到我的博客留言 十三、参考链接 官方文档 中文教程 scrapy五大模块","categories":[{"name":"python","slug":"python","permalink":"http://zhengbomo.github.io/categories/python/"}],"tags":[{"name":"scrapy","slug":"scrapy","permalink":"http://zhengbomo.github.io/tags/scrapy/"}]},{"title":"sqlalchemy学习笔记","slug":"sqlalchemy-start","date":"2016-09-11T04:17:15.000Z","updated":"2016-09-11T04:17:15.000Z","comments":true,"path":"2016-09-11/sqlalchemy-start/","link":"","permalink":"http://zhengbomo.github.io/2016-09-11/sqlalchemy-start/","excerpt":"SQLAlchemy是python的一个数据库ORM工具，提供了强大的对象模型间的转换，可以满足绝大多数数据库操作的需求，并且支持多种数据库引擎（sqlite，mysql，postgres, mongodb等），在这里记录基本用法和学习笔记","text":"SQLAlchemy是python的一个数据库ORM工具，提供了强大的对象模型间的转换，可以满足绝大多数数据库操作的需求，并且支持多种数据库引擎（sqlite，mysql，postgres, mongodb等），在这里记录基本用法和学习笔记 一、安装通过pip安装 1$ pip install SQLAlchemy 二、使用首先是连接到数据库，SQLALchemy支持多个数据库引擎，不同的数据库引擎连接字符串不一样，常用的有 1234mysql://username:password@hostname/databasepostgresql://username:password@hostname/databasesqlite:////absolute/path/to/databasesqlite:///c:/absolute/path/to/database 更多连接字符串的介绍参见这里 下面是连接和使用sqlite数据库的例子 1. connection使用传统的connection的方式连接和操作数据库 1234567891011121314from sqlalchemy import create_engine# 数据库连接字符串DB_CONNECT_STRING = &#x27;sqlite:///:memory:&#x27;# 创建数据库引擎,echo为True,会打印所有的sql语句engine = create_engine(DB_CONNECT_STRING, echo=True)# 创建一个connection，这里的使用方式与python自带的sqlite的使用方式类似with engine.connect() as con: # 执行sql语句，如果是增删改，则直接生效，不需要commit rs = con.execute(&#x27;SELECT 5&#x27;) data = rs.fetchone()[0] print &quot;Data: %s&quot; % data 与python自带的sqlite不同，这里不需要Cursor光标，执行sql语句不需要commit 2. connection事务使用事务可以进行批量提交和回滚 123456789101112131415from sqlalchemy import create_engine# 数据库连接字符串DB_CONNECT_STRING = &#x27;sqlite:////Users/zhengxiankai/Desktop/Document/db.sqlite&#x27;engine = create_engine(DB_CONNECT_STRING, echo=True)with engine.connect() as connection: trans = connection.begin() try: r1 = connection.execute(&quot;select * from User&quot;) r2 = connection.execute(&quot;insert into User(name, age) values(?, ?)&quot;, &#x27;bomo&#x27;, 24) trans.commit() except: trans.rollback() raise 3. sessionconnection是一般使用数据库的方式，sqlalchemy还提供了另一种操作数据库的方式，通过session对象，session可以记录和跟踪数据的改变，在适当的时候提交，并且支持强大的ORM的功能，下面是基本使用 12345678910111213141516171819from sqlalchemy import create_enginefrom sqlalchemy.orm import sessionmaker# 数据库连接字符串DB_CONNECT_STRING = &#x27;sqlite:////Users/zhengxiankai/Desktop/Document/db.sqlite&#x27;# 创建数据库引擎,echo为True,会打印所有的sql语句engine = create_engine(DB_CONNECT_STRING, echo=True)# 创建会话类DB_Session = sessionmaker(bind=engine)# 创建会话对象session = DB_Session()# dosomething with session# 用完记得关闭，也可以用withsession.close() 上面创建了一个session对象，接下来可以操作数据库了，session也支持通过sql语句操作数据库 123456session.execute(&#x27;select * from User&#x27;)session.execute(&quot;insert into User(name, age) values(&#x27;bomo&#x27;, 13)&quot;)session.execute(&quot;insert into User(name, age) values(:name, :age)&quot;, &#123;&#x27;name&#x27;: &#x27;bomo&#x27;, &#x27;age&#x27;:12&#125;)# 如果是增删改，需要commitsession.commit() 注意参数使用dict，并在sql语句中使用:key占位 4. ORM上面简单介绍了sql的简单用法，既然是ORM框架，我们先定义两个模型类User和Role，sqlalchemy的模型类继承自一个由declarative_base()方法生成的类，我们先定义一个模块Models.py生成Base类 123from sqlalchemy.ext.declarative import declarative_baseBase = declarative_base() User.py 12345678from sqlalchemy import Column, Integer, Stringfrom Models import Baseclass User(Base): __tablename__ = &#x27;User&#x27; id = Column(&#x27;id&#x27;, Integer, primary_key=True, autoincrement=True) name = Column(&#x27;name&#x27;, String(50)) age = Column(&#x27;age&#x27;, Integer) Role.py 1234567from sqlalchemy import Column, Integer, Stringfrom Models import Baseclass Role(Base): __tablename__ = &#x27;Role&#x27; id = Column(&#x27;id&#x27;, Integer, primary_key=True, autoincrement=True) name = Column(&#x27;name&#x27;, String(50)) 从上面很容易看出来，这里的模型对应数据库中的表，模型支持的类型有Integer, String, Boolean, Date, DateTime, Float，更多类型包括类型对应的Python的类型参见：这里 Column构造函数相关设置 name：名称 type_：列类型 autoincrement：自增 default：默认值 index：索引 nullable：可空 primary_key：外键 更多介绍参见这里 接下来通过session进行增删改查 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990from sqlalchemy import create_enginefrom sqlalchemy.orm import sessionmakerfrom User import Userfrom Role import Rolefrom Models import BaseDB_CONNECT_STRING = &#x27;sqlite:////Users/zhengxiankai/Desktop/Document/db.sqlite&#x27;engine = create_engine(DB_CONNECT_STRING, echo=True)DB_Session = sessionmaker(bind=engine)session = DB_Session()# 1. 创建表（如果表已经存在，则不会创建）Base.metadata.create_all(engine)# 2. 插入数据u = User(name = &#x27;tobi&#x27;, age = 200)r = Role(name = &#x27;user&#x27;)# 2.1 使用add，如果已经存在，会报错session.add(u)session.add(r)session.commit()print r.id# 3 修改数据# 3.1 使用merge方法，如果存在则修改，如果不存在则插入（只判断主键，不判断unique列）r.name = &#x27;admin&#x27;session.merge(r)# 3.2 也可以通过这种方式修改session.query(Role).filter(Role.id == 1).update(&#123;&#x27;name&#x27;: &#x27;admin&#x27;&#125;)# 4. 删除数据session.query(Role).filter(Role.id == 1).delete()# 5. 查询数据# 5.1 返回结果集的第二项user = session.query(User).get(2)# 5.2 返回结果集中的第2-3项users = session.query(User)[1:3]# 5.3 查询条件user = session.query(User).filter(User.id &lt; 6).first()# 5.4 排序users = session.query(User).order_by(User.name)# 5.5 降序（需要导入desc方法）from sqlalchemy import descusers = session.query(User).order_by(desc(User.name))# 5.6 只查询部分属性users = session.query(User.name).order_by(desc(User.name))for user in users: print user.name# 5.7 给结果集的列取别名users = session.query(User.name.label(&#x27;user_name&#x27;)).all()for user in users: print user.user_name# 5.8 去重查询（需要导入distinct方法）from sqlalchemy import distinctusers = session.query(distinct(User.name).label(&#x27;name&#x27;)).all()# 5.9 统计查询user_count = session.query(User.name).order_by(User.name).count()age_avg = session.query(func.avg(User.age)).first()age_sum = session.query(func.sum(User.age)).first()# 5.10 分组查询users = session.query(func.count(User.name).label(&#x27;count&#x27;), User.age).group_by(User.age)for user in users: print &#x27;age:&#123;0&#125;, count:&#123;1&#125;&#x27;.format(user.age, user.count)# 6.1 exists查询(不存在则为~exists())from sqlalchemy.sql import existssession.query(User.name).filter(~exists().where(User.role_id == Role.id))# SELECT name AS users_name FROM users WHERE NOT EXISTS (SELECT * FROM roles WHERE users.role_id = roles.id)# 6.2 除了exists，any也可以表示EXISTSsession.query(Role).filter(Role.users.any())# 7 randomfrom sqlalchemy.sql.functions import randomuser = session.query(User).order_by(random()).first()session.close() 参考链接： any 5. 多表关系上面的所有操作都是基于单个表的操作，下面是多表以及关系的使用，我们修改上面两个表，添加外键关联（一对多和多对一） User模型 1234567891011121314151617181920from sqlalchemy import Column, Integer, Stringfrom sqlalchemy import ForeignKeyfrom sqlalchemy.orm import relationshipfrom Models import Baseclass User(Base): __tablename__ = &#x27;users&#x27; id = Column(&#x27;id&#x27;, Integer, primary_key=True, autoincrement=True) name = Column(&#x27;name&#x27;, String(50)) age = Column(&#x27;age&#x27;, Integer) # 添加角色id外键(关联到Role表的id属性) role_id = Column(&#x27;role_id&#x27;, Integer, ForeignKey(&#x27;roles.id&#x27;)) # 添加同表外键 second_role_id = Column(&#x27;second_role_id&#x27;, Integer, ForeignKey(&#x27;roles.id&#x27;)) # 添加关系属性，关联到role_id外键上 role = relationship(&#x27;Role&#x27;, foreign_keys=&#x27;User.role_id&#x27;, backref=&#x27;User_role_id&#x27;) # 添加关系属性，关联到second_role_id外键上 second_role = relationship(&#x27;Role&#x27;, foreign_keys=&#x27;User.second_role_id&#x27;, backref=&#x27;User_second_role_id&#x27;) Role模型 12345678910111213from sqlalchemy import Column, Integer, Stringfrom sqlalchemy.orm import relationshipfrom Models import Baseclass Role(Base): __tablename__ = &#x27;roles&#x27; id = Column(&#x27;id&#x27;, Integer, primary_key=True, autoincrement=True) name = Column(&#x27;name&#x27;, String(50)) # 添加关系属性，关联到User.role_id属性上 users = relationship(&quot;User&quot;, foreign_keys=&#x27;User.role_id&#x27;, backref=&quot;Role_users&quot;) # 添加关系属性，关联到User.second_role_id属性上 second_users = relationship(&quot;User&quot;, foreign_keys=&#x27;User.second_role_id&#x27;, backref=&quot;Role_second_users&quot;) 这里有一点需要注意的是，设置外键的时候ForeignKey(&#39;roles.id&#39;)这里面使用的是表名和表列，在设置关联属性的时候relationship(&#39;Role&#39;, foreign_keys=&#39;User.role_id&#39;, backref=&#39;User_role_id&#39;)，这里的foreign_keys使用的时候类名和属性名 接下来就可以使用了 1234567891011121314151617181920u = User(name=&#x27;tobi&#x27;, age=200)r1 = Role(name=&#x27;admin&#x27;)r2 = Role(name=&#x27;user&#x27;)u.role = r1u.second_role = r2session.add(u)session.commit()# 查询（对于外键关联的关系属性可以直接访问，在需要用到的时候session会到数据库查询）roles = session.query(Role).all()for role in roles: print &#x27;role:&#123;0&#125; users&#x27; for user in role.users: print &#x27;\\t&#123;0&#125;&#x27;.format(user.name) print &#x27;role:&#123;0&#125; second_users&#x27; for user in role.second_users: print &#x27;\\t&#123;0&#125;&#x27;.format(user.name) 上面表示的是一对多（多对一）的关系，还有一对一，多对多，如果要表示一对一的关系，在定义relationship的时候设置uselist为False（默认为True），如在Role中 123class Role(Base): ... user = relationship(&quot;User&quot;, uselist=False, foreign_keys=&#x27;User.role_id&#x27;, backref=&quot;Role_user&quot;) 6. 多表查询多表查询通常使用join进行表连接，第一个参数为表名，第二个参数为条件，例如 1234users = db.session.query(User).join(Role, Role.id == User.role_id)for u in users: print u.name join为内连接，还有左连接outerjoin，用法与join类似，右连接和全外链接在1.0版本上不支持，通常来说有这两个结合查询的方法基本够用了，1.1版本貌似添加了右连接和全外连接的支持，但是目前只是预览版 还可以直接查询多个表，如下 1234result = db.session.query(User, Role).filter(User.role_id = Role.id)# 这里选择的是两个表，使用元组获取数据for u, r in result: print u.name 三、数据库迁移sqlalchemy的数据库迁移&#x2F;升级有两个库支持alembic和sqlalchemy-migrate 由于sqlalchemy-migrate在2011年发布了0.7.2版本后，就已经停止更新了，并且已经不维护了，也积累了很多bug，而alembic是较后来才出现，而且是sqlalchemy的作者开发的，有良好的社区支持，所以在这里只学习alembic这个库 alembic实现了类似git&#x2F;svn的版本管理的控制，我们可以通过alembic维护每次升级数据库的版本 1. 安装通过pip安装，pip会自动安装相关的依赖 1$ pip install alembic 2. 初始化安装完成后再项目根目录运行 1$ alembic init YOUR_ALEMBIC_DIR alembic会在根目录创建YOUR_ALEMBIC_DIR目录和alembic.ini文件，如下 12345678910yourproject/ alembic.ini YOUR_ALEMBIC_DIR/ env.py README script.py.mako versions/ 3512b954651e_add_account.py 2b1ae634e5cd_add_order_id.py 3adcc9a56557_rename_username_field.py 其中 alembic.ini 提供了一些基本的配置 env.py 每次执行Alembic都会加载这个模块，主要提供项目Sqlalchemy Model 的连接 script.py.mako 迁移脚本生成模版 versions 存放生成的迁移脚本目录 默认情况下创建的是基于单个数据库的，如果需要支持多个数据库或其他，可以通过alembic list_templates查看支持的模板 12345678910$ alembic list_templatesAvailable templates:generic - Generic single-database configuration.multidb - Rudimentary multi-database configuration.pylons - Configuration that reads from a Pylons project environment.Templates are used via the &#x27;init&#x27; command, e.g.: alembic init --template generic ./scripts 3. 配置使用之前，需要配置一下链接字符串，打开alembic.ini文件，设置sqlalchemy.url连接字符串，例如 1sqlalchemy.url = sqlite:////Users/zhengxiankai/Desktop/database.db 其他参数可以参见官网说明：http://alembic.zzzcomputing.com/en/latest/tutorial.html 4. 创建数据库版本接下来我们创建一个数据库版本，并新建两个表 1$ alembic revision -m &#x27;create table&#x27; 创建一个版本（会在yourproject/YOUR_ALEMBIC_DIR/versions/文件夹中创建一个python文件1a8a0d799b33_create_table.py） 该python模块包含upgrade和downgrade两个方法，在这里添加一些新增表的逻辑 1234567891011121314151617181920212223242526272829303132333435363738&quot;&quot;&quot;create tableRevision ID: 4fd533a56b34Revises:Create Date: 2016-09-18 17:20:27.667100&quot;&quot;&quot;from alembic import opimport sqlalchemy as sa# revision identifiers, used by Alembic.revision = &#x27;4fd533a56b34&#x27;down_revision = Nonebranch_labels = Nonedepends_on = Nonedef upgrade(): # 添加表 op.create_table( &#x27;account&#x27;, sa.Column(&#x27;id&#x27;, sa.Integer, primary_key=True), sa.Column(&#x27;name&#x27;, sa.String(50), nullable=False), sa.Column(&#x27;description&#x27;, sa.Unicode(200)), ) # 添加列 # op.add_column(&#x27;account&#x27;, sa.Column(&#x27;last_transaction_date&#x27;, sa.DateTime))def downgrade(): # 删除表 op.drop_table(&#x27;account&#x27;) # 删除列 # op.drop_column(&#x27;account&#x27;, &#x27;last_transaction_date&#x27;) 这里使用到了了op对象，关于op对象的更多API使用，参见这里 这里生成的文件名是依照在alembic.ini文件声明的模板来的，默认为版本号+名字，可以加上一些日期信息，否则不好排序，更多参数参见这里 1file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d_%%(minute).2d_%%(rev)s_%%(slug)s 另外通常我们也改一下生成模板script.py.mako，加上编码信息，否则在升级脚本中如果有中文会报错 12#!/usr/bin/python# -*- coding:utf-8 -*- 5. 升级数据库刚刚实现了升级和降级的方法，通过下面命令升级数据库到最新版本 1$ alembic upgrade head 这时候可以看到数据库多了两个表alembic_version和account，alembic_version存放数据库版本 关于升级和降级的其他命令还有下面这些 12345678910111213141516171819202122232425# 升到最高版本$ alembic upgrade head# 降到最初版本$ alembic downgrade base# 升两级$ alembic upgrade +2# 降一级$ alembic downgrade -1# 升级到制定版本$ alembic upgrade e93b8d488143# 查看当前版本$ alembic current# 查看历史版本详情$ alembic history --verbose# 查看历史版本（-r参数）类似切片$ alembic history -r1975ea:ae1027$ alembic history -r-3:current$ alembic history -r1975ea: 6. 通过元数据升级数据库上面我们是通过API升级和降级，我们也可以直接通过元数据更新数据库，也就是自动生成升级代码，先定义两个Model（User, Role），这里我定义成三个文件 123456yourproject/ YOUR_ALEMBIC_DIR/ tutorial/Db Models.py User.py Role.py 代码就放在一起了 12345678910111213141516from sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy import Column, Integer, StringBase = declarative_base()class User(Base): __tablename__ = &#x27;users&#x27; id = Column(&#x27;id&#x27;, Integer, primary_key=True, autoincrement=True) name = Column(&#x27;name&#x27;, String)class Role(Base): __tablename__ = &#x27;roles&#x27; id = Column(&#x27;id&#x27;, Integer, primary_key=True, autoincrement=True) name = Column(&#x27;name&#x27;, String) 在YOUR_ALEMBIC_DIR/env.py配置元数据 1target_metadata = None 改为 12345678910import osimport sys# 这里需要添加相对路径到sys.path，否则会引用失败，尝试过使用相对路径，但各种不好使，还是使用这种方法靠谱些sys.path.append(os.path.abspath(os.path.join(os.getcwd(), &quot;../yourproject/tutorial/Db&quot;)))from User import Userfrom Role import Rolefrom Models import Basetarget_metadata = Base.metadata os.path.join(os.getcwd()这个获取到的地址不是env.py的路径，而是根目录 在创建数据库版本的时候添加--autogenerate参数，就会从Base.metadata元数据中生成脚本 1$ alembic revision --autogenerate -m &quot;add user table&quot; 这时候会在生成升级代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445&quot;&quot;&quot;add user tableRevision ID: 97de1533584aRevises: 8678ab6d48c1Create Date: 2016-09-19 21:58:00.758410&quot;&quot;&quot;from alembic import opimport sqlalchemy as sa# revision identifiers, used by Alembic.revision = &#x27;97de1533584a&#x27;down_revision = &#x27;8678ab6d48c1&#x27;branch_labels = Nonedepends_on = Nonedef upgrade(): ### commands auto generated by Alembic - please adjust! ### op.create_table(&#x27;roles&#x27;, sa.Column(&#x27;id&#x27;, sa.Integer(), nullable=False), sa.Column(&#x27;name&#x27;, sa.String(), nullable=True), sa.PrimaryKeyConstraint(&#x27;id&#x27;) ) op.create_table(&#x27;users&#x27;, sa.Column(&#x27;id&#x27;, sa.Integer(), nullable=False), sa.Column(&#x27;name&#x27;, sa.String(), nullable=True), sa.PrimaryKeyConstraint(&#x27;id&#x27;) ) op.drop_table(&#x27;account&#x27;) ### end Alembic commands ###def downgrade(): ### commands auto generated by Alembic - please adjust! ### op.create_table(&#x27;account&#x27;, sa.Column(&#x27;id&#x27;, sa.INTEGER(), nullable=False), sa.Column(&#x27;name&#x27;, sa.VARCHAR(length=50), nullable=False), sa.Column(&#x27;description&#x27;, sa.VARCHAR(length=200), nullable=True), sa.Column(&#x27;last_transaction_date&#x27;, sa.DATETIME(), nullable=True), sa.PrimaryKeyConstraint(&#x27;id&#x27;) ) op.drop_table(&#x27;users&#x27;) op.drop_table(&#x27;roles&#x27;) ### end Alembic commands ### 由于我没有定义account模型，会被识别为删除，如果删除了model的列的声明，则会被识别为删除列，自动生成的版本我们也可以自己修改，然后执行升级命令即可升级alembic upgrade head 需要注意的是 Base.metadata声明的类必须以数据库中的一一对应，如果数据库中有的表，而在元数据中没有，会识别成删除表 revision创建版本之前执行之前需要升级到最新版本 配置Base之前，需要保证所有的Model都已经执行（即导入）过一次了，否则无法读取到，也就是需要把所有Model都import进来 数据库升级有风险，升级前最好先检查一遍upgrade函数，可以的话做好备份哈 四、常见问题1. String长度问题如果使用mysql数据库，String类型对应的是VARCHAR类型，需要指定长度，否则会报下面错误，而在sqlite不会出现 1(in table &#x27;user&#x27;, column &#x27;name&#x27;): VARCHAR requires a length on dialect mysql TODO：如有问题欢迎留言 五、参考链接 Auto Generating Migrations tutorial","categories":[{"name":"python","slug":"python","permalink":"http://zhengbomo.github.io/categories/python/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://zhengbomo.github.io/tags/sql/"}]},{"title":"pycharm添加jinja2模板引擎的识别","slug":"pycharm-jinja2","date":"2016-09-03T01:09:43.000Z","updated":"2016-09-03T01:09:43.000Z","comments":true,"path":"2016-09-03/pycharm-jinja2/","link":"","permalink":"http://zhengbomo.github.io/2016-09-03/pycharm-jinja2/","excerpt":"默认情况下，通过Pycharm新建项目时，有个flask选项，新建完成后，是可以支持jinja模板的识别的，例如跳转，语法高亮等功能，但是如果是自己新建的目录，然后用Pycharm导入的，这个时候html文件里面的模板代码无法被高亮，也无法跳转","text":"默认情况下，通过Pycharm新建项目时，有个flask选项，新建完成后，是可以支持jinja模板的识别的，例如跳转，语法高亮等功能，但是如果是自己新建的目录，然后用Pycharm导入的，这个时候html文件里面的模板代码无法被高亮，也无法跳转 本身pycharm是支持jinja模板引擎的，只需要在配置文件加上配置即可，打开工程目录/.idea/xxx.iml文件，其中xxx为项目名称（即外层目录名），在module节点下添加TemplatesService，如下： 12345678&lt;component name=&quot;TemplatesService&quot;&gt; &lt;option name=&quot;TEMPLATE_CONFIGURATION&quot; value=&quot;Jinja2&quot; /&gt; &lt;option name=&quot;TEMPLATE_FOLDERS&quot;&gt; &lt;list&gt; &lt;option value=&quot;$MODULE_DIR$/hello/templates&quot; /&gt; &lt;/list&gt; &lt;/option&gt;&lt;/component&gt; 由于我的代码在hello目录下，所以在TemplateFolder路径需要加上，否则会找不到文件，修改完保存即可生效","categories":[{"name":"python","slug":"python","permalink":"http://zhengbomo.github.io/categories/python/"}],"tags":[{"name":"pycharm","slug":"pycharm","permalink":"http://zhengbomo.github.io/tags/pycharm/"}]},{"title":"ubuntu crontab定时任务","slug":"ubuntu-crontab","date":"2016-09-01T15:48:43.000Z","updated":"2016-09-01T15:48:43.000Z","comments":true,"path":"2016-09-01/ubuntu-crontab/","link":"","permalink":"http://zhengbomo.github.io/2016-09-01/ubuntu-crontab/","excerpt":"最近在写一个爬虫，需要每天爬取一定量的数据，在自己机器做就太麻烦了，如果能放在服务器上自动跑就好了，找了一下linux系统有个crontab的工具可以用来设置定时任务，这里简单记录一下使用方法","text":"最近在写一个爬虫，需要每天爬取一定量的数据，在自己机器做就太麻烦了，如果能放在服务器上自动跑就好了，找了一下linux系统有个crontab的工具可以用来设置定时任务，这里简单记录一下使用方法 一、定义任务这里定义个python脚本（daily_task.py），假设需要每天凌晨12点执行一次 1234567#!/usr/bin/python# -*- coding:utf-8 -*-def do_something(): print &#x27;daily task by crontab!&#x27;do_something() 假设文件存放在：/home/ubuntu/daily_task.py 二、创建任务通过crontab -e配置任务，如果有多个编辑器的话，会让你选择一个编辑器 1$ crontab -e 输入格式：分 时 日 月 年 脚本第1列分钟：1～59第2列小时：1～23（0表示子夜）第3列日：1～31第4列月：1～12第5列星期：0～6（0表示星期天）第6列脚本 1. 表示单个具体时间每天7点30分执行daily_task.py脚本 130 7 * * * python /home/ubuntu/daily_task.py 2. 表示多个时间（通过都好隔开）表示每月1、10、22日的4:45重启apache。 145 4 1,10,22 * * /usr/local/apache/bin/apachectl restart 3. 表示时间间隔每一小时重启apache 1* */1 * * * /usr/local/apache/bin/apachectl restart 4. 表示时间范围晚上11点到早上7点之间，每隔一小时重启apache 1* 23-7/1 * * * /usr/local/apache/bin/apachectl restart 5. 通过字母表示星期每月的4号与每周一到周三的11点重启apache 10 11 4 * mon-wed /usr/local/apache/bin/apachectl restart 6. 通过字母表示月份1月1号的4点重启apache 10 4 1 jan * /usr/local/apache/bin/apachectl restart 编辑完成后，退出保存，并保存cront文件 三、测试我们创建一个简单的任务，没两分钟执行一次 1*/2 * * * * python /home/ubuntu/python/daily_task.py &gt;&gt; /home/ubuntu/python/crontest.py.log 可以在该文件中配置多个任务，编辑完成后，我们查看一下cron的状态 12$ sudo service cron statuscron start/running, process 29899 如果没有启动，我们重启一下cron服务 123$ sudo service cron restartcron stop/waitingcron start/running, process 29899 可以通过&#96;&#96;命令查看当前的配置（也就是刚刚配置的文件） 1$ crontab -l 可以吧刚刚配置的文件保存到自定义的位置 1$ crontab -l &gt; /home/ubuntu/python/mycron.config 如果已经有了配置文件，可以设置文件路径 1$ crontab &lt; /home/ubuntu/python/mycron.config","categories":[{"name":"linux","slug":"linux","permalink":"http://zhengbomo.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://zhengbomo.github.io/tags/linux/"}]},{"title":"Object-C注释","slug":"objc-annotation","date":"2016-08-26T00:26:26.000Z","updated":"2016-08-26T00:26:26.000Z","comments":true,"path":"2016-08-26/objc-annotation/","link":"","permalink":"http://zhengbomo.github.io/2016-08-26/objc-annotation/","excerpt":"与其他语言一样，Object-C的注释也分为两种，一种是普通注释，一种是文档注释，普通注释通常给阅读代码的人看，而文档注释除了可以给阅读的文件的人看还可以被appledoc识别，在使用的时候xcode能给出智能提示，有些工具还可以把文档注释生成文档","text":"与其他语言一样，Object-C的注释也分为两种，一种是普通注释，一种是文档注释，普通注释通常给阅读代码的人看，而文档注释除了可以给阅读的文件的人看还可以被appledoc识别，在使用的时候xcode能给出智能提示，有些工具还可以把文档注释生成文档 一、简单注释 单行注释 单行注释不能被文档识别，通常用于函数内部 1//学生信息 多行注释 可以被工具识别 1234/* * 多行注释内容1 * 多行注释内容2 */ 二、文档注释（appledoc可识别成文档） 单行注释 123456789101112@interface Student : NSObject///名字@property (nonatomic, copy) NSString *name;///年龄@property (nonatomic, assign) NSInteger age;///校园卡Id@property (nonatomic, copy) NSString *schoolId;///年纪@property (nonatomic, copy) NSString *grade;@end 如果安装了VVDocument，当输入///的时候回自动生成多行注释，通常我们通过/** 注释内容 */进行注释 123456789101112@interface Student : NSObject/** 名字 */@property (nonatomic, copy) NSString *name;/** 年龄 */@property (nonatomic, assign) NSInteger age;/** 校园卡Id */@property (nonatomic, copy) NSString *schoolId;/** 年纪 */@property (nonatomic, copy) NSString *grade;@end 多行注释 1234/** 简要描述. * * 详细描述或其他. */ 行尾注释有时候一些简短的注释可以可以用行尾注释来减少代码的行数，通常用在枚举变量的注释上 12345678@interface Student : NSObject@property (nonatomic, copy) NSString *name; /**&lt; 名字 */@property (nonatomic, assign) NSInteger age; /**&lt; 年龄 */@property (nonatomic, copy) NSString *schoolId; /**&lt; 校园卡Id */@property (nonatomic, copy) NSString *grade; /**&lt; 年纪 */@end 函数注释 函数注释也属于多行注释，通常我们使用 VVDocument 插件辅助 123456789101112131415161718192021/** * 获取状态描述 * * @param state 状态值 * * @return 返回状态描述 */- (NSString *)getState:(NSInteger)state&#123; switch (state) &#123; case 1: return @&quot;待确认&quot;; break; case 2: return @&quot;确认&quot;; break; case 3: return @&quot;驳回&quot;; break; &#125;&#125; 三、总结上面介绍了objc中所有的注释样式，在实际开发中，我们应该多使用文档注释，使用文档注释可以获得xcode的智能提示，在用appledoc生成文档的时候也可以被识别 四、参考链接 http://www.cnblogs.com/zyl910/archive/2013/06/07/objcdoc.html","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"}]},{"title":"virtualenv学习笔记","slug":"virtualenv-start","date":"2016-07-28T08:05:38.000Z","updated":"2016-07-28T08:05:38.000Z","comments":true,"path":"2016-07-28/virtualenv-start/","link":"","permalink":"http://zhengbomo.github.io/2016-07-28/virtualenv-start/","excerpt":"virtualenv是python的一个第三方模块，用来配置独立的python环境，特别是在服务器端需要进行版本控制时使用，有些第三方库向前或向后兼容性很差，这时候可用针对不同的版本配置不同的python环境更为方便","text":"virtualenv是python的一个第三方模块，用来配置独立的python环境，特别是在服务器端需要进行版本控制时使用，有些第三方库向前或向后兼容性很差，这时候可用针对不同的版本配置不同的python环境更为方便 一、安装可以直接通过pip安装，也可以自行下载源码编译安装 1$ sudo pip install virtualenv 安装完后需要连接到执行命令目录 1$ sudo ln -s /usr/local/lib/python2.7.12/bin/virtualenv /usr/bin/virtualenv 在终端使用virtualenv -h查看帮助 二、基本使用我们可以使用virtualenv创建一个独立的python环境，默认也会包含pip, easy_install, wheel等工具： 12$ virtualenv envname # 创建一个新的隔离环境，会安装Installing setuptools, pip, wheel...done.$ cd envname 1. 常见命令参数 --system-site-packages: 使用系统的全局的python库 --no-site-packages: 不使用系统的全局的python库（默认）(废弃) --download: 从网上下载包预安装的包 --no-download: 使用本地包，不从网上下载，如果不存在会报错 更多参数见官网说明：https://virtualenv.pypa.io/en/stable/reference/#cmdoption--system-site-packages 2. 我们查看一下有哪些文件12345678910111213$ lsbin include lib pip-selfcheck.json$ ls binactivate activate_this.py pip python python-configactivate.csh easy_install pip2 python2 wheelactivate.fish easy_install-2.7 pip2.7 python2.7$ ls includepython2.7$ ls libpython2.7 文件与python安装目录下的文件类似，即独立环境所使用的package和一些可执行程序 3. 激活并进入虚拟环境使用下面命令激活当前的环境（这里用的是mac），之后使用的python环境就是刚创建的虚拟环境，命令行前面会带虚拟环境的名字：(envname) 12$ source bin/activate(envname) localhost:envname zhengxiankai$ 我们通过which查看一下当前环境下的python执行文件的路径，我们发现当前的环境变成了刚刚激活的路径，而不是系统的python路径了，而使用pip安装的路径包也会在这个环境的路径下 12(envname) localhost:envname zhengxiankai$ which python/home/ubuntu/envname/bin/python 进入python交互解释器 12345(envname) localhost:envname zhengxiankai$ pythonPython 2.7.12 (default, Jul 28 2016, 07:03:11)[GCC 4.8.4] on linux2Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; 查看搜索路径 1234&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path[&#x27;&#x27;, &#x27;/home/ubuntu/envname/lib/python27.zip&#x27;, &#x27;/home/ubuntu/envname/lib/python2.7&#x27;, &#x27;/home/ubuntu/envname/lib/python2.7/plat-linux2&#x27;, &#x27;/home/ubuntu/envname/lib/python2.7/lib-tk&#x27;, &#x27;/home/ubuntu/envname/lib/python2.7/lib-old&#x27;, &#x27;/home/ubuntu/envname/lib/python2.7/lib-dynload&#x27;, &#x27;/usr/local/lib/python2.7.12/lib/python2.7&#x27;, &#x27;/usr/local/lib/python2.7.12/lib/python2.7/plat-linux2&#x27;, &#x27;/usr/local/lib/python2.7.12/lib/python2.7/lib-tk&#x27;, &#x27;/home/ubuntu/envname/lib/python2.7/site-packages&#x27;]&gt;&gt;&gt; 4. 退出虚拟环境使用完成之后通过deactivate命令退出虚拟环境，前面的虚拟环境名(envname)没有了，说明退出了 12(envname) localhost:envname zhengxiankai$ deactivatelocalhost:envname zhengxiankai$ 三、批量安装packagepip工具支持批量安装package，只需要把需要的包按照格式写在文件中，就可以自动安装，同时也支持导出，下面是从当前环境（envname）导出所有安装的包的配置到requirements.txt文件中 1$ pip freeze &gt; requirements.txt 批量安装requirements.txt文件中的所有包 1$ pip install -r requirements.txt 这样在切换环境的时候安装依赖包就很方便了，不需要一个一个安装了 四、与Pycharm结合Pycharm是python最常用的开发工具，当然也提供了virtualenv的支持，到设置里面的Project Interpreter添加本地已经存在的虚拟环境，也可以直接创建，然后应用到工程即可 四、总结virtualenv可以创建python的独立环境，可以包含一整套python的环境（除了外部依赖，如mysql等），特别是在服务器部署时可以连同环境一块部署，不需要为每一台服务器安装所有的库，而在多人开发过程中，为了保证环境的一致，也可以把独立环境也通过git维护，这样可以保证所有人的环境一致，而不用在所有的机器上配置","categories":[{"name":"python","slug":"python","permalink":"http://zhengbomo.github.io/categories/python/"}],"tags":[{"name":"virtualenv","slug":"virtualenv","permalink":"http://zhengbomo.github.io/tags/virtualenv/"}]},{"title":"ubuntu安装mysql和python","slug":"ubuntu-install-mysql-python","date":"2016-07-28T04:20:48.000Z","updated":"2016-07-28T04:20:48.000Z","comments":true,"path":"2016-07-28/ubuntu-install-mysql-python/","link":"","permalink":"http://zhengbomo.github.io/2016-07-28/ubuntu-install-mysql-python/","excerpt":"前几天弄了一年免费亚马逊VPS服务器，这里记录一下配置python的环境和安装一些常用的工具","text":"前几天弄了一年免费亚马逊VPS服务器，这里记录一下配置python的环境和安装一些常用的工具 升级apt-get源12$ sudo apt-get update$ sudo apt-get upgrade 升级python先看一下ubuntu自带的python的版本也可以通过python --version查看版本自带的python版本为2.7.6，我们手动升级一下 升级前可能需要安装gcc, make, zlib, ssl 123456# 先更新一下源$ sudo apt-get update$ sudo apt-get install gcc$ sudo apt-get install make$ sudo apt-get install zlibc zlib1g-dev$ sudo apt-get install libssl-dev 升级python（安装到/usr/local/lib/python2.7.12） 123456789101112# 下载最新版$ wget https://www.python.org/ftp/python/2.7.12/Python-2.7.12.tgz# 解压$ tar zxvf Python-2.7.12.tgz# 进入目录$ cd Python-2.7.12/# 配置，注意带zlib，否则zlib要自己独立安装$ sudo ./configure --prefix=/usr/local/lib/python2.7.12 --with-zlib-dir=/usr/local/lib# 编译$ make# 执行安装$ sudo make install linux中安装程序基本上是./configure-&gt;make-&gt;make install三部曲，安装后的文件存放在/usr/local/bin/python2.7.12，需要链接到执行文件，安装完后发现python还是原来的版本，通过which命令看一下python的路径 12$ which python/usr/bin/python 进入/usr/bin/目录我们修改一下python文件换成我们新的python执行文件，在终端输入python2.7.9可以进入刚安装的版本，但是太麻烦了，这个时候改一下默认版本（有些版本安装后会自动改） 123# //对系统默认版本python进行操作，改名$ sudo mv /usr/bin/python /usr/bin/python_old$ sudo ln -s /usr/local/lib/python2.7.12/bin/python /usr/bin/python 到这里，我们就完成了python的升级，python安装在/usr/local/lib/python2.7.12目录下，python命令指向新的路径 安装pip和easy_installeasy_install和pip是python最常用的两个包管理工具，通过源码编译安装时，并不会没有带这两个工具（windows和mac通过安装包安装时会自动安装pip和easy_install）安装easy_install 12345$ wget https://pypi.python.org/packages/1b/4f/e52b81c47396668deb139b628f4ebb499b3cd39fc05382851fa985d0b642/setuptools-24.3.0.tar.gz#md5=55d77ca2b1f783a71e330b0878da29ec$ tar zxvf setuptools-24.3.0.tar.gz$ cd setuptools-24.3.0$ python setup.py build$ sudo python setup.py install 安装pip 1234$ wget https://pypi.python.org/packages/e7/a8/7556133689add8d1a54c0b14aeff0acb03c64707ce100ecd53934da1aa13/pip-8.1.2.tar.gz#md5=87083c0b9867963b29f7aba3613e8f4a$ tar zxvf pip-8.1.2.tar.gz$ cd pip-8.1.2$ sudo python setup.py install 默认安装在/usr/local/lib/python2.7.12/bin 这个时候不能直接用easy_install和pip命令，我们创建一下链接 12$ sudo ln -s /usr/local/lib/python2.7.12/bin/easy_install /usr/bin/easy_install$ sudo ln -s /usr/local/lib/python2.7.12/bin/pip /usr/bin/pip 如果系统已经有了pip和easy_install，我们需要改成新版本的pip和easy_install，通过which查看当前的路径，处理方法与python一样 删除原来的pip程序并链接新的pip程序 1234567# pip$ sudo mv /usr/bin/pip /usr/bin/pip_old$ sudo ln -s /usr/local/python2.7.12/bin/pip /usr/bin/pip# easy_install$ sudo mv /usr/bin/easy_install /usr/bin/easy_install_old$ sudo ln -s /usr/local/lib/python2.7.12/bin/easy_install /usr/bin/easy_install 安装virtualenv1$ sudo pip install virtualenv 安装flask12345# flask依赖ssl库，需要先安装下面两个工具$ sudo apt-get install openssl$ sudo apt-get install libssl-dev$ sudo pip install flask 安装mysql使用下面命令检查是否安装过，如果没有任何输出，说明没有安装 1$ sudo netstat -tap | grep mysql 安装mysql-server, mysql-client 12$ sudo apt-get install mysql-server mysql-client$ sudo apt-get install libmysqlclient-dev 安装过程会让你输入root用户的密码，输入后按Tap键下一步 安装完成，测试是否成功安装（成功） 登陆看看 1$ mysql -u root -p 然后输入密码，ok 创建数据库 1CREATE DATABASE IF NOT EXISTS TestDb DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 查看所有数据库 123456789mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || TestDb || mysql || performance_schema |+--------------------+ 使用数据库 12mysql&gt; use TestDbDatabase changed 安装MySQL-python库1$ sudo pip install MySQL-python 使用 123import MySQLdbconn = MySQLdb.connect(host=&quot;127.0.0.1&quot;, user=&quot;root&quot;, passwd=&quot;111111&quot;, db=&quot;PaiPaiDai&quot;, charset=&quot;utf8&quot;) 如果没有安装libmysqlclient-dev，安装过程中可能会出现下面错误 12345678910sh: 1: mysql_config: not foundTraceback (most recent call last): File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; File &quot;/tmp/pip-build-IMiD72/MySQL-python/setup.py&quot;, line 17, in &lt;module&gt; metadata, options = get_config() File &quot;/tmp/pip-build-IMiD72/MySQL-python/setup_posix.py&quot;, line 43, in get_config libs = mysql_config(&quot;libs_r&quot;) File &quot;/tmp/pip-build-IMiD72/MySQL-python/setup_posix.py&quot;, line 25, in mysql_config raise EnvironmentError(&quot;%s not found&quot; % (mysql_config.path,))EnvironmentError: mysql_config not found 安装lxml安装前需要先安装几个依赖包 123$ sudo apt-get install libxml2 libxml2-dev$ sudo apt-get install libxslt1-dev$ sudo apt-get install python-libxml2 安装lxml（安装可能需要几分钟） 1$ sudo pip install lxml 参考：http://lxml.de/installation.html 安装scrapy安装scrapy前需要安装依赖Twisted 1234$ wget https://pypi.python.org/packages/c0/7c/c1e5b61e30b7ffc96576d2a922615c8068e6996a622be813fc626cef07aa/Twisted-16.3.0.tar.bz2#md5=e044af844623e9fbcbe29f578db6053a$ tar xjf Twisted-16.3.0.tar.bz2$ cd Twisted-16.3.0$ sudo python setup.py install 安装完成后再安装scrapy 1$ sudo pip install scrapy 入门教程：https://scrapy-chs.readthedocs.io/zh_CN&#x2F;0.24&#x2F;intro&#x2F;tutorial.html 安装requests库让你从痛苦的urllib中解脱 1$ sudo pip install requests 详细介绍：http://cn.python-requests.org/zh_CN&#x2F;latest&#x2F; 安装git1$ sudo apt-get install git 安装nginx123456# 添加Nginx库到apt-get source中$ sudo add-apt-repository ppa:nginx/stable# 更新apt源$ sudo apt-get update &amp;&amp; sudo apt-get upgrade# 安装nginx$ sudo apt-get install nginx 启动 12$ sudo /etc/init.d/nginx startstart: Job is already running: nginx 启动后可以通过ip可以正常访问 ubuntu使用技巧1. vim退出不保存有时候使用vim编辑系统文件的时候，由于没有权限无法保存，又无法退出，只用:q!可以不保存退出 2. 开启crontab日志默认定时任务crontab是不开启日志的，需要修改/etc/rsyslog.d/50-default.conf并将下面一行的前面的注释#去掉（编辑的时候需要sudo权限） 1# cron.* /var/log/cron.log 然后重启rsyslog和cron服务 12$ service rsyslog restart;$ service cron restart;","categories":[{"name":"技术","slug":"技术","permalink":"http://zhengbomo.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://zhengbomo.github.io/tags/mysql/"}]},{"title":"亚马逊VPS免费一年试用","slug":"amazon-aws-start","date":"2016-07-18T13:02:00.000Z","updated":"2016-07-18T13:02:00.000Z","comments":true,"path":"2016-07-18/amazon-aws-start/","link":"","permalink":"http://zhengbomo.github.io/2016-07-18/amazon-aws-start/","excerpt":"一直想整个服务器玩玩，又苦于没时间没钱，最近看到亚马逊VPS服务器有免费一年的使用时间，于是整了一个，在这里记录申请和配置的过程","text":"一直想整个服务器玩玩，又苦于没时间没钱，最近看到亚马逊VPS服务器有免费一年的使用时间，于是整了一个，在这里记录申请和配置的过程 一、准备需要用到VISA信用卡或者Master信用卡，钱的问题比较敏感，添加信用卡只是当预授权做验证用，会扣除$1，有个心理准备 二、开始 到亚马逊注册账号 按步骤填写，中间需要使用到信用卡，会扣除$1的手续费，在使用过程中需要注意，有很多服务是收费的，并且绑定信用卡后不会每次都询问你确认就直接扣除了（呵呵），操作的时候要小心，我使用完就直接到账户中心把信用卡删除了 到https://console.aws.amazon.com/ec2/创建实例，选择linux Ubuntu服务器（有部分服务器是要钱的）有两种版本HVM和PV，PV运行效率高一些，linux选择PV（半虚拟）就可以了，区别见 一直下一步走，会有提示免费的选项，选择免费的就行，在最后会让你创建秘钥，输入名字创建，并且下载到本地xxx.pem（只有一次下载机会）然后完成 到https://console.aws.amazon.com/ec2/查看正在运行的实例，这个时候应该只有一个，可以看到实例的公网ip，等信息 这个时候需要用秘钥与服务器配对连接 进入终端修改秘钥文件的权限：chmod 400 xxx.pem 默认用户为ubuntu，连接公网服务器：ssh -i xxx.pem ubuntu@[公网ip]（如：ssh -i “ABC.pem” &#117;&#x62;&#x75;&#x6e;&#116;&#117;&#64;&#x35;&#50;&#x2e;&#x33;&#x39;&#46;&#49;&#x36;&#x38;&#x2e;&#50;&#51;&#x35;），以后也是通过这个连接的 ok，连接成功 接下来就可以对服务器进行操作了 如果是windows下默认不支持ssh登陆，需要安装PuTTY，详情参见这里 三、固定IP默认情况下，服务器每次重启的的时候，IP可能会更变，我们在后台控制面板申请一个新的公网地址 然后绑定到实例上，因为我这里已经绑定了，所以是解除关联 这样在每次重启的的时候ip就不会变了 四、设置安全组默认情况下服务器只能通过ssh访问，如果我们配置了web服务器，默认情况下是不能通过ip访问的，需要在安全组中添加入站规则，在后台找到实例对应的安全组 找到添加入站规则（如：http）这样就可以通过http访问了，下面我们安装nginx测试一下 123$ sudo add-apt-repository ppa:nginx/stable$ sudo apt-get update &amp;&amp; sudo apt-get upgrade$ sudo apt-get install nginx 启动nginx 12$ sudo /etc/init.d/nginx startstart: Job is already running: nginx 这个时候我们就可以通过ip访问了 五、绑定域名有了固定ip绑定域名就很简单了，在dns域名解析服务器(如dnspod)添加一个A记录即可接下来就可以用域名访问了（可能有延迟） 六、iTerm快捷连接iTerm基本上是Mac上必备的终端工具，功能比自带的终端强大的多，这里使用其中一个技巧来实现快速连接和登录服务器，打开iTerm配置（Cmd+,）添加Profile 添加完后，通过快捷键（Cmd+o）打开profile列表，然后选择就可以自动打开新窗口执行了，特别方便","categories":[{"name":"技术","slug":"技术","permalink":"http://zhengbomo.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"VPS","slug":"VPS","permalink":"http://zhengbomo.github.io/tags/VPS/"}]},{"title":"swift构造器总结","slug":"swift-constructor","date":"2016-07-07T13:17:17.000Z","updated":"2016-07-07T13:17:17.000Z","comments":true,"path":"2016-07-07/swift-constructor/","link":"","permalink":"http://zhengbomo.github.io/2016-07-07/swift-constructor/","excerpt":"swift构造器的语法和规则比其他语言复杂，有很多限制和检查，刚开始学的时候经常搞懵，在这里做一个简单的总结","text":"swift构造器的语法和规则比其他语言复杂，有很多限制和检查，刚开始学的时候经常搞懵，在这里做一个简单的总结 一、基本用法构造器与函数类似，但不是函数，构造器无返回值，使用方式与函数类似，名称为init，可以带参数 1234567891011121314class Person &#123; var name: String var gender: Int? // 定义一个无参数的构造器 init() &#123; name = &quot;&quot; &#125; // 定义一个带参数的构造器 init(name: String) &#123; self.name = name &#125;&#125; 构造器的作用是保证所有的成员（变量&#x2F;常量）初始化完成，所有常量被赋值，所有非Optional变量都要进行赋值 123456789101112131415161718192021class Person &#123; var name: String // 非Optional类型变量，必须初始化 var age: Int? // Optional类型变量，可以不显式初始化 let idNumber: String // 非Optional类型常量，必须初始化 let gender: Int? // Optional类型常量，必须初始化 // 定义一个无参数的构造器 init() &#123; name = &quot;&quot; idNumber = &quot;&quot; gender = nil &#125; // 定义一个带参数的构造器 init(name: String) &#123; self.name = name idNumber = &quot;&quot; gender = nil &#125;&#125; 二、便利构造器上面我们看到的构造器，都是指定构造器（designated），指定构造器必须保证所有的成员都完成初始化了，我们可以对初始化话方法做一些方便的扩展，并且可以重用原指定构构造器的逻辑，这时候可以定义便利构造器（convenience），定义便利构造器使用convenience init()，如上面Person类的例子 12345678910111213141516171819class Person &#123; var name: String // 非Optional类型变量，必须初始化 var age: Int? // Optional类型变量，可以不显式初始化 let idNumber: String // 非Optional类型常量，必须初始化 let gender: Int? // Optional类型常量，必须初始化 // 定义一个无参数的构造器 init() &#123; name = &quot;&quot; idNumber = &quot;&quot; gender = nil &#125; // 定义便利构造器 convenience init(name: String) &#123; self.init() // 调用指定构造器 self.name = name &#125;&#125; 便利构造器不能被子类继承，子类不能通过super调用，如果希望便利构造器被子类继承，可以使用required声明子类必须重写该方法 123456789101112131415161718192021222324252627class Person &#123; var name: String // 非Optional类型变量，必须初始化 var age: Int? // Optional类型变量，可以不显式初始化 let idNumber: String // 非Optional类型常量，必须初始化 let gender: Int? // Optional类型常量，必须初始化 // 定义一个无参数的构造器 init() &#123; name = &quot;&quot; idNumber = &quot;&quot; gender = nil &#125; // 定义一个带参数的构造器 required convenience init(name: String) &#123; self.init() self.name = name &#125;&#125;class Student: Person &#123; var classNo: String = &quot;&quot; required init(name: String) &#123; &#125;&#125; 便利构造器只能调用当前类的指定构造器，不能调用父类的指定构造器，类不能只有便利构造器，便利构造器是横向调用（当前类）而指定构造器是纵向调用的（父类） 开始使用convenience声明便利构造器感觉有点奇葩，因为编译器是可以识别到构造器是否调用了其他指定构造器（designated）的，也就是说可以，却还需要我们自己声明，当然自己声明可以方便我们区分构造器，以便更直观的看出指定构造器和便利构造器，这样可以很快的分辨是否可以被子类使用 三、可失败构造器（Failable initializer）除了普通的构造器，swift还允许构造失败，如当我们传入一些不恰当的参数导致类构造出现一些异常的情况，这时候我们可以让构造器返回nil，说明构造失败，声明方式为init?()，在需要的地方return nil 12345678910111213141516class Person &#123; var name: String var gender: Int // 定义一个无参数的构造器 init?(name: String, gender: Int) &#123; self.name = name if gender != 0 &amp;&amp; gender != 1 &#123; return nil // 失败的地方返回nil即可 &#125; self.gender = gender &#125;&#125;var person = Person(name: &quot;bomo&quot;, gender: 2)if let p = person &#123; print(p.name)&#125; 可失败构造这名字太难听了，我更喜欢叫为可空构造器，返回是一个Optional类型，使用的时候需要先取值 四、必须构造器类可以定义required构造器，当子类继承父类是，必须实现required构造器，当然，如果子类不实现任何构造器时，也可以不实现required构造器 1234567891011121314151617class Parent &#123; var name: String required init(name: String) &#123; self.name = name &#125;&#125;class Son: Parent &#123; required init(name: String) &#123; //子类必须实现 super.init(name: name) &#125; init() &#123; super.init(name: &quot;bomo&quot;) &#125;&#125;class Son2: Parent &#123; // 如果子类不实现任何构造器，则不可以不实现required&#125; 五、闭包初始化属性出行的初始化可以通过构造器设置，也可以在声明的时候直接设置，swift还支持通过执行闭包函数初始化属性 123456class SomeClass &#123; let someProperty: SomeType = &#123; // 这里不能使用类相关的属性，因为在这里类还没有初始化完成 return someValue &#125;() // 最后需要执行闭包，否则返回的是闭包，而不是闭包函数运行后返回的值&#125; 六、继承* 子类只能继承父类的指定构造器和`required`声明的构造器，required声明构造器表示子类必须重写该构造器 * 如果子类实现了父类的**部分**指定构造器，则不会继承父类的构造器 * 如果子类实现了父类的**所有**指定构造器，则会继承父类 * 如果子类没有实现任何构造器，则会继承父类的**所有构造器** * 子类的指定构造器最终必须调用父类的指定构造器 * 子类调用父类构造器之前必须保证当前类的所有属性已初始化为适当的值（非可选变量都已赋值，所有常量都已赋值） * 子类使用父类的属性时，必须在调用父类指定构造器之后 所有的构造器都必须保证，在执行完构造器时，所有的属性都初始化为适当的值 七、两段式构造swift的构造器有点奇葩，分为两段式构造 * 第一阶段：为每个属性初始化一个初始值 * 第二阶段：为每个属性定制化值 在其他语言中C#&#x2F;Java中，系统默认会为对象的所有属性和字段初始化值，如值类型初始化为0，引用类型初始化为null，结构体成员遵循前两条，系统自动为我们完成了第一阶段，我们直接进入第二阶段，直接定制化属性&#x2F;字段值，而swift把这两个阶段分开给我们实现了 八、外部参数名所有带参数的构造器在调用的时候必须显式使用外部参数名，如果不显式声明外部参数名，外部参数名与内部参数名相同（与函数的规则一样） 123456789class Person &#123; var name: String // 定义一个带参数的构造器 init(outName name: String) &#123; self.name = name &#125;&#125;let p1 = Person(&quot;bomo&quot;) // 报编译错误，需要指定外部参数名var p2 = Person(outName: &quot;&quot;) 如果想忽略外部参数名，可以使用_代替外部参数名 12345678class Person &#123; var name: String // 定义一个带参数的构造器 init(_ name: String) &#123; self.name = name &#125;&#125;let p = Person(&quot;bomo&quot;) // 编译通过 九、构造器总结属性 如果所有成员都进行了初始化，并且没有提供构造器，编译器会自动为类生成一个无参数构造器，如果是结构体，那么还会生成一个带所有参数的构造器 指定构造器和便利构造器 指定构造器总是纵向向上代理，便利构造器总是横向代理 便利构造器只能调用当前类内的构造器 便利构造器最终需调用指定构造器 4种检查 指定构造器必须保证所有的成员属性都被初始化 指定构造器（如果有父类）必须最终调用父类的构造器 指定构造器调用父类构造器之前必须保证当前类的所有成员已完成初始化 继承 父类构造器通常情况下不会被子类继承，只有子类无构造器的时候才会 子类可以通过super调用父类的指定构造器，不能调用父类的便利构造器 如果有父类，所有的构造器最终都必须调用父类的指定构造器 使用父类的属性之前，必须先调用父类的构造器，再使用","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://zhengbomo.github.io/tags/swift/"}]},{"title":"swift学习笔记","slug":"swift-start","date":"2016-06-28T07:00:04.000Z","updated":"2016-12-16T07:00:04.000Z","comments":true,"path":"2016-06-28/swift-start/","link":"","permalink":"http://zhengbomo.github.io/2016-06-28/swift-start/","excerpt":"一直没有时间好好看一下swift，最近复习了一遍语法，这里记录swift学习过程中遇到的一些问题和要点，和Object-C的一些相关特性这里也不做介绍，只记录swift特有的一些特性swift借鉴了很多语言的语法，特别是脚本语言，在swift里，可以看到python语言的一些影子，还有其他编程语言的影子","text":"一直没有时间好好看一下swift，最近复习了一遍语法，这里记录swift学习过程中遇到的一些问题和要点，和Object-C的一些相关特性这里也不做介绍，只记录swift特有的一些特性swift借鉴了很多语言的语法，特别是脚本语言，在swift里，可以看到python语言的一些影子，还有其他编程语言的影子 一、基础语法 swift语句结束不需要分号（写了也没有问题），有一种情况需要分号，如果一行代码中有多条语句，这时候就必须要分号隔开 swift字符串，数组语法糖，字典语法糖不需要@标示 swift是类型安全的语言，所有的类型都不会自动转换（如：Int和UInt类型不能直接运算），同事swift具有强大的类型推测，所以很多时候我们不需要声明类型 swift的多行注释支持嵌套123/* 这是第一个多行注释的开头/* 这是第二个被嵌套的多行注释 */这是第一个多行注释的结尾 */ swift的布尔值使用小写true和false，判断语句只能使用Bool类型 二、数据类型 与objc一样，swift支持以前（objc）使用的所有数据类型，swift的类型名字首字母大写，如Int, Float, NSInteger swift支持可选类型（Optionals）类型，相当于C#中的可空类型，标识变量可能为空，基础数据类型也可为空，可选类型不能直接赋非可选类型12var a: Int? = 10var b: Int = a // 报错，不同类型不能赋值 swift的布尔类型使用true/false，而不用YES/NO swift支持使用_来分割数值来增强可读性而不影响值，如一亿可以表示为下面形式1let oneMillion = 1_000_000 swift数值类型进行运算符计算的时候不会自动进行类型转换，通常可以通过类型的构造方法进行类型转换1234var a: Int = 12var b: Float = 23var c = a + b // 报错var d = Float(a) + b // 正确 swift的基础数据类型与对象类型一视同仁，可以混用，不需要装箱和拆箱 TODO：Any, AnyObject,三、常量变量 与C/Obj-C不同，swift的常量更为广义，支持__任意类型__，常量只能赋值一次 swift的变量和常量在声明的时候类型就已经确定（由编译器自动识别或开发者指定） 使用let声明的集合为可变集合，使用var声明的集合为不可变集合 如果你的代码中有不需要改变的值，请使用 let 关键字将它声明为常量。只将需要改变的值声明为变量。这样可以尽量数据安全，并且常量是线程安全 123456789101112// 常量：使用let声明，赋值后就不能再修改let a = NSMutableArray()let b = 12let c: Float = 12 // 类型标注(type annotation)let d = b + 12a.addObject(11) // str == [11]let e = a // str == [11], d == [11]a.addObject(12) // str == [11, 12], d == [11, 12]// 变量：使用var声明var f: Double? = 12var g = &quot;hello world&quot; 类型标注在声明变量和常量的时候可以如果可以由编译器自动识别，可以不用制定类型，如下 12let a = 12 //常量a会编译为Int类型var b = 1.3 //变量b会编译为Double类型 我们也可以指定类型 12let a: Double = 12let b: Float = 1.3 可以在一行声明多个变量&#x2F;常量，在最后一个声明类型 1var red, green, blue: UInt 四、序列和集合1. 数组Arrayswift的数组可以是有类型的（泛型），存放同类型的数据，如果添加一个错误的类型会报编译错误，默认情况下编译器会自动识别 12345678910111213141516171819202122232425262728293031323334//1. 数组的写法为：Array&lt;Int&gt;，也可以简写成[Int]//2. 数组初始化与NSArray类似，直接用中括号括起来，里面值用逗号隔开var array0 = [Int]()var array1: [Int] = [1, 3, 5, 7, 9]var array2: Array&lt;Int&gt; = array1array1.append(11) // [1, 3, 5, 7, 9, 11]array1.insert(0, atIndex: 0) // [0, 1, 3, 5, 7, 9, 11]array1.isEmpty // Falsearray1.count // 7// 3. 如果初始化时不指定类型，而编译器也不能识别出类型，这时候，会被当成NSArray处理var array3 = [] // array3 为 NSArray类型的空数组// 4. 如果声明的时候使用不同的类型，编译器会把数组识别为NSObject类型var array4 = [&quot;fdsa&quot;, 121] // array4 为 Array&lt;NSObject&gt; 类型// 5. 集合支持加法运算，相当于NSMutableArray的addObjectsFromArrayarray1 += [2, 4, 6, 8, 10] // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]// 6. 使用let声明的数组不可变，不能修改数组array3let array5: [Int] = [1, 3, 5, 7, 9]//array5.append(2) // 报编译错误// 7. 集合使用下标索引，支持区间索引，区间不可越界var array6: [Int] = [1, 3, 5, 7, 9]array6[1] = 4 // [1, 3, 5, 7, 9]array6[1...3] = [2, 3, 4] // [1, 2, 3, 4, 9]array6[0...2] = array6[1...3] // [2, 3, 4, 4, 9]// 8. 迭代数组的时候，如果需要索引，可以用enumerate方法for (index, value) in array4.enumerated() &#123; //do something&#125; 2. 字典Dictionary与数组类型一样，字典也支持泛型，其键值类型都可以指定或有编译器识别，其中Key的类型，必须是可Hash的，swift中基础数据类型都是可hash的（String、Int、Double和Bool） 12345678910111213141516171819202122232425// 1. 用法与oc类似，初始化不需要@var dict1 = [&quot;key1&quot;: 1, &quot;key2&quot;: 2, &quot;key3&quot;: 3]// 2. 声明方式var dict2: Dictionary&lt;String, Int&gt; = dict1 //dict2与dict1不是一个对象var dict3: [String: Int] = dict1 //通常采用这种方式声明类型// 3. 不声明类型，编译器又无法识别，则为NSDictionaryvar dict4 = [:]var dict5: [Int: String] = [:]// 4. 修改或添加键值对dict1[&quot;key3&quot;] = 4// 5. 删除键dict1[&quot;key3&quot;] = nil// 6. key不存在不报错，返回可空类型nillet value4 = dict1[&quot;key4&quot;]// 7. 字典迭代返回key/value元组，类似pythonfor (key, value) in dict1 &#123; print(&quot;\\(key) = \\(value)&quot;)&#125; 数组（Array）或字典（Dictionary），如果声明为变量（var），则为可变，如果为常量（let），则为不可变常量数组或字典编译器会对其进行优化，所以尽量把不可变的数组定义为常量数组 3. SetSet集合用于存放无序不重复的对象，用法与数组类似，重复的项会被忽略 123456var s: Set&lt;Int&gt; = [1, 3, 5, 6, 7, 4, 3, 7] // [1, 3, 4, 5, 6, 7]s.counts.isEmptys.insert(3)s.remove(3)s.contains(3) 集合操作 123456789101112131415let oddDigits: Set = [1, 3, 5, 7, 9]let evenDigits: Set = [0, 2, 4, 6, 8]let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]//合操作oddDigits.union(evenDigits).sort() // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]//交操作oddDigits.intersection(evenDigits).sorted() // []//减操作oddDigits.subtracting(singleDigitPrimeNumbers).sorted() // [1, 9]//不重叠集合oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted() // [1, 2, 9] 使用“是否相等”运算符( &#x3D;&#x3D; )来判断两个 合是否包含全部相同的值。 使用 isSubset(of:) 方法来判断一个 合中的值是否也被包含在另外一个 合中。 使用 isSuperset(of:) 方法来判断一个 合中包含另一个 合中所有的值。 使用 isStrictSubset(of:) 或者 isStrictSuperset(of:) 方法来判断一个 合是否是另外一个 合的子 合或 者父 合并且两个 合并不相等。 使用 isDisjoint(with:) 方法来判断两个 合是否不含有相同的值(是否没有交 ) 4. 元组Tuple与python类似，swift也支持元组，可以很方便的使用元组包装多个值，也使得函数返回多个值变得更加方便，特别是临时组建值得时候 支持任意类型 支持同时赋值 支持自定义key，支持索引 元组不是对象，不是AnyObject类型，由于swift是强类型的，所以元组有时不能当做普通的对象使用，例如不能把元组加到数组里面，元组内的所有类型必须是明确的 1234567891011121314151617181920// 1. 声明一个元组，元组支持任意类型let httpError1 = (404, &quot;Not Found&quot;)let point = (100, 50)// 2. 可以分别赋值let (x, y) = pointprint(x) // 100print(y) // 50// 3. 使用下标取元组元素，下标从0开始print(httpError1.0) // 404print(httpError1.1) // Not Found// 4. 可以给数组元素取名let httpError2 = (code: 404, errorMessage: &quot;Not Found&quot;)print(httpError2.code) // 404print(httpError2.errorMessage) // Not Found// 5. 可以用下划线表示忽略部分值let (a, _) = point 元组在临时组织值得时候很有用，可以不用重新定义数据结构 5. 字符串Stringswift字符串是由Character字符组成的集合，支持+操作符，可以与NSString无缝桥接，swift的字符串完全兼容unicode字符串与值类型（与Int, Float）一样，是值类型，在传值的时候都会进行拷贝，当然这回带来一定的性能损耗，swift编译器在编译的时候会进行优化，保证只在必要的情况下才进行拷贝 1234567891011121314151617181920212223242526272829303132// 1. 与NSString不同，声明不需要@前缀，支持转移字符let name1 = &quot;bomo\\n&quot;// 2. 空串（下面两种方式等价）let name2 = &quot;&quot;let name3 = String()// 3. 字符串由字符Character组成，定义字符let character1: Character = &quot;!&quot;// 4. 常见属性，方法name1.isEmpty // 判空name1.characters.count // 获取字符串的字符数name1.uppercaseStringname1.lowercaseStringname1.hasPrefix(&quot;bo&quot;)name1.hasSuffix(&quot;mo&quot;)// 5. 加法运算let hello = &quot;hello &quot; + name1 // hello bomo\\n// 6. 比较（比较值，而不是地址）let name4 = &quot;b&quot; + &quot;omo\\n&quot;name4 == name1 // True// 7. 字符串插值（使用反斜杠和括号站位）let city = &quot;广州&quot;let hello2 = &quot;I&#x27;m \\(name1) from \\(city)&quot;// 8. 格式化字符串let f = 123.3233var s = String(format: &quot;%.2f&quot;, f) //123.32 6. 集合的赋值和拷贝行为swift的集合通常有Array和Dictionary，他们在赋值或传递的时候，行为上有所不同，字典类型Dictionary或数组类型Array在赋值给变量或常量的时候，只要有做修改，就会进行值拷贝，并且不会作用到原来变量上 12345678910111213var dict1 = [&quot;a&quot;: 1, &quot;b&quot;: 2]var dict2 = dict1print(dict1 == dict2) // truedict2[&quot;a&quot;] = 3 // 修改dict2print(dict1 == dict2) // falsevar arr1 = [&quot;a&quot;, &quot;b&quot;]var arr2 = arr1print(arr1 == arr2) // truearr1[0] = &quot;c&quot; // 修改arr1// arr1.append(&quot;c&quot;)print(arr1 == arr2) // false 当数组或字典作为参数传递给函数的时候，由于在Swift3中不推荐使用变量参数，故所有函数参数不可变，故也不进行拷贝 五、可选类型（可空类型）swift加入了可空类型让我们使用数据的时候更为安全，我们需要在可空的地方使用可选类型声明该变量可为空，不能给非可选类型设值nil值，在使用的时候可以明确的知道对象是否可能为nil，有点像ObjC的对象，对象可以为nil，也可以不为nil，而swift得可选类型范围更广可以作用于任何类型（基础类型，类，结构体，枚举） 1. 声明12345678910111213141516171819// 1. 声明可选类型，在类型后面加上?var obj1: NSObject?obj1 = NSObject()obj1 = nil// 2. 不能给一个可选类型赋nil，下面会报错，var obj = NSObject()obj = nil// 3. 如果声明可选变量时没有赋值，则默认为nilvar i: Int?// 4. 一个函数返回一个可选类型func getdog() -&gt; String? &#123; return &quot;wangcai&quot;&#125;// 5. 不能把可选类型赋值给非可选类型，下面会报错let cat: String = dog 2. 强制解析可选类型不能直接使用，需要通过取值操作符!取得变量的值，才能使用，如果变量有值，则返回该值，如果变量为空，则会运行时错误 123456789101112var b: Int?var a: Inta = 12b = 13let c = a + b! // 先对b取值，再运算var b: Bool? = nilif b! &#123; // b为空，编译不报错，运行时报错 print(&quot;true&quot;)&#125; else &#123; print(&quot;false&quot;)&#125; 3. 可选绑定使用可选绑定可以判断一个可选类型是否有值，如果有值，则绑定到变量上，如果没有值，返回false，使用if-let组合实现 123456var i: Int? = nilif let number = i &#123; print(&quot;\\(number)&quot;)&#125; else &#123; print(&quot;nil&quot;)&#125; 可选绑定还支持绑定条件 123456var i: Int? = nilif let number = i where i &gt; 10 &#123; print(&quot;i不为空且大于10 \\(number)&quot;)&#125; else &#123; print(&quot;nil&quot;)&#125; 可选绑定还支持多个绑定，不许所有的绑定都满足才返回true 123456789if let firstNumber = 1, let secondNumber = 2)&#125;// 输出 &quot;4 &lt; 42 &lt; 100&quot; if let firstNumber = Int(&quot;4&quot;) &#123; if let secondNumber = Int(&quot;42&quot;) &#123; if firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 &#123; print(&quot;\\(firstNumber) &lt; \\(secondNumber) &lt; 100&quot;)&#125; &#125;&#125; 4. 隐式解析声明类型的时候可以使用隐式解析，即在使用可选变量的时候自动取值，不需要调用!操作符， 12345678// 一个函数返回一个可选类型func getdog() -&gt; String? &#123; return &quot;wangcai&quot;&#125;//假定我们通过getdog方法返回的值一定不为空var dog: String? = getdog()let cat: String = dog! // 使用前需要通过!强制取值 使用dog的时候都需要取值我们觉得太麻烦了，可以声明成隐式可选类型，使用的时候自动取值 12var dog: String! = getdog() // 实际上dog还是可选类型，只是使用的时候回自动取值let cat: String = dog // 在使用dog的时候会自动进行取值，不需要取值操作符 5. 可选类型自判断链接在使用可选类型之前，需要进行判断其是否有值，才能使用，通过!操作符取值后使用（保证有值的情况下），或通过if-let可选绑定的方式，swift提供了一种类似C#语言的语法糖可以让代码更为简洁，可以自动判断值，如果有值，则操作，无值则不操作，并返回nil，在使用前加上? 1234567891011121314151617class Person &#123; var favDog: Dog?&#125;class Dog &#123; var name: String?&#125;var p = Person()var d = Dog()// p.favDog = dp.favDog?.name = &quot;tobi&quot; // 如果p.favDog为空，不设置nameif let name = p.favDog?.name &#123; // p.favDog不为空且p.favDog.name不为空&#125; else &#123; // p.favDog为空或p.favDog.name为空&#125; 自判断链接还支持多连接如 1let identifier = john.residence?.address?.buildingIdentifier 6. 可选关联运算符可选关联运算符可对可选类型进行拆包，如果可选类型对象为nil，返回第二个操作数，第二个操作数类型必须和第一个操作数同类型（可选或不可选） 1234let defaultColorName = &quot;red&quot;var userDefinedColorName: String? // defaults to nilvar colorNameToUse = userDefinedColorName ?? defaultColorName defaultColorName和userDefinedColorName必须是同类型（String或String?） 如果userDefinedColorName不为空，返回其值，如果userDefinedColorName为空，返回defaultColorName 返回值colorNameToUse的类型同??的第二个操作数的类型，为String 六、运算符swift运算符在原有的基础上做了一些改进，还添加了一下更高级的用法，还有新的运算符 =运算符不返回值 符合运算符+=, -=等不返回值 12//下面语句会报错let b = a *= 2 比较运算符可以用于元组的比较（逐个比较，如果遇到不等的元素，则返回，默认最多只能比较7个元素的元组，超过则需要自定义） 1(1, &quot;zebra&quot;) &lt; (2, &quot;apple&quot;) // true，因为 1 小于 2 字符串String，字符Character支持+运算符 浮点数支持%求余运算 18 % 2.5 // 等于 0.5 ++/--运算在swift3被抛弃，用+=/-=代替 支持溢出运算符（&amp;+, &amp;-, &amp;*），可以在溢出时进行(高位)截断 支持位运算符（&gt;&gt;, &lt;&lt;） 支持三目运算符（a ? b : c） 支持逻辑运算符（&amp;&amp;, ||, !） 与其他高级语言类似，swift运算符支持重载，可以为类添加自定义的运算符逻辑，后面会讲到 !=, ==, ===, !==（恒等于&#x2F;不恒等于）===：这两个操作符用于引用类型，用于判断两个对象是否指向同一地址!===：与===相反，表示两个变量&#x2F;常量指向的的地址不同==：表示两个对象逻辑相等，可以通过重载运算符实现相等的逻辑，两个值相等的对象可以是不同地址的对象!=：与==相反，表示两个对象逻辑不等 区间运算符 可以使用a...b表示一个范围，有点类似于Python的range(a, b) 123for i in 1...5 &#123; print(i) // 1, 2, 3, 4, 5&#125; a...b: 从a到b并包含a和b a..&lt;b: 包含a不包含b a..b表示半闭区间的用法已经被放弃 范围运算符也可以作用于字符串 12let az = &quot;a&quot;...&quot;z&quot; // 返回的是CloseInteval或HalfOpenIntervalaz.contains(&quot;e&quot;) // True 空合运算符??（与C#类似） 对于可选类型取值，如果不为空则返回该值，如果为空则去第二个操作数 1let result = a ?? b 七、流程控制swift使用三种语句控制流程：for-in、for、switch-case、while和repeat-while，且判断条件的括号可以省略 12345678let names = [&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;]for name in names &#123; print(&quot;Hello, \\(name)!&quot;)&#125;//如果不需要使用到迭代的值，使用下划线`_`忽略该值for _ in 1...10 print(&quot;hello&quot;) 流程控制语句的条件返回值必须是Bool，下面会报错 1234var dd: Bool? = trueif dd &#123; print(&quot;fd&quot;)&#125; 条件判断可以与let结合使用，当值为nil时，视为false（即：可选绑定） 1234var dd: Bool? = trueif let ee = dd &#123; print(&quot;fd&quot;)&#125; 在Swift2.0以后，不支持do-while语句，使用repeat-while代替，用法与do-while一样 1234repeat &#123; print(&quot;repeat while : \\(j)&quot;) j++ &#125; while j &lt; 3 guard-else翻译为保镖模式，在执行操作前，进行检查，如果不符合，则拦截，使用方式与if有些类似，如果与let结合使用，可以对可选类型解包，先看看普通的if-else模式 12345678func test(i: Int?) &#123; if let i = i where i &gt; 0 &#123; // 符合条件的处理 return &#125; // 不符合条件的处理&#125; 上面的处理把条件放在了条件判断内部，使用guard与之相反，把正确的情况放在最外部，而异常情况放在条件判断内部 123456789func test(i: Int?) &#123; guard let i = i where i &gt; 0 else &#123; // 在这里拦截，处理不符合条件的情况 return &#125; // 符合条件的处理，这个时候已经对i进行了拆包，i是非可选类型，可以直接使用 print(i)&#125; 保镖模式可以避免代码中过多的流程判断代码导致过多的代码块嵌套，增强可读性 保镖模式guard-else内的代码块必须包含break, return等跳出代码块的关键字 switch-case switch语句支持更多数据类型（String，Int, Float, 元组, 枚举），理论上switch支持任意类型的对象（需要实现~=方法或Equatable协议，详情参见这里） case可以带多个值，用逗号隔开 case可以支持区间（a...b），支持元组，区间可以嵌套在元组内使用 case多条语句不需要用大括号包起来 case语句不需要break，除了空语句，如果需要执行下面的case，可以使用fallthrough 如果case不能命中所有的情况，必须要default，如Int，String类型，否则编译会失败 可以用fallthrough关键字声明接着执行下一条case语句，注意，如果case语句有赋值语句（let），则fallthrough无效 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 定义一个枚举enum HttpStatus &#123; case ServerError case NetworkError case Success case Redirect&#125;var status = HttpStatus.Redirectswitch status &#123;// case可以接收多个值case HttpStatus.ServerError, HttpStatus.NetworkError: print(&quot;error&quot;) // case语句结束显式写break，除非是空语句case .Redirect: // 如果编译器可以识别出枚举类型，可以省略枚举名 print (&quot;redirect&quot;) fallthrough // 像C语言一样，继续执行下一条casecase HttpStatus.Success: print(&quot;success&quot;)&#125;//元组，区间let request = (0, &quot;https://baidu.com&quot;)switch request &#123;case (0, let a): // 支持绑定 print(a)case let (a, b) where a == 1: // 绑定可以卸载元组外面，支持where判断 print(&quot;cancel \\(b)&quot;)case (2...10, _): // 支持区间，支持忽略值 print(&quot;error&quot;)default: print(&quot;unknown&quot;)&#125;// case可以与where进行进一步判断let request2 = (0, 10)switch request2 &#123;case (0, let y) where y &lt; 5:&quot;success&quot; //被输出case (0, let y) where y &gt;= 5:&quot;error&quot; //被输出default: &quot;unknown&quot;&#125; case除了和swift一起使用外，还支持与if语句结合使用，用法与switch一样 123456let bb = (12, &quot;bomo&quot;)if case (1...20, let cc) = bb where cc == &quot;bomo&quot; &#123; print(cc)&#125; else &#123; print(&quot;nil&quot;)&#125; 带标签的语句如果有多层嵌套的情况下，有时候我们需要在某处直接退出多层循环，在objc下并没有比较好的方式实现，需要添加退出标识，然后一层一层退出，而在swift可以很方便的退出多层循环，首先需要使用标签标识不通的循环体，形式如下 1labelName : while condition &#123; statements &#125; 看下面例子 12345678910111213141516outerLoop1 : for i in 1...10 &#123; outerLoop2 : for j in 1...10 &#123; outerLoop3 : for k in 1...10 &#123; if j &gt; 5 &#123; // 1. 跳出一层循环（默认）继续outerLoop2的循环 break // 2. 跳出两层循环，继续outerLoop1的循环 // break outerLoop2 // 3. 跳出三层循环，退出整个循环，继续后面的语句 // break outerLoop1 &#125; &#125; &#125;&#125; 八、函数1. 基本形式123456789101112131415161718192021222324//有返回值func 函数名(参数名1:参数类型1, 参数名2:参数类型2) -&gt; 返回值类型 &#123; // 函数体&#125;//多个返回值（元组）func getPoint() -&gt; (x: Int, y: Int) &#123; return (1, 3)&#125;var p = getPoint()p.x//无参数无返回值func sayHello() &#123; // 函数体&#125;//eggfunc add(a: Int, b: Int) -&gt; Int &#123; return a + b&#125;// 调用add(12, b: 232) 函数调用除了第一个参数，后面所有的参数必须带上参数名（符合Objc的函数命名规则）如果是调用构造器，第一个参数也需要显示声明 123456789101112131415class A &#123; var name: String init(name: String) &#123; self.name = name &#125; func sayHello(msg: String, count: Int) &#123; for _ in 1...count &#123; print (msg) &#125; &#125;&#125;let a = A(name: &quot;bomo&quot;) // 构造器所有参数都必须显示声明参数名a.sayHello(&quot;hello&quot;, count: 2) // 函数参数除了第一个其他都需要显示声明参数名 2. 可变参数可变参数只能作为最后一个参数，一个方法最多只有一个可变参数 1234567func sum(numbers: Int...) -&gt; Int &#123; var sum = 0 for number in numbers &#123; sum += number &#125; return sum&#125; 3. 外部参数名默认情况下，如果不指定外部参数名，swift编译器会自动为函数参数声明与内部参数名同名的外部参数名（格式为：外部参数名 内部参数名: 类型名） 1234567//默认情况下，外部参数名与内部参数名一样func add(first a: Int, second b: Int) -&gt; Int &#123; return a + b&#125;// 调用add(first: 10, second: 20) 如果函数在第一个参数定义外部参数名，必须显示指定，当然我们还可以通过下划线_让函数忽略参数名 1234func add(a: Int, _ b: Int) -&gt; Int &#123; return a + b&#125;add(1, 2) 4. 函数默认值函数还支持声明默认值，（格式为：外部参数名 内部参数名: 类型名 = 默认值） 1234567func log(msg: String, isDebug: Bool = true) &#123; if isDebug &#123; print(msg) &#125;&#125;log(&quot;fail&quot;)log(&quot;success&quot;, isDebug: false) 如果使用默认值并且默认值不是出现在最后，那调用的时候必须写全所有参数 建议把默认参数放到最后面，这样可以确保非默认参数的赋值顺序，减少参数混乱的情况 5. 闭包 函数作为变量 函数作为函数参数 函数作为函数返回值 闭包函数声明123456789101112131415161718192021222324252627282930func add(a: Int, b: Int) -&gt; Int &#123; return a + b&#125;//函数作为变量，函数hello赋给somefunc，并调用let somefunc: (Int, Int) -&gt; Int = addsomefunc(10, 20) // 30//函数作为参数func logAdd(a:Int, b:Int, function: (Int, Int) -&gt; Int) &#123; // 函数内容 print(&quot;begin&quot;) function(a, b) print(&quot;end&quot;)&#125;logAdd(12, b: 23, function: add)//函数作为返回值（包装一个函数，在执行前后输出信息），函数作为参数又作为返回值func addWrapper(addFunc: (Int, Int) -&gt; Int) -&gt; ((Int, Int) -&gt; Int) &#123; // 函数内容 func wrapper(a: Int, b: Int) -&gt; Int &#123; print(&quot;begin&quot;) let res = addFunc(a, b) print(&quot;end&quot;) return res &#125; return wrapper&#125;var newAdd = addWrapper(add)newAdd(12, 32) 闭包函数声明形式 123&#123; (parameters) -&gt; returnType in statements // 可以有多行&#125; 闭包函数 1234567891011121314151617181920//定义一个函数变量var addfunc: (Int, Int) -&gt; Int//闭包的写法// 1. 完整写法addfunc = &#123;(a: Int, b: Int) -&gt; (Int) in //var c = a + 1 //函数体可以有多条语句，如果在同一行，需要用分号隔开，函数体不需要大括号 return a + b&#125;// 2. 前面的addfunc变量可以推断出后面函数的参数类型和返回值类型，故可以省略addfunc = &#123;(a, b) in return a + b&#125;// 3. 参数列表括号可以省去，函数只有一条语句时，return可以省略addfunc = &#123;a, b in a + b&#125;// 4. 参数和in可以省去，通过$和索引取得参数addfunc = &#123;$0 + $1&#125;// 操作符需要的参数与函数参数一致，可以省去参数，并使用括号括起来，作为参数时，可不用括号addfunc = (+) 6. Trailing(尾行)闭包如果函数作为另一个函数的参数，并且是最后一个参数时，可以通过Trainling闭包来增强函数的可读性 123456789101112131415161718func someFunctionThatTakesAClosure(a: Int, closure: () -&gt; ()) &#123; // 函数体部分&#125;// 1. 一般形式someFunctionThatTakesAClosure(10, closure: &#123; // 闭包主体部分&#125;)// 2. Trainling闭包的方式someFunctionThatTakesAClosure(10) &#123; // 闭包主体部分&#125;// 3. 如果没有其他参数时，可以省略括号someFunctionThatTakesAClosure &#123; // 闭包主体部分&#125; 7. Escaping（逃逸）闭包如果一个闭包&#x2F;函数作为参数传给另外一个函数，但这个闭包在传入函数返回之后才会执行，就称该闭包在函数中”逃逸”，需要在函数参数添加@escaping声明，来声明该闭包&#x2F;函数允许从函数中”逃逸”，如下 123456var completionHandlers: [() -&gt; Void] = []// 传入的闭包/函数并没有在函数内执行，需要在函数类型钱添加@escaping声明func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) &#123; completionHandlers.append(completionHandler)&#125; 逃逸闭包只是一个声明，以增强函数的意图 8. 自动闭包对于没有参数的闭包，swift提供了一种简写的方式，直接写函数体，不需要函数形式（返回值和参数列表），如下 12345// 声明一个自动闭包（无参数，可以有返回值，返回值类型swift可以自动识别）let sayHello = &#123; print(&quot;hello world&quot;) &#125;//调用闭包函数sayHello() 自动闭包只是闭包的一种简写方式 如果一个函数接受一个不带参数的闭包 12345func logIfTrue(predicate: () -&gt; Bool) &#123; if predicate() &#123; print(&quot;True&quot;) &#125;&#125; 调用的时候可以使用自动闭包 1234logIfTrue(predicate: &#123; return 1 &lt; 2 &#125;)// 可以简化returnlogIfTrue(predicate: &#123; 1 &lt; 2 &#125;) 上面代码看起来可读性不是很好，swift引入了一个关键字@autoclosure，简化自动闭包的大括号，在闭包类型前面添加该关键字声明 12345678func logIfTrue(predicate: @autoclosure () -&gt; Bool) &#123; if predicate() &#123; print(&quot;True&quot;) &#125;&#125;// 调用logIfTrue(predicate:1 &lt; 2) @autoclosure 关键字是为了简化闭包的写法，增强可读性，这里的例子比较简单，可以参考：@AUTOCLOSURE 和 ?? 9. 常量参数和变量参数默认情况下所有函数参数都是常量，意味着参数是不可变的，我们可以显式的声明参数为变量 12345678func log(msg: String) &#123; msg = &quot;begin &quot; + msg + &quot; end&quot; // 会报错，因为msg为常量 print(msg)&#125;func log(var msg: String) &#123; msg = &quot;begin &quot; + msg + &quot; end&quot; // 变量参数正常运行 print(msg)&#125; 注：变量参数在swift3被抛弃 10. 输入输出参数在c语言里有指针，可以通过传址直接修改外部变量的值，在swift通过inout关键字声明函数内部可直接修改外部变量，外部通过&amp;操作符取得变量地址 1234567func swap(inout a: Int, inout b: Int) &#123; let temp = a a = b b = temp&#125;var a = 19, b = 3swap(&amp;a, &amp;b) 11. 嵌套函数swift的函数还支持嵌套，默认情况下，嵌套函数对外部不可见，只能在函数内部使用 1234567func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int &#123; //定义两个内部函数 func stepForward(input: Int) -&gt; Int &#123; return input + 1 &#125; func stepBackward(input: Int) -&gt; Int &#123; return input - 1 &#125; return backward ? stepBackward : stepForward&#125; 嵌套函数相当于objc函数内的block 12. defer在swift2.0之后添加了defer关键字，可以定义代码块在函数执行完成之前的完成一些操作，并且在函数抛出错误的时候也可以执行 12345678910111213141516171819202122232425func test() &#123; print(&quot;begin1&quot;) defer &#123; // 入栈 print(&quot;end1&quot;) &#125; print(&quot;begin2&quot;) defer &#123; // 入栈 print(&quot;end2&quot;) &#125; if true &#123; print(&quot;begin4&quot;) defer &#123; print(&quot;end4&quot;) &#125; print(&quot;begin5&quot;) defer &#123; print(&quot;end5&quot;) &#125; &#125; print(&quot;do balabala&quot;) return&#125; 上面输出结果为 123456789begin1begin2begin4begin5end5end4do balabalaend2end1 通常可以用在需要成对操作的逻辑中（如：open/close） 九、枚举swift的枚举比C语言的枚举更为强大，支持更多特性，swift的枚举更像类和结构体，支持类和结构体的一些特性，与ObjC不同，如果不声明枚举的值，编译器不会给枚举设置默认值 枚举与结构体一样，是值类型 1. 声明和使用1234567891011121314151617181920212223242526272829303132// 1. 定义枚举enum CompassPoint &#123; case North case South case East case West&#125;// 2. 可以把枚举值定义在一行，用逗号隔开enum CompassPoint2 &#123; case North, South, East, West&#125;// 3. 像对象一样使用枚举，代码结构更为清晰，枚举更为简短let direction = CompassPoint.East// 4. 如果编译器可以识别出枚举的类型，可以省略枚举名let direction2: CompassPointdirection2 = .East// 5. 如果编译器能确定case命中所有的情况，可以不需要defaultswitch direction &#123;case .East: print(&quot;east&quot;)case .West: print(&quot;west&quot;)case .South: print(&quot;south&quot;)case .North: print(&quot;north&quot;) //所有值都被枚举，则不需要default&#125; 2. 嵌套枚举swift的枚举定义支持嵌套，在使用的时候一层一层引用 1234567891011121314151617181920enum Character &#123; enum Weapon &#123; case Bow case Sword case Lance case Dagger &#125; enum Helmet &#123; case Wooden case Iron case Diamond &#125; case Thief case Warrior case Knight&#125;let character = Character.Thieflet weapon = Character.Weapon.Bowlet helmet = Character.Helmet.Iron 3. 递归枚举枚举的关联值的类型可以设为枚举自身，这样的枚举称为递归枚举 12345enum ArithmeticExpression &#123; case number(Int) indirect case addition(ArithmeticExpression, ArithmeticExpression) indirect case multiplication(ArithmeticExpression, ArithmeticExpression)&#125; 带递归类型的枚举需要在case前面添加关键字声明indirect，也可以在enum前面加上声明，表示所有的成员是可以递归的 12345indirect enum ArithmeticExpression &#123; case number(Int) case addition(ArithmeticExpression, ArithmeticExpression) case multiplication(ArithmeticExpression, ArithmeticExpression)&#125; 使用递归枚举取值的时候可以使用递归函数 123456789101112131415161718func evaluate(_ expression: ArithmeticExpression) -&gt; Int &#123; switch expression &#123; case let .number(value): return value case let .addition(left, right): return evaluate(left) + evaluate(right) case let .multiplication(left, right): return evaluate(left) * evaluate(right) &#125;&#125;let five = ArithmeticExpression.number(5)let four = ArithmeticExpression.number(4)let sum = ArithmeticExpression.addition(five, four)// (5 + 4) * 2let product = ArithmeticExpression.multiplication(sum, ArithmeticExpression.number(2))print(evaluate(product)) 其实感觉这种嵌套多层的用法可读性并不是特别好，而且在取值的时候还需要递归，通常来说，嵌套一层就够了 4. 原始值与C语言一样，可以为每个枚举指定值，并且可以支持更多类型（Int, Float, Character, String） 1234567891011121314151617181920212223242526272829303132// 定义枚举，并初始化原始值enum ASCIIControlCharacter: Character &#123; case Tab = &quot;\\t&quot; case LineFeed = &quot;\\n&quot; case CarriageReturn = &quot;\\r&quot;&#125;// 2. 通过两个属性获得原始值var ch = ASCIIControlCharacter.Tabch.hashValue // 获取是否有原始值ch.rawValue // 获得原始值// 3. 通过原始值构造枚举，如果不存在，则返回nilvar tab = ASCIIControlCharacter.init(rawValue: &quot;\\t&quot;)// 4. 如果是原始值是整形值，后面的值默认自增1，如果不指定，则默认为空，而不是从0开始enum Planet: Int &#123; case Mercury = 1, Venus // Venus = 2 case Neptune // Neptune = 3&#125;// 5. 如果没有指定枚举原始值的类型，则默认为空，而不是整型enum CompassPoint &#123; case North case South case East case West&#125;//swift 不会为North, South, East, West设置为0,1,2,3，并且CompassPoint没有原始值（rawValue）// 6. 有原始值的枚举可以通过原始值构造（构造器返回可选类型）let lineFeed = ASCIIControlCharacter(rawValue: &quot;\\n&quot;) 5. 关联值上面我们说到，枚举与类和结构体类似，swift的枚举可以给不同的枚举值绑定关联值，如下 1234567891011121314enum Barcode &#123; case UPCA(Int, Int, Int) //条形码，关联一个元组 case QRCode(String) //二维码，关联一个字符串&#125;var productBarcode = Barcode.UPCA(8, 85909_51226, 3)// var productBarcode = .QRCode(&quot;http://www.baidu.com&quot;)switch productBarcode &#123;case .UPCA(let a, let b, let c): //在枚举的时候可以取得关联值 print(&quot;barcode: \\(a)\\(b)\\(c)&quot;)case let .QRCode(value): print(&quot;qrcode: \\(value)&quot;)&#125; 如上面这种轻量的数据，在OC上一般我们可能需要定义两个类实现，而swift的枚举可以轻松的处理这种轻量数据，而减少项目中类的定义和维护 十、类与结构体先来看看结构体和类的一些差异 类是引用类型，结构体为值类型 类使用引用计数管理内存，结构体分配在栈上，有系统管理内存，变量传递的时候，结构体整个拷贝，而类默认只传递引用地址（有些类会进行一些额外的拷贝，详见深拷贝和浅拷贝） 结构体不支持继承，类支持继承 与ObjC不同，swift的结构体可以定义方法 类支持运行时类型检查，而结构体不支持 类有构造器和析构器，结构体只有构造器 常量结构体的成员的值不能改变 实际上，在 Swift 中，所有的基本类型:整数(Integer)、浮 点数(floating-point)、布尔值(Boolean)、字符串(string)、数组(array)和字典(dictionary)，都是 值类型，并且在底层都是以结构体的形式所实现。 1. 结构体，类定义1234567891011121314151617181920212223242526struct Point &#123; let x: Int let y: Int func printPoint() &#123; print(&quot;x=\\(x), y=\\(y)&quot;) &#125;&#125;class Person &#123; var someObj = NSObject() // 定义属性，并初始化 var name: String // 定义属性，并指定类型 init(name: String) &#123; // 构造函数 self.name = name &#125; func hello() &#123; print(&quot;hello \\(self.name)&quot;) &#125; //析构函数 deinit &#123; print(&quot;dealloc&quot;) &#125;&#125; swift中，许多基本类型如String, Array和Dictionary都是用结构体实现的，意味着在传递的时候都会进行值拷贝，当然swift也对这些类型进行了优化，只有在需要的时候进行拷贝 2. 静态属性，静态方法swift中有两个static和class声明静态变量或方法，其中class只能用在类的方法和计算属性上，其他的都使用static，由于类支持继承，所以使用class声明的静态方法可以被继承，而static声明的静态方法不能被继承 12345678910111213141516class Person &#123; static var instanceCount: Int = 0 // 声明一个类属性 init () &#123; Person.instanceCount += 1 // 通过类名引用类属性，子类可以访问基类的类属性 &#125; // 使用class声明的静态方法可以被继承 class func overrideableComputedTypeProperty() &#123; print(&quot;\\(Person.instanceCount)&quot;) &#125; // 使用static声明的静态方法不能被继承 static func printInstanceCount() &#123; // 声明一个静态方法 print(&quot;\\(Person.instanceCount)&quot;) &#125;&#125; 类和结构体的声明和用法与类类似，使用static 注意：class只能用来声明计算属性和方法，不能用来声明普通属性 3. 构造器和析构器swift的构造器规则和限制比较多，关于构造器可以参见：这里 析构器相当于objc里面的dealloc方法，做一些需要手动释放资源的操作，析构器与构造器不同，没有参数，定义的时候不需要括号，类在释放的之前会自动调用父类的析构器，不需要主动调用 12345class Person &#123; deinit &#123; print(&quot;释放额外的资源，如通知&quot;) &#125;&#125; 4. 类型判断在objc中，我们通常使用isKindOfClass, isMemberOfClass, isSubclassOfClass等方法进行类型判断，swift使用is和as判断类型 123456789101112131415class Parent &#123;&#125;class Son: Parent &#123;&#125;var s = Son()// isKindOfClassson is Son // trueson is Parent // true// isMemberOfClassson.dynamicType == Son.self // trueson.dynamicType == Parent.self // false// isSubclassOfClass 暂时没找到相关的API &#x2F;&#x2F;TODO: swift动态性，反射 5. 弱引用与ObjC一样，swift的内存管理也使用引用计数管理，也使用weak声明弱引用变量 123class Person &#123; weak var person: Person? = nil&#125; 6. 访问级别在swift中，framework和bundle都被处理成模块 * public：公开，可以被外部访问 * internal：内部，在模块（framework）内部使用，模块外访问不到 * private：只能在当前源文件中使用 swift默认的访问级别为Internal，使用的时候只需要在类&#x2F;变量&#x2F;函数前面加上访问级别即可 123456789101112131415public class Person &#123; class public var peopleCount: Int = 0 // 类变量，通过class声明，类变量使用时使用类名引用 internal var age: Int // 实例变量 var name: String // 不声明，则为internal init() &#123; self.age = 0 self.name = &quot;&quot; Person.peopleCount++ // 使用静态变量 &#125; private func sayHello() &#123; print(&quot;hello&quot;) &#125;&#125; 外层访问级别的必须是比成员更高，下面会报警告 1234567class Person &#123; // 默认为internal public var age: Int = 0 // 为public，比类访问级别高，会有警告 private var gender: Int = 10 private func sayHello() &#123; print(&quot;hello&quot;) &#125;&#125; 函数的访问级别要比参数(或泛型类型)的访问级别低，否则会报警告 12345678910111213private class PrivatePerson &#123; private var age: Int = 0 var gender: Int = 10 // 报警告 private func sayHello() &#123; &#125;&#125;public class Test &#123; public func test(person:PrivatePerson) &#123; //报编译错误：这里参数访问级别为private，所以函数访问级别不能高于private，则只能为private &#125;&#125; 枚举类型的成员访问级别跟随枚举类型，嵌套类型默认最高访问级别为internal（外层为public，内层默认为internal） 123456public enum CompassPoint &#123; case North // 四个枚举成员访问级别都为public case South case East case West&#125; 子类访问级别不能高于父类（包括泛型类型），协议继承也同理，子协议访问级别不能高于父协议 1234567class Parent &#123;&#125;public class Son: Parent &#123; // 报编译错误：Son访问级别必须低于Parent，应该为internal或private&#125; 元组的访问级别为元组内所有类型访问级别中最低级的 123456789class Parent &#123;&#125;private class Son: Parent &#123;&#125;public class SomeClass &#123; internal let sometuple = (Son(), Parent()) // 报编译错误：sometuple的访问级别不能高于成员类型的访问级别，由于Son为private，故sometuple必须为private&#125; 变量的访问级别不能高于类型 1234567private class PrivateClass &#123;&#125;public class SomeClass &#123; public var value: PrivateClass // 报编译错误：变量value的访问级别不能高于其类型，故value必须声明为private&#125; 属性的 Setter 访问级别不能高于 Getter访问级别 12345public class SomeClass &#123; private(set) var num = 1_000_000 // 声明属性num，getter访问级别没有声明，默认为Internal，setter访问级别为private private internal(set) var name = &quot;bomo&quot; // 报编译错误：属性name的setter访问级别为internal，高于getter访问级别private&#125; 协议与类的访问级别关系 协议中所有必须实现的成员的访问级别和协议本身的访问级别相同 其子协议的访问级别不高于父协议（与类相同） 如果类实现了协议，那类的访问级别必须低于或等于协议的访问级别 类型别名访问级别与类型的关系 类型别名的访问级别不能高于原类型的访问级别； 函数构造函数默认访问级别为internal，如果需要给其他模块使用，需显式声明为public 注意：swift的访问级别是作用于文件（private）和模块的（internal）的，而不只是类，所以只要在同一个文件内，private访问级别在不同类也可以直接访问，例如我们可以通过子类包装父类的方法以改变访问级别 123456789public class A &#123; private func someMethod() &#123;&#125;&#125;internal class B: A &#123; override internal func someMethod() &#123; // 在同一个文件，改变someMethod的访问级别 super.someMethod() &#125;&#125; 7. 属性 使用关键字lazy声明一个懒加载 变量 属性，当属性被使用的时候（get），才会进行初始化 set方法的访问级别必须必get方法低 声明属性的时候可以使用private(set)和internal(set)改变set方法默认的访问级别 每个实例都有一个self属性，指向实例自身，通常在属性与函数参数有冲突的时候使用 对于常量属性，不许在定义它的类的构造器中赋值，不能再子类赋值 1234567891011121314151617181920212223242526272829303132333435363738394041424344class DataImporter &#123;&#125;class DataManager &#123; // 1. 只有第一次调用importer的get方法的时候才会初始化 lazy var importer = DataImporter() var data = [String]()&#125;class Rectangle &#123; var width: Double = 0.0 var height: Double = 0.0 // 2. 声明get方法和set方法的访问级别 private private(set) var weight: Double = 0 // 3. 自定义get/set方法 var square: Double &#123; get &#123; return (self.width + self.height)/2; &#125; //set &#123; //如果不指定名称，默认通过newValue使用新值 set(newValue) &#123; self.width = newValue/2.0; self.height = newValue/2.0 &#125; &#125; // 4. 只读属性，可以省略get，直接使用一个花括号 var perimeter: Double &#123; return (self.width + self.height) * 2 &#125; // 5. 属性监视器，在初始化的时候不会触发 var someInt: Int = 0 &#123; willSet &#123; //用法与set一样如果不指定名称，默认通过newValue使用旧值 print(&quot;set方法之前触发&quot;) &#125; didSet &#123; //用法与set一样如果不指定名称，默认通过oldValue使用旧值 print(&quot;set方法完成后触发，可以在这里设置obj的值覆盖set方法设置的值&quot;) self.someInt = 0 // someInt的值永远为0，在监视器修改属性的值不会导致观察器被再次调用 &#125; &#125;&#125; 使用lazy声明的属性不是线程安全的，在多线程情况下可能产生多份，需要自己控制 对于结构体，与OC不同，swift的结构体允许直接对属性的子属性直接修改，而不需要取出重新赋值 1someVideoMode.resolution.width = 1280 在oc上需要这样做 123var resolution = someVideoMode.resolutionresolution.width = 1024someVideoMode.resolution = resolution 8. 继承我们都知道，在oc里所有的类都继承自NSObject&#x2F;NSProxy，而在swift中的类并不是从一个通用的基类继承的，所有没有继承其他父类的类都称为基类 12345678910111213141516class Parent &#123; final var gender = &quot;unknown&quot; init(gender: String) &#123; self.gender = gender &#125; private func hello() &#123; print(&quot;parent hello&quot;) &#125;&#125;class Son: Parent &#123; // 重写可以改变父类方法的访问级别 internal override func hello() &#123; // 重写父类方法必须加上override，否则会报编译错误 //super.hello() // 可以通过super访问父类成员，包括附属脚本 print(&quot;son hello&quot;) &#125;&#125; 重写属性的时候，如果属性提供了setter方法，则必须为提供getter方法如果重写了属性的setter方法，则不能重写willSet和didSet方法如果重写了willSet和didSet方法，则不能重写get和set方法 父类的属性，方法，类方法，附属脚本，包括类本身都可以被子类继承和重写，可以通过final约束限制子类的重写（final class, final var, final func, final class func, 以及 final subscript） 1234567891011class Parent &#123; final var gender = &quot;unknown&quot; // 不允许被子类重写 var name: String // 可以被子类重写 init(gender: String) &#123; self.gender = gender self.name = &quot;&quot; &#125; final func hello() &#123; // 不允许被重写 print(&quot;parent hello&quot;) &#125;&#125; swift编译器在识别数组类型的时候，如果数组元素有相同的基类，会被自动识别出来 12345678910111213class Person &#123;&#125;class Teacher: Person &#123;&#125;class Student: Person &#123;&#125;let t1 = Teacher()let t2 = Teacher()let s1 = Student()let s2 = Student()let people = [t1, t2, s1, s2] // people会被识别为[Person]类型 向下类型转换as!, as?，as!返回非可选类型，如果类型不匹配会报错，as?返回可选类型，如果类型不匹配返回nil 1234567for person in people &#123; if let teacher = person as? Teacher &#123; println(&quot;teacher&quot;) &#125; else if let student = person as? Student &#123; println(&quot;student&quot;) &#125;&#125; 9. 附属脚本subscript附属脚本可以让类、结构体、枚举对象快捷访问集合或序列，而不需要调用使用对象内的实例变量引用，看下面实例 12345678910111213class DailyMeal &#123; enum MealTime &#123; case Breakfast case Lunch case Dinner &#125; var meals: [MealTime : String] = [:]&#125;// 如果需要使用DailyMeal的meals对象的，需要这么用var dailyMeal = DailyMeal()dailyMeal.meals[MealTime.Breakfast] = &quot;Toast&quot; 使用附属脚本可以直接通过类对象索引访问meals的值 12345678910111213141516171819202122232425262728class DailyMeal &#123; enum MealTime &#123; case Breakfast case Lunch case Dinner &#125; var meals: [MealTime : String] = [:] // 定义附加脚本，类似属性 subscript(realMealTime: MealTime) -&gt; String &#123; get &#123; if let value = meals[realMealTime] &#123; return value &#125; else &#123; return &quot;unknown&quot; &#125; &#125; set(newValue) &#123; meals[realMealTime] = newValue &#125; &#125;&#125;var dailyMeal = DailyMeal()dailyMeal[.Breakfast] = &quot;sala&quot;print(dailyMeal[.Breakfast]) 附加脚本还支持多个参数 1234567891011121314151617181920212223242526struct Matrix &#123; let rows: Int, columns: Int var grid: [Double] init(rows: Int, columns: Int) &#123; self.rows = rows self.columns = columns grid = Array(count: rows * columns, repeatedValue: 0.0) &#125; func indexIsValidForRow(row: Int, column: Int) -&gt; Bool &#123; return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns &#125; subscript(row: Int, column: Int) -&gt; Double &#123; get &#123; assert(indexIsValidForRow(row, column: column), &quot;Index out of range&quot;) return grid[(row * columns) + column] &#125; set &#123; assert(indexIsValidForRow(row, column: column), &quot;Index out of range&quot;) grid[(row * columns) + column] = newValue &#125; &#125;&#125;var matrix = Matrix(rows: 2, columns: 2)matrix[0, 1] = 1.5matrix[1, 0] = 3.2 附加脚本类似属性，拥有get&#x2F;set方法，支持只读和读写两种方式，附加脚本也支持多个参数，附属脚本可以屏蔽外部对内部对象的直接访问，隐藏对象内部的细节，提高封装度，使得代码更加健壮和简洁 10. 类型嵌套与枚举一样，结构体和类都支持类型嵌套，可以在类里面再定义类&#x2F;结构体&#x2F;枚举 1234567891011121314151617181920212223242526class SomeClass &#123; // 类里面嵌套定义枚举 enum Suit: Character &#123; case Spades = &quot;♠&quot;, Hearts = &quot;♡&quot;, Diamonds = &quot;♢&quot;, Clubs = &quot;♣&quot; // 枚举里面嵌套定义结构体 struct Values &#123; let first: Int, second: Int &#125; &#125; // 类里面嵌套定义结构体 struct Point &#123; let x: Int let y: Int &#125; // 类里面嵌套定义类 class InnerClass &#123; var name: String = &quot;&quot; var id: Int = 0 &#125;&#125;// 使用的时候像属性一样引用let values = SomeClass.Suit.Values(first: 1, second: 2) 11. 类型别名swift类型别名与c语言中取别名有点像，通过关键字typealias声明别名 12345public typealias MyInt = Intfunc add(a: MyInt, b: MyInt) -&gt; MyInt &#123; return a + b&#125; 通常在容易出现命名冲突的情况下会考虑使用类型别名 十一、扩展Extension与oc一样，扩展就是对已有的类添加新的功能，与oc的category类似，swift的扩展可以： 提供新的构造器（需要符合构造器的基本规则） 添加实例计算型属性和类计算性属性 添加实例方法和类方法 添加附加脚本 添加新的嵌套类型 使一个已有类型符合某个接口 swift扩展不可以： 不可以添加存储属性 不可以向已有属性添加属性观测器(willSet, didSet) 123456789101112131415class Person &#123; func hello() &#123; print(&quot;hello&quot;) &#125;&#125;// 定义扩展extension Person &#123; func fly() &#123; print(&quot;fly&quot;) &#125;&#125;let p = Person()p.fly() 扩展也可以作用在结构体和枚举上 12345678910111213struct Rectangle &#123; let width: Double let height: Double&#125;extension Rectangle &#123; var perimeter: Double &#123; return 2 * (self.width + self.height) &#125;&#125;let rect = Rectangle(width: 100, height: 200)print(rect.perimeter) 扩展内的成员定义与类类似，这里不再说明 扩展属性由于swift不能扩展新的属性，有时候我们希望给类添加属性，在oc里可以用关联属性新增存储属性，在swift也可以，需要引入ObjectiveC模块 1234567891011121314151617import ObjectiveCclass Point &#123; var x: Int = 0 var y: Int = 1&#125;private var xoTag: UInt = 0extension Point &#123; var z: Int &#123; get &#123; return objc_getAssociatedObject(self, &amp;xoTag) as! Int &#125; set(newValue) &#123; objc_setAssociatedObject(self, &amp;xoTag, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_ASSIGN) &#125; &#125;&#125; 十二、协议Protocalswift的协议在oc的基础上加了更多的支持，可以支持属性，方法，附加脚本，操作符等，协议的属性必须为变量var 12345678910protocol SomeProtocol &#123; // 属性要求 var mustBeSettable: Int &#123; get set &#125; // 只读属性 var doesNotNeedToBeSettable: Int &#123; get &#125; // 只读静态属性 static var staticProperty: Int &#123; get &#125; // 静态方法 static func hello()&#125; 1. mutating在结构体&#x2F;枚举中的值类型变量，默认情况下不能对其进行修改，编译不通过，如果需要修改值类型的属性，需要在方法声明前加上mutating 12345678910111213141516171819struct Point &#123; var x: Int var y: Int func moveToPoint(point: Point) &#123; self.x = point.x // 报错：不能对值类型的属性进行修改 self.y = point.y // 报错：不能对值类型的属性进行修改 &#125; mutating func moveToPoint2(point: Point) &#123; self.x = point.x // 编译通过 self.y = point.y // 编译通过 &#125; //可变方法还可以对self进行修改，这个方法和moveToPoint2效果相同 mutating func moveToPoint3(x deltaX: Int, y deltaY: Int) &#123; self = Point(x:deltaX, y:deltaY) &#125;&#125; 可变方法还可以修改枚举值自身的值 12345678910111213enum TriStateSwitch &#123; case Off, Low, High mutating func next() &#123; switch self &#123; case .Off: self = .Low case .Low: self = .High case .High: self = .Off &#125; &#125;&#125; 特别是在定义Protocal的时候，需要考虑到协议可能作用于枚举或结构体，在定义协议的时候需要在方法前加上mutating 123protocol SomeProtocol &#123; mutating func moveToPoint(point: Point)&#125; 2. 协议类型协议虽然没有任何实现，但可以当做类型来用，与oc的protocal类似，用协议类型表示实现了该协议的对象，与oc的id&lt;SomeProtocol&gt;一样 3. 协议组合有时候我们需要表示一个对象实现多个协议，可以使用协议组合来表示，如下 1234567891011protocol SwimProtocal &#123; func fly()&#125;protocol WalkProtocal &#123; func walk()&#125;func through(animal: protocol&lt;WalkProtocal, SwimProtocal&gt;) &#123; animal.walk() animal.fly()&#125; 4. 自身类型有时候我们需要表示实现协议的类型，可以使用Self代替，如下 1234567891011protocol CompareProtocal &#123; // Self表示实现协议自己的类型本身 func compare(other: Self) -&gt; Bool&#125;class Product: CompareProtocal &#123; var id: Int = 0 func compare(other: Product) -&gt; Bool &#123; return self.id == other.id &#125;&#125; 5. @objc协议swift声明的协议是不能直接被oc的代码桥接调用的，如果需要，需要在声明前加上@objc，使用@objc声明的协议不能被用于结构体和枚举 1234import Foundation@objc protocol HasArea &#123; // 协议可以被桥接到oc中使用 var area: Double &#123; get &#125;&#125; 6. Optional要求在oc中的protocal可以定义可选方法，在swift默认不支持可选方法，swift只有在添加了@objc声明的协议才能定义可选方法，在定义前添加optional声明 1234import Foundation@objc protocol HasArea &#123; optional var area: Double &#123; get &#125; // 定义可选属性&#125; 十三、错误与其他高级语言异常处理有点类似，swift引入了错误的机制，可以在出现异常的地方抛出错误，错误对象继承自Error，抛出的错误函数会立即返回，并将错误丢给调用函数的函数处理，如果一个函数可能抛出错误，那么必须在函数定义的时候进行声明，如下 1234567891011121314151617181920212223//定义错误类型enum OperationError: Error &#123; case DivideByZero case Other&#125;//定义可能抛出异常的函数，在函数声明的返回值前面加上throwsfunc divide(a: Int, b: Int) throws -&gt; Float &#123; if b == 0 &#123; throw OperationError.DivideByZero &#125; return Float(a) / Float(b)&#125;//调用可能出错的函数（调用出必须加上try）do &#123; let result = try divide(a: 10, b: 0) print(result)&#125; catch OperationError.DivideByZero &#123; print(error)&#125; catch &#123; //其他错误&#125; 如果错误是一个对象，而不是枚举，可以用let绑定到变量上 1234567do &#123; try divide(a: 10, b: 0)&#125; catch let err as SomeErrorType &#123; print(err.message)&#125; catch &#123; print(&quot;other error&quot;)&#125; 如果不处理错误的话可以使用try?，使用try?关键字的方法会被包装到一个可选类型中，如果发生错误，则会返回nil，如下面序列化的例子 123456func serialize(obj: AnyObject) -&gt; String &#123; guard let jsonString = try? someSerializeFuncMayThrowError(obj) else &#123; print(jsonString) &#125; print(&quot;fail&quot;)&#125; try?配合guard let一起使用效果更好 十四、断言断言可以让我们在调试时候更好的发现问题，排查错误，几乎所有的高级语言都支持断言，swift也如此，断言的代码在release的时候回被忽略，不会影响发布程序的性能，只会在调试的时候生效 12// 如果age小于0，程序会停止，并输出错误信息assert(age &gt;= 0, &quot;A person&#x27;s age cannot be less than zero&quot;) 十五、泛型关于泛型的介绍，这里不进行说明，swift的泛型是我认为最酷的特性之一，当然其他语言也有，可以让类或函数更大程度的重用，swift的泛型与其他语言的泛型有点类似 1. 定义在类或函数声明的时候，指定一个泛型类型参数（通常为T）然后使用的时候直接把T当成类型使用 123456789101112131415161718192021//泛型函数定义func swapTwoValues&lt;T&gt;(inout a: T, inout b: T) &#123; let temporaryA = a a = b b = temporaryA&#125;//泛型类定义class Result&lt;T&gt; &#123; var code: Int = 0 var errorMessage: String? var data: T?&#125;//多个泛型类型参数class Result&lt;T, TK&gt; &#123; var code: Int = 0 var errorMessage: String? var data: T? var subData: TK?&#125; 2. 泛型约束我们还可以对泛型进行约束，泛型类型参数只能是某些类型的子类，或实现了某些协议 12345678func findIndex&lt;T&gt;(array: [T], valueToFind: T) -&gt; Int? &#123; for (index, value) in array.enumerate() &#123; if value == valueToFind &#123; return index &#125; &#125; return nil&#125; 上面函数会报编译错误，因为在swift里，并不是所有的类都能用==操作符比较，只有实现了Equatable协议的类才能用==操作符，修改为 12345678func findIndex&lt;T: Equatable&gt;(array: [T], valueToFind: T) -&gt; Int? &#123; for (index, value) in array.enumerate() &#123; if value == valueToFind &#123; return index &#125; &#125; return nil&#125; 3. 多泛型类型参数有时候我们需要用多个协议进行约束，可以使用下面方式（类与函数的使用方式类似） 123func someFunc&lt;T : protocol&lt;StudyProtocal, RunProtocal&gt;&gt;(arg: T) &#123; // do stuff&#125; 如果约束既有类又有协议的话可以使用where添加限制条件 123func someFunc&lt;T, TK where T:Student, T: StudyProtocal&gt;(t: T, tk: TK) &#123; // do stuff&#125; 4. 泛型是不可变的1234var dog1 = SomeClass&lt;Parent&gt;()var dog2 = SomeClass&lt;Son&gt;()dog1 = dog2 // 报错 关于可变，不可变，逆变，协变参考这里：http://swift.gg/2015/12/24/friday-qa-2015-11-20-covariance-and-contravariance/ 5. 泛型协议swift的协议不支持泛型，不能像类一样定义泛型，而是通过类型参数定义泛型 123456789101112131415protocol GenericProtocol &#123; associatedtype T1 associatedtype T2 func someFunc(t2: T2) -&gt; T1&#125;class SomeClass&lt;T&gt; : GenericProtocol &#123; // 设置泛型类型 typealias T1 = String typealias T2 = T func someFunc(t2: T2) -&gt; T1 &#123; return &quot;&quot; &#125;&#125; 十六、运算符重载与其他高级语言的一样，swift也提供了运算符重载的功能，我们可以自定义运算符的实现，运算符通常分为三种类型 单目运算符：&lt;运算符&gt;&lt;操作数&gt;或&lt;操作数&gt;&lt;运算符&gt;，如!a 双目运算符：&lt;操作数&gt;&lt;运算符&gt;&lt;操作数&gt;，如：1 + 1 三元运算符：&lt;操作数&gt;&lt;运算符&gt;&lt;操作数&gt;&lt;运算符&gt;&lt;操作数&gt;，如：a ? b : c swift的运算符重载 支持自定义运算符/, =, -, +, *, %, &lt;, &gt;, !, &amp;, |, ^, ., ~的任意组合。可以脑洞大开创造颜文字。 不能对默认的赋值运算符=进行重载。组合赋值运算符可以被重载，如==，!==! 无法对三元运算符a ? b : c进行重载 运算符声明和定义只能定义在全局作用域，不能定义在类&#x2F;结构体&#x2F;枚举内 1. 前缀，中缀，后缀运算符 前缀prefix：默认的有-，!，~等 中缀infix：默认的有+，*，&#x3D;&#x3D;等 后缀postfix：默认的有：++，–等 1.1 声明运算符如果实现不存在的运算符需要添加运算符声明（系统的提供的，可以不需要声明），声明必须放在全局作用域 12345678// 前缀运算符prefix operator +++ &#123;&#125;// 中缀运算符（二元运算符）infix operator +++ &#123;&#125;// 后缀运算符postfix operator +++ &#123;&#125; 1.2 实现上面三个运算符1234567891011121314151617181920// 定义Point结构体struct Point &#123; var x: Int var y: Int&#125;// 重载操作符要放在全局作用域func +++ (left: Point, right: Point) -&gt; Point &#123; return Point(x: left.x + right.x, y: left.y + right.y)&#125;// 如果需要修改操作数，需要添加inout关键字prefix func +++ (inout left: Point) &#123; left.x += 1 left.y += 1&#125;postfix func --- (right: Point) -&gt; Point &#123; return Point(x: right.x - 1, y: right.y - 1)&#125; 1.3 使用123456var p1 = Point(x: 12, y: 21)var p2 = Point(x: 12, y: 2)let p3 = p1+++p2 // p3.x = 24, p3.y = 23+++p1 // p1.x = 13, p1.y = 3p1--- // p1.x = 12, p1.y = 2 2. 优先级这个很好理解，就是优先级高的运算符先执行，声明运算符的时候可以指明优先级 1234infix operator ^ &#123; associativity left // 结合性，后面说 precedence 140 // 指定运算符优先级&#125; 这里可以查看默认运算符的优先级 3. 结合性运算符还可以定义结合性，对于双目运算符，当优先级一样的时候，可以定义运算符优先进行左结合还是右结合，运算符的结合性有下面三种 left：左结合 right：右结合 none：无 结合性设置为left 12345678910111213// 定义一个双目操作符infix operator ^ &#123; associativity left // 结合性 precedence 140 // 指定运算符优先级&#125;func ^ (left: Int, right: Int) -&gt; Int &#123; return Int(pow(Double(left), Double(right)))&#125;let a = 2 ^ 2 ^ 2 ^ 2 // 执行结果为256// 相当于let aa = ((2 ^ 2) ^ 2) ^ 2 如果我们设置结合性为right 12345678910111213// 定义一个双目操作符infix operator ^ &#123; associativity right // 结合性 precedence 140 // 指定运算符优先级&#125;func ^ (left: Int, right: Int) -&gt; Int &#123; return Int(pow(Double(left), Double(right)))&#125;let a = 2 ^ 2 ^ 2 ^ 2 // 执行结果为65536// 相当于let aa = 2 ^ (2 ^ (2 ^ 2)) 如果结合性设置为none，则会报错，无法判断 十七、命名空间在很多语言里面，都有命名空间的概念，可以分离代码，防止命名冲突，而swift也有类似命名空间的概念，通过访问级别实现命名空间&#x2F;&#x2F;TODO 十八、参考链接 运算符结合性 Swift高级运算符 十九、总结总的来说，swift还是比较装逼的，整个很多新名词，新概念，例如，指定构造器，便利构造器，构造器代理，但其实这些东西在别的语言基本上有，没那么复杂，另外swift的关键字太多了，有些可有可无，是不是苹果看到什么好的就想往swift里面塞还是怎么着，另外感觉苹果还是太装逼了，例如do-while非要偏偏要搞成repeat-while啥的，个人感觉编程语言应该是轻便，简单，当然，并且能满足所有需求的，反正，没什么特别的好感","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://zhengbomo.github.io/tags/swift/"}]},{"title":"《编写高质量代码 改善Python程序的91个建议》学习笔记","slug":"Python-tip","date":"2016-06-28T03:16:46.000Z","updated":"2016-07-11T03:16:46.000Z","comments":true,"path":"2016-06-28/Python-tip/","link":"","permalink":"http://zhengbomo.github.io/2016-06-28/Python-tip/","excerpt":"最近在读《编写高质量代码 改善Python程序的91个建议》，在这里总结阅读中遇到的一些要点，和一些自己的理解","text":"最近在读《编写高质量代码 改善Python程序的91个建议》，在这里总结阅读中遇到的一些要点，和一些自己的理解 0. the Zen of Python先来看看一个有趣的彩蛋，python的设计之禅，我们在Python控制台输入import this，可以看到 1234567891011121314151617181920212223&gt;&gt;&gt; import thisThe Zen of Python, by Tim Peters # Python的禅宗Beautiful is better than ugly. # 优美胜于丑陋Explicit is better than implicit. # 明了胜于晦涩Simple is better than complex. # 简单胜于复杂Complex is better than complicated. # 复杂胜于凌乱Flat is better than nested. # 扁平胜于嵌套Sparse is better than dense. # 间隔胜于紧凑Readability counts. # 可读性很重要Special cases aren&#x27;t special enough to break the rules. # 特例并不违背规则Although practicality beats purity. # 虽然实用性比完美Errors should never pass silently.Unless explicitly silenced. # 错误不应该被忽略，除非你明确要这样做In the face of ambiguity, refuse the temptation to guess. # 在模棱两可的时候，拒绝胡乱猜测There should be one-- and preferably only one --obvious way to do it. # 应该有一个，最后只有一个方式可以做到Although that way may not be obvious at first unless you&#x27;re Dutch. # 虽然好的方式可能不容易做到（但我心向之），除非你是Python之父Now is better than never. # 立行胜于不做Although never is often better than *right* now. # 不做胜于鲁莽If the implementation is hard to explain, it&#x27;s a bad idea.If the implementation is easy to explain, it may be a good idea. # 如果你无法向别人描述好你的实现，那这一定是个糟糕的想法，如果能，或许是个好想法Namespaces are one honking great idea -- let&#x27;s do more of those! # 命名空间是一个很棒的理念，我们尽量多利用它&gt;&gt;&gt; python的设计哲学可以归纳为两个单词：简单，易懂 1. 理解Pythonic什么是Pythonic，最直观的解释就是Python风格的代码，那什么是Python风格的代码看看下面这个C语言的例子 123for (i = 0; i &lt; mylist_length; i++) &#123; do_something(mylist[i]);&#125; 如果直接写成Python的风格，是这样的（Python的for语句只用于迭代，故我们把上面的写法转成while语句） 1234i = 0while i &lt; mylist_length: do_something(mylist[i]) i += 1 上面代码可以正确运行，但是并不被人为是Python的风格，我们稍作修改 12for i in range(mylist_length): do_something(mylist[i]) 上面代码比之前的while更为简洁，但还不是完全的Pythonic风格，下面方式才是完全的Pythonic风格 12for element in mylist: do_something(element) 从上面例子中我们可以看出，Pythonic的代码，变量更少，更为短小，更为简单，读起来更为清晰 另外一个经常被提到的问题是，如何直接修改引用的变量（指针变量），我们再来看另外一个C语言的例子 12345678void foo(int* a, float* b) &#123; *a = 3; *b = 5.5;&#125;int alpha;int beta;foo(&amp;alpha, &amp;beta); 上面代码不能很好的描述其功能，并且晦涩难懂，在Python不鼓励这种写法，也不支持这种写法，Python使用输入输出的方式传值 1234def foo(): return 3, 5.5alpha, beta = foo() 再看一个例子，在C语言中交换两个数 1234int a = 1, b = 2int tmp = aa = bb = tmp Python中交换两个数 1a, b = b, a Pythonic是一种代码风格，以简单，易懂为宗旨 参考：http://blog.startifact.com/posts/older/what-is-pythonic.html 2. 编写Pythonic代码 变量名不与内建方法重名，如dict, list, element等， 由于Python使用缩进识别代码块，所以在代码里面，多余的空格和Tab尽量不要随便使用，不推荐对齐等号的方式（下面方式） 12a = 10 # some commentsome_str = &#x27;hello world&#x27; # some comment 注释 123# 下面第一种比较第二行更好x = x + 1 # increase x by 1x = x + 1 # increase x by 1 函数详细注释 12345678910111213141516def func(a, b): &quot;&quot;&quot;summary desctiption more detail comments for the function Args: a: some comment for parameter a b: some comment for parameter b Returns: return type, return value desctiption Raises: IOError: IOError exception may raise in the function IndexError: IndexError exception may raise in the function &quot;&quot;&quot; 函数设计 函数长度不宜过长，通常以小于一屏为准 函数嵌套不宜过多，通常保持在3层以内（for, if-else等） 参数不宜过多 函数只做一件事 使用异常抛出错误，而不通过返回值错误 尽量不要在函数中定义可变对象，除非特殊需要 3. 常量Python没有提供常量的支持，通常使用命名规范识别常量，所有字母大写，如MAX_OVERFLOW，当然，这只是一种约定，实际上与变量一样，是可以改变的 还有一种方式来模拟实现常量的功能，使用类来限制对属性的赋值 1234567891011121314class _const: class ConstError(TypeError): pass class ConstCaseError(ConstError): pass def __setattr__(self, name, value): if self.__dict__.has_key(name): raise self.ConstError, &#x27;Can\\&#x27;t change const.%s&#x27; % name if not name.isupper(): raise self.ConstCaseError, &#x27;const name &quot;%s&quot; is not all uppercase&#x27; % name self.__dict__[name] = valueimport constconst.COMPANY = &#x27;Google&#x27; 4. 使用断言断言在其他很多语言都存在，可以方便用于测试和调试程序，使用断言格式如下 12345assert expression, some_error_info# 如下x, y = 1, 2assert x == y, &#x27;not equals&#x27; 上面例子相当于 123x, y = 1, 2if __debug__ and not x == y: raise AssertionError(&#x27;not equals&#x27;) 断言会带来一定的性能消耗，由于Python没有严格意义上的Debug和Release模式，故它并不优化字节码，只是忽略相关代码的执行，在执行脚本的时候添加-O参数可以禁用断言 5. 使用枚举Python本身并不提供枚举的功能，关于Python是否要加入枚举功能，也引发了很多讨论，最后被组织拒绝了(在Python3.4以后又支持了😅)，但是因为Python强大的动态性，我们可以通过很多方式实现枚举的功能 12345678910111213141516class Seasons: Spring = 0 Summer = 1 Autumn = 2 Winter = 3# 简写为class Seasons: Spring, Summer, Autumn, Winter = range(4)# 使用函数动态构造一个对象def enum(*posarg, **kvarg): return type(&#x27;Enum&#x27;, (object,), dict(zip(posarg, xrange(len(posarg)))))season = enum(&#x27;spring&#x27;, &#x27;summer&#x27;, &#x27;autumn&#x27;, &#x27;winter&#x27;)print season.summer 我们还可以用第三方模块实现枚举的功能flufl.enum&#x2F;&#x2F;TODO: 6. 不推荐使用type()来判断类型相等 在经典类中，所有对象执行type()都相等 在新式类中，type()无法用于判断子类与父类的关系 1type(son) is type(parent) # 正常逻辑应该为True，但是结果是False 通常使用isinstance()方法判断类型 12isinstance(son, Son) # Trueisinstance(son, (Son, list, tuple)) # True 7. 注意运算时候的精度问题Python与C语言一样，计算精度取决于计算的值的类型，如两个整数相除，结果是整数，如果需要获得高精度的结果，需要转换为float类型在进行计算，在python3里，这个问题不存在 1234a, b = 1, 3print a / b # 0print a / float(b) # 0.33333333 8. 尽量避免浮点类型的比较浮点类型，在计算过程中可能有精度损失的风险，应尽量避免，如果可以转成整形再计算 1234i = 1.0while i != 1.5: i += 0.1 print i 上面语句会一直在while循环，而不能正确跳出 9. 避免使用eval用过JS或PHP的可能都知道eval函数，可以直接执行字符串脚本，然而，字符串有注入的风险，有安全性问题，如果需要，可以考虑使用ast.literal_eval代替 &#x2F;&#x2F;TODO 10. 使用enumerate枚举索引和变量Python语言很灵活，同一功能有多种实现方式，如索引列表 12345678910111213141516171819l = [1, 2, 3]# 方式一index = 0for i in l: do_something(i, index) index+=1# 方式二for index in range(len(l)) do_something(l[index], index)# 方式三for index, i in zip(range(len(l)), l) do_something(i, index)# 方式四for index, i in enumerate(l): do_something(i, index) 推荐使用方式四，支持延迟加载，不会一次枚举出所有的值，性能最优，书写也简洁，enumerate不适用于dict对象 11. 分清is和&#x3D;&#x3D;is：比较内存地址，而不是内容，a is b相当于id(a) == id(b)&#x3D;&#x3D;：a == b相当于a.__eq__(b)，可以重载__eq__方法实现等于的逻辑 123456789101112class person(object): def __init__(self, pid, name): self.pid = pid self.name = name def __eq__(self, p): return self.pid == p.pidp1 = person(1, &#x27;bomo&#x27;)p2 = person(1, &#x27;tobi&#x27;)print p1 == p2 # True 12. 尽量使用Unicode编码python编码见这里 13. 多使用模块和包来管理文件 尽量减少使用from pack import *这种导入方式，会污染命名空间，容易导致命名冲突，如果冲突，则后导入的覆盖先导入的 TODO: absolute import, relative import 14. Python不支持++i语法Python会把++i解释为+(+i) 12345a = -1print ++a# 相当于print +(+a)# 输出-1 15. 使用with自动释放资源用过C#的朋友应该都知道using，可以在代码块结束后自动释放资源，而Python也支持类似的语法 1234import iof = open(&#x27;test.txt&#x27;, &#x27;r&#x27;)print f.read()f.close() 像上面这种IO资源，在使用完成后需要开发者自己调用释放资源的方法，通常也会使用try-except-finally来保证释放资源，而通常情况下，释放资源很容易遗漏，可以使用with语法，把相关操作放在代码块中，当离开代码块的时候会自动调用释放资源的方法，这样就可以避免人为的遗漏问题，上面代码可以写成下面方式 123with open(&#x27;test.txt&#x27;, &#x27;r&#x27;) as f: print f.read()# 离开代码块后，f会自动释放 无论代码块中是否会抛出异常，离开代码块的时候，资源f都会被释放，其实只需要实现__enter__和__exit__方法就能支持这种行为 1234567891011121314151617181920212223242526272829class MyObj(object): def open(self): print &#x27;open&#x27; return self def __enter__(self): print &#x27;enter&#x27; def __exit__(self, exc_type, exc_val, exc_tb): print &#x27;close&#x27; if exc_type is None: print &#x27;没有异常&#x27; return False else: print &#x27;出现异常&#x27; return Falseobj = MyObj()with obj.open() as v: print str(v) + &#x27;执行一些操作&#x27;# 输出# open# enter# Nonedo something# close# 没有异常","categories":[{"name":"python","slug":"python","permalink":"http://zhengbomo.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://zhengbomo.github.io/tags/python/"}]},{"title":"python爬取拉勾网数据","slug":"python-lagou","date":"2016-06-27T12:23:26.000Z","updated":"2016-06-27T12:23:26.000Z","comments":true,"path":"2016-06-27/python-lagou/","link":"","permalink":"http://zhengbomo.github.io/2016-06-27/python-lagou/","excerpt":"学了一段时间的Python，于是抓了一些数据练手，选择了拉勾网上的招聘数据，抓取完成后进行分析，先来看看结果 拉勾网只能取到最近一个月的职位，所以以下统计也只有一个月的数据 只爬取了技术分类下的数据，如下图 总数据有34122条，由于拉勾的接口最多只能取到5000条数据，所以其中Android分类和前端开发分类数据可能不全，而其他关键字的结果都不到5000条，数据基本完整","text":"学了一段时间的Python，于是抓了一些数据练手，选择了拉勾网上的招聘数据，抓取完成后进行分析，先来看看结果 拉勾网只能取到最近一个月的职位，所以以下统计也只有一个月的数据 只爬取了技术分类下的数据，如下图 总数据有34122条，由于拉勾的接口最多只能取到5000条数据，所以其中Android分类和前端开发分类数据可能不全，而其他关键字的结果都不到5000条，数据基本完整 可以看到北京薪资最高， 安卓需求是iOS的一倍 最热门的技术岗位都在前端 需求最大的职位是PHP CTO，CDN，自然语言处理，GO语言，Hadoop，全栈工程师薪资最高 当然上面只是拉勾网一家最近一个月的数据 一、准备1. 要点 urllib2库的简单使用 sqlite的使用（入库，统计） flask的简单使用 chartkick的简单使用 分析拉勾网的数据，可以看到，在切换页的时候，数据列表使用ajax异步加载，通过Chrome查看网络数据可以看到数据通过一个Post请求，获取 http://www.lagou.com/jobs/positionAjax.json?px=default&amp;city=全国&amp;needAddtionalResult=falsePost数据：first=false&amp;pn=12&amp;kd=iOSpn为页数，kd为搜索关键字 二、爬取数据由于拉勾网的接口没有加密，也没有做限制，爬取的代码很简单，cookie都不用，下面是爬取的代码 1234567891011121314151617181920212223@staticmethoddef __download(url, data): &quot;&quot;&quot;下载url内容&quot;&quot;&quot; request = urllib2.Request(url) try: response = urllib2.urlopen(request, data) return response.read() except Exception, e: print str(e) return Noneif __name__ == &#x27;__main__&#x27;: city = u&#x27;广州&#x27; page_num = 10 keyword = u&#x27;iOS&#x27; url = u&#x27;http://www.lagou.com/jobs/positionAjax.json?px=default&amp;city=%s&amp;needAddtionalResult=false&#x27; % (city,) data = u&#x27;first=false&amp;pn=%d&amp;kd=%s&#x27; % (page_num, keyword) html = __download(url, data) if html: # 分析入库 pass else: logger.error(&#x27;download fail&#x27;) 爬完之后，我们可以进行分析入库，这里会用到json库 拉勾网的薪资信息使用**k-**k, **k以上, **k以下表示，这里我把他们解析成三个字段：minsalary, midsalary, maxsalary，mid取最大或最小或中间值，minsalary和maxsalary可空，在统计的时候使用的是midsalary作为薪资值 最后我们得到数据库 三、分析接下来是通过浏览器展现图表，这里使用的Flask框架作为Web服务器 1. 安装12345sudo pip install virtualenvsudo pip install flask# 图表库sudo pip install chartkick 新建一个模块ChartServer.py 123456789101112131415161718192021222324252627282930313233343536373839#!/usr/bin/python# -*- coding:utf-8 -*-from flask import Flask, render_template# 下面获取数据或工具类from Analyzer import Analyzerimport jsonimport collections# 构造一个Flask对象，即服务器对象app = Flask(__name__)app.jinja_env.add_extension(&quot;chartkick.ext.charts&quot;)# 定义路由@app.route(&#x27;/percent/&lt;count&gt;&#x27;)@app.route(&#x27;/percent/&lt;city&gt;/&lt;count&gt;&#x27;)def job_percent_for_city(city=None, count=0): &quot;&quot;&quot; 职位的数量排行 :param count: 结果数 :param city: 关键字 &quot;&quot;&quot; # 从数据库中读取数据 analyzer = Analyzer() data = analyzer.key_persent(count=count, city=city) # 有序字典 data = collections.OrderedDict(sorted(data.items(),key = lambda t:t[1], reverse=True)) data = json.dumps(data, encoding=&#x27;utf-8&#x27;,indent=4) subtitle = u&#x27;全国&#x27; if city is None else city # 传递参数给模板，并渲染 return render_template(&#x27;index.html&#x27;, data=data, title=u&#x27;职位的数量排行&#x27;, subtitle=subtitle)if __name__ == &quot;__main__&quot;: # 运行服务器 app.run(host=&quot;0.0.0.0&quot;) 模板定义，模板的路径为/templates/index.html 12345678&lt;script src=&quot;&#123;&#123; url_for(&#x27;static&#x27;, filename=&#x27;jquery.min.js&#x27;) &#125;&#125;&quot;&gt;&lt;/script&gt;&lt;script src=&quot;&#123;&#123; url_for(&#x27;static&#x27;, filename=&#x27;chartkick.js&#x27;) &#125;&#125;&quot;&gt;&lt;/script&gt;&lt;script src=&quot;&#123;&#123; url_for(&#x27;static&#x27;, filename=&#x27;highcharts.js&#x27;) &#125;&#125;&quot;&gt;&lt;/script&gt;&#123;% line_chart data with library=&#123;&quot;title&quot;:&#123;&quot;text&quot;: title&#125;, &quot;subtitle&quot;: &#123;&quot;text&quot;: subtitle&#125;&#125; %&#125;&#123;% pie_chart data with library=&#123;&quot;title&quot;:&#123;&quot;text&quot;: title&#125;, &quot;subtitle&quot;: &#123;&quot;text&quot;: subtitle&#125;&#125; %&#125;&#123;% column_chart data with library=&#123;&quot;title&quot;:&#123;&quot;text&quot;: title&#125;, &quot;subtitle&quot;: &#123;&quot;text&quot;: subtitle&#125;&#125; %&#125;&#123;% area_chart data with library=&#123;&quot;title&quot;:&#123;&quot;text&quot;: title&#125;, &quot;subtitle&quot;: &#123;&quot;text&quot;: subtitle&#125;&#125; %&#125; 这里使用的几个js文件引用的是本地文件/static/jquery.min.js, /static/chartkick.js, /static/highcharts.js 运行ChartServer模块当我们请求 /percent/广州/10这个url的时候，就会执行job_percent_for_city方法，然后返回渲染后的文本输出到浏览器 四、总结本文主要记录了爬取的一些要点和过程，更多细节可以到这里直接查看代码 五、参考链接 Flask的中文介绍 chartkick+flask画报表 chartkick.py项目","categories":[{"name":"python","slug":"python","permalink":"http://zhengbomo.github.io/categories/python/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://zhengbomo.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"python编解码","slug":"python-encode-decode","date":"2016-06-24T07:53:43.000Z","updated":"2016-06-24T07:53:43.000Z","comments":true,"path":"2016-06-24/python-encode-decode/","link":"","permalink":"http://zhengbomo.github.io/2016-06-24/python-encode-decode/","excerpt":"python使用中文字符串的时候，经常会遇到乱码，升值是根本无法使用的问题，经常无端报错，有找不到原因，有时候使用decode或encode可以解决问题，但是并不知道为什么，今天在这里总结一下关于python编解码的一些相关要点","text":"python使用中文字符串的时候，经常会遇到乱码，升值是根本无法使用的问题，经常无端报错，有找不到原因，有时候使用decode或encode可以解决问题，但是并不知道为什么，今天在这里总结一下关于python编解码的一些相关要点 1. python的字符串python有两种类型的字符串，分别是unicode和str，我们知道，大部分其他语言的字符串都只有一种，使用同一的编码方式，为什么python要搞出两个来坑人？ 先来看看声明，以便下面区别，str字符串没有前缀，unicode字符串有前缀u 12s = &#x27;str字符串&#x27;u = u&#x27;unicode字符串&#x27; 在python中，str是字节串，而unicode才是真正意义上的字符串，str是unicode字符串经过编码后字节组成，而它们是可以互相转换的 123456# unicode -&gt; strs = u&#x27;abc中文&#x27;.encode(&#x27;utf-8&#x27;)print type(s) # &lt;type &#x27;str&#x27;&gt;# str -&gt; unicodeprint s.decode(&#x27;utf-8&#x27;) # abc中文 unicode编码是python处理字符串的中间编码，其他编码都是通过unicode进行转换的，所以为了避免混乱，这里推荐一个原则：不要对unicode使用decode，不要对str使用encode 如果要把gbk编码的str转为utf16编码的str，我们需要用unicode编码做中转 123456789s8 = u&#x27;abc中文&#x27;.encode(&#x27;gbk&#x27;) # &#x27;abc\\xd6\\xd0\\xce\\xc4&#x27;# 转成unicodetemp = s8.decode(&#x27;gbk&#x27;) # u&#x27;abc\\u4e2d\\u6587&#x27;# 转成strs16 = temp.encode(&#x27;utf-16&#x27;) # &#x27;\\xff\\xfea\\x00b\\x00c\\x00-N\\x87e&#x27;# 合起来s16 = s8.decode(&#x27;gbk&#x27;).encode(&#x27;utf-16&#x27;) s16使用的是utf-16编码，这时候我们在控制台或IDE输出一下 12print s16# 输出：��abc-N�e 我们看到了乱码，这是由于控制台或IDE的编码与字符串的编码不一致导致的，如果一致，就正常输出 2. py文件编码在python中，如果源文件使用了非Ascii字符，必须在文件头（前几行）声明文件编码格式，这样python解释器在解释的时候，会把相应的str字符串编码为响应的编码格式 声明py文件编码格式如下，下面四种方式可以，第一句#!/usr/bin/python是用来兼容linux，声明python解释器的位置，通常也加上 12345#!/usr/bin/python# -*- coding: utf-8 -*-#coding=utf-8#coding:utf-16#coding=gbk 注意上面声明的编码格式必须与文件保存的编码格式一致，否则会读取失败或出现乱码文件头声明的编码是给解释器看的，它会把文件中的字符串用响应的格式进行编码 test.py（文件编码为GBK，py编码声明为GBK） 12345678910#!/usr/bin/python#coding=gbku = u&#x27;abc中文&#x27;s = &#x27;abc中文&#x27;print u # abc中文print s # 出现乱码# 转为unicode字符串，正常print s.decode(&#x27;gbk&#x27;) # abc中文 上面代码运行的后，直接打印s会出现乱码，因为s是用GBK进行编码的str字符串，而IDE或控制台使用的编码为UTF8，不一致，所以输出乱码，解决办法可以吧s转换为unicode字符串 3. 读取文件假定文件test.txt是用GBK编码存储的，我们现在读取其内容 123456import ioio.open(&#x27;test.txt&#x27;)f = io.open(&#x27;test.txt&#x27;, encoding=&#x27;gbk&#x27;)print f.read()# 这是一个GBK编码存储的文件 默认使用utf-8编码读取，不指定编码格式可能会读不了或出现乱码 4. getdefaultencoding&#x2F;setdefaultencoding上面我们说到，把gbk编码转换成utf16的时候，我们需要借助unicode编码进行中转，其实不中转也是可以的，python会自动帮我们转 12345678# 先拿到一个gbk编码的strgbk = u&#x27;abc中文&#x27;.encode(&#x27;gbk&#x27;)# 严谨的方式是这样的gbk.decode(&#x27;gbk&#x27;).encode(&#x27;utf16&#x27;)# 省去解码这一步（会报错）gbk.encode(&#x27;utf16&#x27;) 上面我们直接对str进行encode，python解释器会自动帮我们吧str先转成unicode，而解码方式使用系统默认的方式，一般默认的解码方式是ascii，可以通过sys.getdefaultencoding()取到，所以上面语句相当于，显然会报错 1gbk.decode(&#x27;ascii&#x27;).encode(&#x27;utf16&#x27;) 这个时候我们可以设置defaultencoding为gbk就可以了，设置之前，需要reload一下sys库 12345678import sysprint sys.getdefaultencoding() # asciireload(sys)sys.setdefaultencoding(&#x27;gbk&#x27;)gbk = u&#x27;abc中文&#x27;.encode(&#x27;gbk&#x27;)print gbk.encode(&#x27;utf16&#x27;) # 输出：&#x27;\\xff\\xfea\\x00b\\x00c\\x00-N\\x87e&#x27; 输出成功 5. 总结 文件编码，存储时的编码格式，与python无关 python编码声明，放在py文件前几行，为了避免冲突，通常保持与文件编码一致 IDE&#x2F;控制台编码，当我们在IDE&#x2F;或控制台输出的字符串的时候，如果IDE的编码与字符串的编码不一致，也导致输出乱码 str字符串encode的时候，会自动先转为unicode，再进行编码，setdefaultencoding可以设置str字符串默认转换为unicode的编码 在python中，真正用来执行操作的还是unicode字符串，而str字符串仅用于前后的编码的转换而已 为了保证编码正确，我们可以尽量把其他编码格式的str字符串根据响应的编码格式，转换为unicode字符串，再使用 在开发中我们尽量都使用UTF8作为编码的格式，包括IDE，文件编码默认都是用UTF8","categories":[{"name":"python","slug":"python","permalink":"http://zhengbomo.github.io/categories/python/"}],"tags":[{"name":"编码","slug":"编码","permalink":"http://zhengbomo.github.io/tags/%E7%BC%96%E7%A0%81/"}]},{"title":"python网络请求库urllib","slug":"python-urllib2","date":"2016-06-23T07:21:59.000Z","updated":"2016-06-23T07:21:59.000Z","comments":true,"path":"2016-06-23/python-urllib2/","link":"","permalink":"http://zhengbomo.github.io/2016-06-23/python-urllib2/","excerpt":"Python也提供了自带网络请求库有，urllib，urllib2 urllib # 初级url请求库，提供最基本的url请求，header都不支持 urllib2 # 高级url请求库，通常与urllib库一起使用 cookielib # Cookie容器处理","text":"Python也提供了自带网络请求库有，urllib，urllib2 urllib # 初级url请求库，提供最基本的url请求，header都不支持 urllib2 # 高级url请求库，通常与urllib库一起使用 cookielib # Cookie容器处理 1. Opener在Python中使用Opener对象来请求的url资源，使用urlopen方法则调用默认的opener请求 123456789import urllib2# 使用默认的opener请求数据（Get）response = urllib2.urlopen(&#x27;http://python.org/&#x27;)html = response.read()# 可以把url封装成Request对象进行请求（Get）req = urllib2.Request(&#x27;http://www.python.org&#x27;)response = urllib2.urlopen(req)html = response.read() 2. Post请求上面处理的是get请求，下面看看Post请求，只要在Request对象设置了data参数或在urlopen设置了data参数，就会被识别为post请求 123456req = urllib2.Request(&#x27;http://www.python.org&#x27;)values = &#123;&#x27;name&#x27;: &#x27;bomo&#x27;, &#x27;age&#x27;: 18&#125;data = urllib.urlencode(values)req = urllib2.Request(url, data)response = urllib2.urlopen(req)html = response.read() 2. Header123456req = urllib2.Request(&#x27;http://www.python.org&#x27;)values = &#123;&#x27;name&#x27;: &#x27;bomo&#x27;, &#x27;age&#x27;: 18&#125;data = urllib.urlencode(values)headers = &#123;&#x27;User-Agent&#x27;: &quot;Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)&quot;&#125;response = urllib2.urlopen(req, headers, headers=headers data=data)html = response.read() 3. CookieWeb请求相当于一条请求管道，在请求的过程中可以有多个操作，如缓存处理，Cookie处理，URL跳转处理，代理处理等等，在urllib2中被定义为handler，cookie处理相当于opener的一个handler，一个opener可以有多个handler，通过不同的handler处理做不同的处理，如可以通过自带的方法创建handler，如有urllib2.ProxyHandler，urllib2.HTTPRedirectHandler等 Python中Cookie的基本使用如下 1234567891011121314import urllib2import cookielibfilename = &#x27;cookie.txt&#x27;# 构造一个Cookie容器来保存Cookiecookie = cookielib.LWPCookieJar(filename)# 利用urllib2库的HTTPCookieProcessor对象来创建cookie处理器handler = urllib2.HTTPCookieProcessor(cookie)# 通过handler来构建openeropener = urllib2.build_opener(handler)# 有了opener就可以请求了response = opener.open(&quot;http://www.baidu.com&quot;)# 请求完成后，可以获取到cookie的值，这里我们保存到文件cookie.save(ignore_discard=True, ignore_expires=True) 刚刚获取到cookie并存到了文件，这时候我们直接从文件读取出cookie来使用 12345678910import urllib2import cookielibfilename = &#x27;cookie.txt&#x27;cookie = cookielib.LWPCookieJar(filename)cookie.load(&#x27;cookie.txt&#x27;, ignore_discard=True, ignore_expires=True)opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))req = urllib2.Request(&quot;http://www.baidu.com&quot;)response = opener.open(req)print response.read() 4. 重定向问题默认情况下，Python请求到301&#x2F;302的结果的时候，会自动进行重定向请求，如果不需要跳转怎么办，我们可以添加一个handler，不处理重定向的操作 12345678910import urllib2class RedirectHandler(urllib2.HTTPRedirectHandler): def http_error_301(self, req, fp, code, msg, headers): pass def http_error_302(self, req, fp, code, msg, headers): passopener = urllib2.build_opener(RedirectHandler)opener.open(&#x27;http://www.google.cn&#x27;) 5. 参考 urllib2库官方介绍 BeautifulSoup官方介绍","categories":[{"name":"python","slug":"python","permalink":"http://zhengbomo.github.io/categories/python/"}],"tags":[{"name":"urllib","slug":"urllib","permalink":"http://zhengbomo.github.io/tags/urllib/"}]},{"title":"Python使用sqlite","slug":"python-sqlite","date":"2016-06-22T13:55:58.000Z","updated":"2016-06-22T13:55:58.000Z","comments":true,"path":"2016-06-22/python-sqlite/","link":"","permalink":"http://zhengbomo.github.io/2016-06-22/python-sqlite/","excerpt":"与其他语言一样，Python也能进行数据库操作，并且在2.5版本以后，Python就内置了sqlite3，所以在使用Python的时候不需要装任何东西，可以直接使用","text":"与其他语言一样，Python也能进行数据库操作，并且在2.5版本以后，Python就内置了sqlite3，所以在使用Python的时候不需要装任何东西，可以直接使用 下面是一个最简单的操作数据库的例子 1. 增删改1234567891011121314151617181920212223242526272829303132import sqlite3# 连接数据库，在当前目录下找数据库文件，如果不能再，则会创建conn = sqlite3.connect(&#x27;test.db&#x27;)# 使用绝对路径# conn = sqlite3.connect(&#x27;/Users/bomo/Documents/Code/Python/test.db&#x27;)# 连接内存数据库# conn = sqlite3.connect(&quot;:memory:&quot;)# 获得一个游标，通过这个游标对数据库操作，使用完成后需要关闭cursor = conn.cursor()# 执行一个sql语句，创建一个表sql = &#x27;CREATE TABLE if not exists user (id varchar(20) primary key AUTOINCREMENT, name varchar(20), age integer)&#x27;cursor.execute(sql)# 增删改必须调用commit才能生效conn.commit()# 插入一条记录sql = &#x27;INSERT INTO user (name, age) values (\\&#x27;bomo\\&#x27;, 18)&#x27;cursor.execute(sql)conn.commit()# 删除一条记录sql = &#x27;DELETE FROM user WHERE name=\\&#x27;bomo\\&#x27;&#x27;cursor.execute(sql)conn.commit()# 使用完成后需要关闭游标cursor.close()# 关闭连接conn.close() 如果对数据库进行增删改操作的时候，需要调用connection.commit()方法才能生效 2. 查询12345678910111213141516171819conn = sqlite3.connect(&#x27;test.db&#x27;)cursor = conn.cursor()# 查询结果集，参数为元组sql = &#x27;select * from user where id = ?&#x27;cursor.execute(sql, (&#x27;1&#x27;,))values = cursor.fetchall() # 获取所有的行记录，得到一个list，list元素为tupleprint values# 输出：[(1, u&#x27;bomo&#x27;, 18), (2, u&#x27;tobi&#x27;, 6)]# 查询单个结果sql = &#x27;select count(*) from user&#x27;cursor.execute(sql)result = cursor.fetchone() # 得到一个元组print result# 输出：(2,)cursor.close()conn.close() 3. row_factory上面查询结果可以看到，输出结果为元组，只包含值信心，我们可以通过row_factory配置更丰富的结果集，python的sqlite自带sqlite.Row工厂可以生成可以通过索引和列名访问值的结果集，如下 1234567891011121314151617181920212223242526272829connection = sqlite3.connect(&#x27;spider.db&#x27;)# 查询结果集使用Row构造, sqlite.Row提供了基于索引和列名索引的方式connection.row_factory = sqlite3.Rowcu = connection.cursor()# 查询多行cu.execute(&#x27;select * from user limit 1&#x27;)rows = cu.fetchall()for row in rows: # print type(row) # &lt;type &#x27;sqlite3.Row&#x27;&gt; # 取得所有的列 for col in row.keys(): print &#x27;%s=%s &#x27; % (col, i[col])# 输出：# id=1# name=bomo# age=18# 查询单行cu = connection.cursor()cu.execute(&#x27;select count(*) as rowcount count from user&#x27;)row = cu.fetchone()for col in row.keys(): print &#x27;%s=%s &#x27; % (col, i[col])# 输出：# rowcount=2cu.close()connection.close() 当然，我们也可以自定义row_factory 12345678# 自定义row构造器，返回字典对象，可以通过列名索引def dict_factory(cursor, row): d = &#123;&#125; for idx, col in enumerate(cursor.description): d[col[0]] = row[idx] return dconnection.row_factory = dict_factory 4. 字符串编码数据库默认的编码格式为UTF-8，可以通过下面命令指定编码格式，如果主数据库还没创建，则可以指定编码，否则使用原有编码格式 PRAGMA encoding &#x3D; “UTF-8”; PRAGMA encoding &#x3D; “UTF-16”; PRAGMA encoding &#x3D; “UTF-16le”; PRAGMA encoding &#x3D; “UTF-16be”; 12345678connection = sqlite3.connect(&#x27;spider.db&#x27;)conn.executescript(&#x27;PRAGMA encoding = &quot;UTF-16&quot;;&#x27;)cu = connection.cursor()# do somethingcu.close()connection.close() 问题：主数据库（main database）是指什么?? 5. text_factory从sqlite数据库读取出来的字符串需要转换成unicode对象，text_factory可以用于编码的转换，构建unicode字符串，默认保存的就是unicode编码，如果我们需要把字符串存成UTF8编码的，我们需要修改text_factory的值 123conn = sqlite3.connect(&#x27;test&#x27;)conn.text_factory = str # 默认为utf8编码conn.text_factory = lambda t: unicode(t, &#x27;gbk&#x27;, &#x27;ignore&#x27;) # 设为gbk编码 参见官网的介绍 关于python的编解码和unicode与str可以看我另一篇文章","categories":[{"name":"python","slug":"python","permalink":"http://zhengbomo.github.io/categories/python/"}],"tags":[{"name":"sqlite","slug":"sqlite","permalink":"http://zhengbomo.github.io/tags/sqlite/"}]},{"title":"Python迭代器和生成器","slug":"python-iterator-generator","date":"2016-06-21T06:55:49.000Z","updated":"2016-06-21T06:55:49.000Z","comments":true,"path":"2016-06-21/python-iterator-generator/","link":"","permalink":"http://zhengbomo.github.io/2016-06-21/python-iterator-generator/","excerpt":"与其他高级语言一样，Python也提供了迭代器的功能，迭代器统一了访问的集合的方式，Python中所有的集合数据类型（list, str, dict, set, tuple）都支持使用for进行迭代，当然我们也可以为自己定义的类或函数实现这种迭代的功能","text":"与其他高级语言一样，Python也提供了迭代器的功能，迭代器统一了访问的集合的方式，Python中所有的集合数据类型（list, str, dict, set, tuple）都支持使用for进行迭代，当然我们也可以为自己定义的类或函数实现这种迭代的功能 例子我们先来看一个例子，我们生成一个斐波那契序列 123456def fabs(count): n, a, b = 0, 0, 1 while n &lt; max: print b a, b = b, a + b n = n + 1 上面在函数里面直接print结果，显然这样做的复用性特别差，于是我们想到了用列表 1234567891011def fabs(count): l = [] n, a, b = 0, 0, 1 while n &lt; max: l.append(b) a, b = b, a + b n = n + 1 return lfor i in fabs(10): print i 使用list返回可以解决了复用性问题，但是有时候我们需要使用的数据量非常大的时候，返回整个list会占用大量内存，这个时候，我们希望，函数返回的值不要一次性全部返回，而是用到的时候计算再返回，这样数据量再打也只占用一份内存而已了，Python提供了两种方式实现这种逐步迭代的方式，于是就有了下面迭代器和生成器 迭代器迭代器统一了所有集合访问元素的方式，包括有序无序的，相比for遍历集合，其支持随机访问的集合，如set，dict，只能向前，不能后退，迭代器有下面两个基本方法，大多数高级语言都会定义统一的迭代器操作，Python中的迭代器类型需要实现下面两个方法 next：返回迭代器下一个元素 __iter__方法：返回一个迭代器 给一个类实现迭代器功能，生成斐波那契序列 1234567891011121314151617181920class Fabs(object): def __init__(self, max): &quot;&quot;&quot;传入斐波那契数列的个数&quot;&quot;&quot; self.max = max; self.n, self.a, self.b = 0, 0, 1 def __iter__(self): return self; def next(self): if self.n &lt; self.max: r = self.b self.a, self.b = self.b, self.a + self.b self.n = self.n + 1 return r; raise StopIteration() # 迭代结束需要抛出异常fab = Fabs(8)for i in fab: print i # 1, 1, 2, 3, 5, 8, 13, 21 生成器yield上面我们看到每次迭代通过调用next取得值，Python还提供了另一个关键字yield用于更方便的迭代每个值，C#也支持这种语法，带有yield关键的函数被称为生成器（generator） yield：在函数使用yield返回每次迭代的值，而不直接返回，yield返回值后等待下次迭代，而保留当前的状态（局部变量不变），直到下次迭代的时候，接着后面的代码继续执行 12345678910111213141516171819202122def Foo(): yield 1 # 返回后等待第二次迭代 yield 3 # 第二次迭代从这里开始，等待第三次迭代 yield 2 # 第三次迭代从这里开始，迭代完成def myrange(max): print &#x27;iter start&#x27; # 迭代开始时执行 i = 0 while i &lt; max: yield i i += 1 print &#x27;iter end&#x27; # 迭代函数执行完没yield返回时，抛出StopIteration异常表示迭代结束# 不执行迭代过程（不输出iter start）print type(myrange(10)) # 输出：&lt;type &#x27;generator&#x27;&gt;for _ in Foo(): print str(_) # 输出：1 3 2for _ in myrange(10): print str(_) # 输出：0 1 2 3 4 5 6 7 8 9 iter end 上面函数Foo可以迭代三次，分别返回1,3,2，与普通的列表一样 使用了生成器的函数，不能使用return，编译器会报错 生成器返回的对象是generator 生成器在迭代完最后一个值之后，当迭代函数执行完，没有yield返回迭代值的话，会抛出StopIteration异常表示迭代结束 只有生成器调用next方法的时候才会运行迭代过程 生成器支持与外部函数交互send生成器可以通过yield返回值给外部函数，也可以接受外部函数传递的值，通过send方法传值 123456789for _ in test(): print _# 相当于try: while True: print ite.next()except StopIteration, e: pass 迭代器每次迭代实际上相当于调用了next方法，然后从yield取值，Python迭代器还提供了send方法，功能与next类似，但是可以传递参数作为yield的返回值在迭代器内部使用 1234567891011121314151617181920def test(): n = 1 p = yield n if p: # 调用send时，p接收参数值，调用next时，p为None n += p p = yield n if p: n += p yield nite = test()try: print ite.next() # 第一次不允许调用send print ite.send(1) # 传递参数1给迭代器 print ite.send(2) # 传递参数2给迭代器 print ite.send(3) # 最后一次传至无效，因为迭代已经完成，触发StopIterationexcept StopIteration, e: pass yield的原理&#x2F;&#x2F;TODO:","categories":[{"name":"python","slug":"python","permalink":"http://zhengbomo.github.io/categories/python/"}],"tags":[]},{"title":"Python装饰器","slug":"python-decorator","date":"2016-06-17T08:32:35.000Z","updated":"2016-06-17T08:32:35.000Z","comments":true,"path":"2016-06-17/python-decorator/","link":"","permalink":"http://zhengbomo.github.io/2016-06-17/python-decorator/","excerpt":"Python从语法级别提供了对装饰器模式的支持，有时候需要为一些函数添加一些额外的操作，如在执行前后打印执行时间，由于Python是函数式编程语言，支持高阶函数（函数可以作为参数和返回值使用），这样我们可以定义一个函数对原有的函数进行包装，比如在函数执行前后进行打印","text":"Python从语法级别提供了对装饰器模式的支持，有时候需要为一些函数添加一些额外的操作，如在执行前后打印执行时间，由于Python是函数式编程语言，支持高阶函数（函数可以作为参数和返回值使用），这样我们可以定义一个函数对原有的函数进行包装，比如在函数执行前后进行打印 1234567891011121314151617def sayHello(name): print &#x27;hello %s&#x27; % (name,)def log(func): # 定义一个转换器,接收任意参数最后传给func def wrapper(*args, **kv): print &#x27;begin %s&#x27; % (time.ctime(),) func(*args, **kv) print &#x27;end %s&#x27; % (time.ctime(),) return wrapper# 直接调用sayHello(&#x27;bomo&#x27;)# 包装后调用f = log(sayHello)f(&#x27;bomo&#x27;) 打印结果 这样做还是很麻烦，Python提供了一种装饰器的语法，直接包装方法，而不改变原有的函数调用，我们在sayHello函数定义上加上@log 123456# 把log函数的定义放在sayHello之前@logdef sayHello(name): print &#x27;hello %s&#x27; % (name,)sayHello(&#x27;bomo&#x27;) 这里的@log的功能就相当于 1sayHello = log(sayHello) Python的装饰器本质上就是函数调用，除了上面的方式，还支持三层嵌套，也支持参数，我们可以修改log函数为下面形式如下 123456789101112def log(name): def wrapper2(func): # 定义一个转换器,接收任意参数最后传给func def wrapper(*args, **kv): print &#x27;begin %s %s&#x27; % (name, time.ctime()) func(*args, **kv) print &#x27;end %s %s&#x27; % (name, time.ctime()) return wrapper@log(&#x27;timelog&#x27;)def say_hello(name): print &#x27;hello %s&#x27; % (name,) 这时候就相当于 1say_hello = log(&#x27;timelog&#x27;)(say_hello) 装饰器是替换了原来的方法，所以使用装饰器后方法名也会变化，由上面代码可以看出 12345say_hello = log(&#x27;timelog&#x27;)(say_hello)# 相当于say_hello = wrapper2(say_hello)# 相当于say_hello = wrapper 故say_hello.__name__为wrapper 有时候我们可能会有些操作依赖于原来的方法名，这时候我们就不希望方法名被改了，或者是我们在使用装饰器后还能访问到原来函数的一些属性（函数也是对象，也有属性），Python提供了functools.wraps装饰器，用于把外部方法的相关属性赋值给内部方法，如 123456789101112131415161718def log(func): # 定义一个转换器,接收任意参数最后传给func @functools.wraps(func) def wrapper(*args, **kv): print &#x27;begin %s&#x27; % (time.ctime(),) func(*args, **kv) print &#x27;end %s&#x27; % (time.ctime(),) return wrapperdef log(name): def wrapper2(func): @functools.wraps(func) def wrapper(*args, **kv): print &#x27;begin %s %s&#x27; % (name, time.ctime()) func(*args, **kv) print &#x27;end %s %s&#x27; % (name, time.ctime()) return wrapper Python还只是同事声明几个装饰器，如 1234567891011121314151617181920def log1(func): def wrapper(*args, **kv): print &#x27;log1 begin %s&#x27; % (time.ctime(),) func(*args, **kv) print &#x27;log1 end %s&#x27; % (time.ctime(),) return wrapperdef log2(func): def wrapper(*args, **kv): print &#x27;log2 begin %s&#x27; % (time.ctime(),) func(*args, **kv) print &#x27;log2 end %s&#x27; % (time.ctime(),) return wrapper@log1@log2def say_hello(name): print &#x27;hello %s&#x27; % (name,)say_hello(&#x27;bomo&#x27;) 输出，先定义的在外层 12345log1 begin Fri Jun 17 19:00:59 2016log2 begin Fri Jun 17 19:00:59 2016hello bomolog2 end Fri Jun 17 19:00:59 2016log1 end Fri Jun 17 19:00:59 2016 在面向对象设计模式中有个叫装饰器模式的，与Python的类似，而Python直接从语法级实现了支持","categories":[{"name":"python","slug":"python","permalink":"http://zhengbomo.github.io/categories/python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zhengbomo.github.io/tags/Python/"}]},{"title":"Python多线程学习笔记","slug":"python-multithread","date":"2016-06-14T15:42:53.000Z","updated":"2016-06-14T15:42:53.000Z","comments":true,"path":"2016-06-14/python-multithread/","link":"","permalink":"http://zhengbomo.github.io/2016-06-14/python-multithread/","excerpt":"关于多线程的理论，这里不做介绍，Python通过thread和threading两个标准库提供对多线程的支持。 thread提供了低级别的、原始的线程以及一个简单的锁。 threading基于Java的线程模型设计。锁（Lock）和条件变量（Condition）在Java中是对象的基本行为（每一个对象都自带了锁和条件变量），而在Python中则是独立的对象。","text":"关于多线程的理论，这里不做介绍，Python通过thread和threading两个标准库提供对多线程的支持。 thread提供了低级别的、原始的线程以及一个简单的锁。 threading基于Java的线程模型设计。锁（Lock）和条件变量（Condition）在Java中是对象的基本行为（每一个对象都自带了锁和条件变量），而在Python中则是独立的对象。 thread模块使用start_new_thread方法开启一个线程，第一个参数为线程函数，第二个参数为参数，如果函数没有参数，要传空元组 123456789101112131415import timeimport threaddef test1(): print &#x27;start test1&#x27; # 休息3秒 time.sleep(3) print &#x27;end test1&#x27;if __name__ == &#x27;__main__&#x27;: thread.start_new_thread(test1, ()) print &#x27;main thread...&#x27; # start_new_thread创建的线程在主线程执行完成时会自动结束，这里等5秒 time.sleep(5) print &#x27;main thread end&#x27; 上面通过sleep防止主线程退出导致其他线程也跟着退出，显然不靠谱，这时候我们可以通过锁的方式控制线程执行顺序 123lock = thread.allocate_lock() # 返回一个新的锁定对象。lock.acquire() # 请求锁，如果该所没被占用，则成功返回，如果被占用，则等待直到锁被释放lock.release() # 释放锁 例子： 1234567891011121314151617181920212223import timeimport threaddef test1(thread_lock): print &#x27;start test1&#x27; # 休息3秒 time.sleep(3) print &#x27;end test1&#x27; # 执行完后释放锁 thread_lock.release()if __name__ == &#x27;__main__&#x27;: # 创建一个锁 lock = thread.allocate_lock() # 请求锁 lock.acquire() # 把锁传给函数 thread.start_new_thread(test1, (lock,)) print &#x27;main thread...&#x27; # 只有被释放了才能请求到 lock.acquire() print &#x27;main thread end&#x27; threading模块thread模块不支持守护线程，当主线程退出时，所有子线程不管是否工作都会被结束，而threading更强大，也支持守护线程 123456789101112131415161718import timeimport threadingdef test1(): print &#x27;start test1 &#x27; time.sleep(3) # 休息3秒 print &#x27;end test1&#x27;if __name__ == &#x27;__main__&#x27;: # 创建一个线程 t = threading.Thread(target=test1, args=()) # 运行线程 t.start() print &#x27;main thread...&#x27; # join函数阻塞当前线程，直到t线程运行完成 t.join() print &#x27;main thread end&#x27; 使用Thread.start()运行的线程，在主线程执行完成后不会被强制结束，会一直运行至结束 常用属性 threading.currentThread()：返回当前的线程变量。 threading.enumerate()：返回一个包含正在运行的线程的list threading.activeCount()： 返回正在运行的线程数量 Thread对象 start(): 启动线程 join(): 阻塞直到线程完成 isAlive(): 返回线程是否活动的 getName(): 返回线程名 setName(): 设置线程名 run(): 表示线程活动的方法 当Thread对象调用start方法的时候，默认会调用run方法，所以我们可以封装线程函数到Thread对象里面，如下 1234567891011121314import timeimport threadingclass MyThread(threading.Thread): def __init__(self, name): super(MyThread, self).__init__() self.name = name def run(self): &quot;&quot;&quot;线程执行函数&quot;&quot;&quot; time.sleep(2) print &#x27;%s run&#x27; % (self.name,)t = MyThread(&#x27;thread_name&#x27;)t.start() 线程同步问题与其他语言一样，Python也提供了线程同步相关的支持，Python支持下面几种线程同步锁 线程锁的锁定释放的流程如下 请求锁定 —&gt; 进入锁定池等待 —&gt; 获取锁 —&gt; 已锁定 —&gt; 释放锁 1. Lock &amp; RLock Lock指令锁，只有两种状态 1234mutex = threading.Lock() # 构造方法mutex.acquire() # 请求锁，成功则锁定，如果该锁已被锁定，则阻塞等待# mutex.acquire() # 会发生死锁mutex.release() # 释放锁，使用前该锁必须已被锁定 RLock可重入锁，为了保证线程对共享资源的独占，又避免死锁的出现，允许在同一线程中多次请求锁，如下： 12345mutex = threading.RLock() # 构造方法mutex.acquire() # 请求锁mutex.acquire() # 请求锁，不会死锁mutex.release()mutex.release() # 请求多少次就要释放多少次，成对出现 2. Semaphore信号量，比Lock多了计数器，可以记录多次请求和释放，技术器不能小于0，小于0则会阻塞，通常可以用在控制并发数的情况下，用法与Lock类似 123456semaphore = threading.Semaphore(2) # 构造一个信号量，容量为2semaphore.acquire() # 请求信号，计数器-1，执行完后为1semaphore.acquire() # 请求信号，计数器-1，执行完后为0# semaphore.acquire() # 请求信号，计数器为0，阻塞，直到release让计数器+1semaphore.release() # 请求信号，计数器+1，执行完后为1semaphore.release() # 请求信号，计数器+1，执行完后为2 3. Event与Lock相反，Event内部维护一个标志位，初始化为false，调用set置为true，调用clear置为flase 123456789101112131415161718import timeimport threadingdef test1(signal): print &quot;I will sleep, wake me up 3 seconds later&quot; signal.wait() print &quot;I awake up...&quot;if __name__ == &#x27;__main__&#x27;: sig = threading.Event() t = threading.Thread(target=test1, args=(sig,)) t.start() # 睡3秒 time.sleep(3) # 叫醒信号 sig.set() print &#x27;main thread end&#x27; 4. ConditionCondition称为条件变量，提供了Python多线程中复杂的同步支持，除了提供与Lock类似的acquire和release方法外，还提供了wait和notify方法，支持通知 wait：release锁，阻塞，等待notify唤醒 notify：唤醒由wait阻塞的线程 下面使用Condition来模拟一个捉迷藏的游戏 1234567891011121314151617181920212223242526272829303132333435363738394041424344import threadingimport timeclass Seeker(threading.Thread): def __init__(self, cond, name): super(Seeker, self).__init__() self.cond = cond self.name = name def run(self): self.cond.acquire() print self.name + &#x27;: 我已经把眼睛蒙上了&#x27; self.cond.wait() print self.name + &#x27;: 我找到你了 ^o^&#x27; self.cond.notify() self.cond.wait() print self.name + &#x27;: 我赢了&#x27; self.cond.release()class Hider(threading.Thread): def __init__(self, cond, name): super(Hider, self).__init__() self.cond = cond self.name = name def run(self): time.sleep(1) # 睡1秒确保Seeker先运行 self.cond.acquire() print self.name + &#x27;: 我已经藏好了，你快来找我吧&#x27; self.cond.notify() self.cond.wait() print self.name + &#x27;: 被你找到了，哎~~~&#x27; self.cond.notify() self.cond.release()cond = threading.Condition()seeker = Seeker(cond, &#x27;seeker&#x27;)hider = Hider(cond, &#x27;hider&#x27;)seeker.start()hider.start() 执行结果如下 队列Queue多线程很多时候可以与队列一起使用，把任务放到队列，保证线程任务的执行顺序 123456import Queuemyqueue = Queue.Queue(maxsize = 10) # 指定容量，不指定则无限大# 下面方法默认有个block参数和timeout参数，当容量不足或队列没有对象的时候会阻塞当前线程myqueue.put(10) # 存入值进队列myqueue.get(block=False) # 取出队列中的第一个元素，如果没有对象，抛出Queue.Empty异常 可以利用Queue写一个线程安全的队列，如对数据库的操作可以放在一个队列里面进行，这样就可以省去线程同步带来的问题了 1234567891011121314151617181920212223242526272829303132import threadingimport timeimport Queueclass MyThread(threading.Thread): def __init__(self, queue): super(MyThread, self).__init__() self.queue = queue def run(self): (sql, args) = self.queue.get(block=True) while sql != &#x27;q&#x27;: # 假定退出操作为&#x27;q&#x27; time.sleep(0.5) print &#x27;exe %s&#x27; % (sql,) (sql, args) = self.queue.get(block=True)my_queue = Queue.Queue()my_thread = MyThread(my_queue)my_thread.start()my_queue.put((&#x27;insert into user(name, age)&#x27;, (&#x27;bobo&#x27;, 23)))my_queue.put((&#x27;update user set age=24 where name=?&#x27;, (&#x27;bobo&#x27;,)))my_queue.put((&#x27;delete from user where name=?&#x27;, (&#x27;bobo&#x27;,)))# 处理完my_queue.put((&#x27;q&#x27;, ()))print &#x27;wait for sqlite complete&#x27;my_thread.join()print &#x27;complete&#x27; GIL刚接触Python多线程的时候可能会经常遇到GIL这个词，并且GIL还经常与Python不能高效的实现多线程划上等号GIL（global interpreter lock）不是Python的特性，而是CPython的特性，而CPython是通常是Python默认的解释器，而Python本身，不依赖于GIL CPython编译器引入了GIL全局锁（进程）来解决多线程环境下的数据同步问题，即Python对象的内部是thread-safe的，并且被开发者广泛依赖，当然这种简单粗暴的锁不可避免也带来了一定的性能损耗，并且由于GIL的存在，同一时刻只能有一个线程在运行，Python无法充分的利用多核CPU带来的多核计算 CPU密集型通常是计算为主，如图像处理，复杂的数学计算等 IO密集型通常是与硬件相关的，如硬盘、网卡、声卡、显卡，计算机需要等待硬件的耗时处理，比较常见的有文件处理，网络流处理，这时候CPU负载比较低 在CPU密集型的场景下，由于GIL的存在，线程消耗CPU资源比较多，而在多线程下需要频繁的获取和释放锁，带来很大量的开销，所以通常在CPU密集型的场景下，多线程通常不如单线程来得快，建议使用多进程，而不是多线程 在IO密集型的场景下，由于GIL的存在，Python在遇到IO操作的时候回释放锁，建议使用多线程，而不是多进程 当然进程与线程又有自身的优缺点，进程不共享内存，多进程通讯比较麻烦，而线程共享所有内存，通讯更方便，具体如何取舍还是得看具体业务了 关于GIL的更多介绍，可以参见这里 测试CPU密集型和IO密集型场景下的多线程效果 CPU密集型:给一张图片创建1000张缩略图 IO密集型:给一个文件进行重复的读写和删除1000次操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import osimport timeimport threadingimport Queueimport uuidfrom PIL import Imageclass MyThread(threading.Thread): THUMB_SIZE = (75, 75) SAVE_DIRECTORY = &#x27;thumbs&#x27; def __init__(self, queue, is_cpu=True): super(MyThread, self).__init__() self.queue = queue self.is_cpu = is_cpu if is_cpu: # 如果是CPU密集型,只打开一次图片,避免IO操作对测试的影响,图片大一些效果比较好 self.path = u&#x27;/Users/zhengxiankai/Desktop/Python/test.jpg&#x27; self.image = Image.open(self.path) else: self.path = u&#x27;/Users/zhengxiankai/Desktop/Python/test2.png&#x27; def run(self): item = self.queue.get(block=True) while item != &#x27;q&#x27;: # 假定退出操作为&#x27;q&#x27; if self.is_cpu: self.test_cpu(self.image) else: self.test_io(self.path) self.queue.task_done() item = self.queue.get(block=True) self.queue.task_done() def test_cpu(self, img): # 模拟CPU密集型操作,只生成缩略图,不进行IO操作 img.thumbnail(self.__class__.THUMB_SIZE, Image.ANTIALIAS) @staticmethod def test_io(filename): # 模拟IO密集型操作,进行文件读写和删除 base, file_name = os.path.split(filename) file_id = uuid.uuid1() save_path = os.path.join(base, str(file_id) + &quot;.jpg&quot;) # 保存文件 open(save_path, &quot;wb&quot;).write(open(filename, &quot;rb&quot;).read()) # 删除文件 os.remove(save_path)class MyQueue(Queue.Queue): def __init__(self, maxsize=0, thread_count=10, is_cpu=True): Queue.Queue.__init__(self, maxsize=maxsize) self.thread_count = thread_count self.threads = [] self.is_cpu = is_cpu self.create_threads(thread_count) def create_threads(self, thread_count): for i in range(0, thread_count): thread = MyThread(self, self.is_cpu) thread.start() self.threads.append(thread) def finish(self): for _ in range(0, len(self.threads)): self.put(&#x27;q&#x27;)def test(): # 模拟1-10个线程的情况 types = [&#x27;cpu&#x27;, &#x27; io&#x27;] for t in types: for thread_count in range(1, 10): my_queue = MyQueue(thread_count=thread_count, is_cpu=(t == &#x27;cpu&#x27;)) # 模拟1000次操作 for __ in range(0, 1000): my_queue.put(1) # 在处理完后结束所有线程 my_queue.finish() start = time.time() my_queue.join() span = time.time() - start print &#x27;%s: thread_count=%d span=%s&#x27; % (t, thread_count, str(span))test() 用我的MacbookPro测试结果如下： 1234567891011121314151617181920cpu: thread_count=1 span=0.304748058319cpu: thread_count=2 span=0.299258947372cpu: thread_count=3 span=0.359387874603cpu: thread_count=4 span=0.452157974243cpu: thread_count=5 span=0.52136015892cpu: thread_count=6 span=0.610749959946cpu: thread_count=7 span=0.688009023666cpu: thread_count=8 span=0.812467098236cpu: thread_count=9 span=0.939681053162 io: thread_count=1 span=2.01645898819 io: thread_count=2 span=1.76048994064 io: thread_count=3 span=1.45470404625 io: thread_count=4 span=1.45363807678 io: thread_count=5 span=1.10205197334 io: thread_count=6 span=1.02844214439 io: thread_count=7 span=1.0888478756 io: thread_count=8 span=1.01435399055 io: thread_count=9 span=1.0473139286Process finished with exit code 0 上面可以看出，在CPU密集型的场景下，线程越多越慢，在IO密集型的场景下，线程数在6以下，提升效果明显，在6个以上，性能提升的效果不明显，所以Python得多线程也不是一无是处，看具体场景使用","categories":[{"name":"python","slug":"python","permalink":"http://zhengbomo.github.io/categories/python/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://zhengbomo.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"Python","slug":"Python","permalink":"http://zhengbomo.github.io/tags/Python/"}]},{"title":"python学习笔记","slug":"python-start","date":"2016-06-14T12:01:29.000Z","updated":"2016-06-14T12:01:29.000Z","comments":true,"path":"2016-06-14/python-start/","link":"","permalink":"http://zhengbomo.github.io/2016-06-14/python-start/","excerpt":"一直想学习一下Python语言，拥有动态语言的特性，还是解释型语言，拥有高级数据结构，可以以简单而高效的方式进行面向对象编程，并且Python类库众多，适合写脚本，特别是一些小工具，最近把Python语法大概捋了一遍，在这里记录学习的过程","text":"一直想学习一下Python语言，拥有动态语言的特性，还是解释型语言，拥有高级数据结构，可以以简单而高效的方式进行面向对象编程，并且Python类库众多，适合写脚本，特别是一些小工具，最近把Python语法大概捋了一遍，在这里记录学习的过程 一、简介1. 什么是PythonPython是一种编程语言，支持高级数据结构，结构化，Python是一门解释性语言，无需编译即可运行，支持模块化，类库众多且重用性高，例如基础的IO，Socket，图形界面等，模块化使得Python适用于更多领域，绝大多数其他编程语言能做到的Python都能做到，甚至支持与二进制库连接起来，有一句话是这么说的：人生苦短，我用Python 2. 什么时候使用PythonpPython比较使用于编写工具脚本，例如如果你有一些大量的重复的工作，希望计算机可以自动帮你完成，而又找不到相关的软件可以比较完美的实现，这个时候就可以考虑写一个Python脚本来执行，例如： 例如批量扫描文件内容，并替换文件中的文本（执行某些操作） 批量修改文件名 从多个excel文件中提取相关信息并输出到一个excel中 批量抓取网页信息并保存到数据库（爬虫） 通常来说就是使用脚本自动完成一些自定义的行为，主要是Python支持的库（module）众多，能帮助你节省不少时间当然如果你是开发人员，可能通过C++&#x2F;C#&#x2F;Java来写自动化的工具，但是这些工具可能会显得庞大而臃肿，可能会让人觉得这是烦躁而漫长的工作，那么你可以用Python试试 当然Python能做的事远不止这些，支持的类库涵盖了很多领域，如人工智能，机器学习，图像处理，金融，物理学等，当然，很多功能其他语言也能做到，Python最大的优势就是类库众多，处理灵活，我们很多时候都不需要重复造轮子，特别是对于追求效率的你来说，或许是个好选择， 语言只是个工具，没有语言是万能的，什么好用用什么 3. 安装Python学习Python的时候建议使用Python 2.x版本，大多第三方库都基于2.x版本，3.x版本相对于2.x改动比较大，并且一些老的库不支持3.x，我这里使用的是Python 2.7.10，mac系统自带Python，可以通过下面命令查看Python的版本 1234# 默认情况下使用Python查看Python2的版本$ Python -V# 查看Python3的版本$ Python3 -V 4. 工具与其他脚本语言类似（php, js）使用普通的文本编辑器即可，我这里用的是Sublime2，当然也可以使用一些集成IDE Atom：与Sublime类似，支持代码高亮，自动补齐 PyCharm：JetBrains出的Python语言IDE，功能强大，收费 Eclipse：有Python插件提供支持 如果是刚开始学习，推荐使用文本工具（Sublime或Atom） 5. 交互式编程交互式编程相当于一问一答的方式，在Terminal输入Python进入交互式模式，与其他语言不同，Python不以分号结尾，并且通过缩进识别代码块 12345localhost:~ bomo$ PythonPython 2.7.10 (default, Oct 23 2015, 19:19:21)[GCC 4.2.1 Compatible Apple LLVM 7.0.0 (clang-700.0.59.5)] on darwinType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; 二、基础与语法1. 数据类型与其他高级语言一样，除了基础数据类型，Python也支持高级数据类型Python支持如下数据类型 数值类型int, long, float, decimal数值, fraction有理数, complex复数 迭代器类型迭代器类型包括，list, dict, tuple, str, set等 2. 运算符 + - * / % //, **123456# 取整（不大于该数）11 // 3.0 # 3.011 // -3 # -4# 幂运算，与其他语言的`^`类似5 ** 2 # 25 in, not in比较运算符，判断区间或集合是否存在某项 is, is not判断两个对象是否相同 is 与 &#x3D;&#x3D; 的区别 123a, b = 1, 1.0a == b # Truea is b # False python（2.5+）也支持三元运算符，用法与C语言有点出入，形式为 1x if x &gt; y else y # 等价于C语言的 x &gt; y ? x : y 在交互运算中，Python会把最近一次的表达式的值赋值给_，__该变量是只读的，不要尝试给其赋值__，一些不需要的变量有时也用_表示（其实跟普通的变量i一样），如for 123456a = 1010 + 32 # 42a + _ # 52for _ in range(0, 10): print &#x27;这里不需要用到迭代的值&#x27; 3. 流程控制与循环Python的流程控制跟其他语言差不多，关键字有：if-else, for, while, break, continue, pass 3.1 if-else1234567if x == 0: print &#x27;Zero&#x27; print &#x27;ff&#x27;elif x == 1: print &#x27;1&#x27;else: print &#x27;Other&#x27; 3.2 for123words = [&#x27;mac&#x27;, &#x27;windows&#x27;, &#x27;linux&#x27;]for w in words: print w 3.3 pass空语句，与C语言的分号;类似，什么都不执行，通常用来表示一个空的代码块 注意for, if-else, while 后面都有冒号: Python使用缩进来识别块（其他语言多数使用大括号来识别代码块） Python没有do-while语句 Python没有switch-case，也可以参考：http://blog.sina.com.cn/s/blog_6409e7eb01018chn.html 4. 函数4.1 函数定义形式 12def 函数名(函数参数列表): 函数体 eg: 输出一个Fibonacci斐波那契序列 1234567def fib(n): a, b = 0, 1 while a &lt; n: print b, a, b = b, a + bfib(2000) # 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 4.2 参数默认值1234567i = 10def test(a = 12, b = i): print bi = 11; # i为不可变对象，这个时候test函数的参数b的默认值仍为10test(1,2)test(b = 2, a = 12) # 也可以指定参数 从上面例子可以看到，参数的默认值在解释器运行到函数的时候就确定了，如上面的变量b，后面修改的的变量i与函数test没有关联了，有一点需要注意的是，如果默认参数是一个对象的时候，也是同样的，如下面例子 1234567def test(data=[]): # 默认参数为空list data.append(1) return dataprint test() # 输出：[1]print test() # 输出：[1, 1]print test() # 输出：[1, 1, 1] Python解释器在解释道函数test的时候就确定好了函数test的参数默认值，所以每次调用使用的参数对象都是同一个，上面函数应该定义为如下方式 12345def test(data=None): # 默认参数为空list if data is None: data = [] data.append(1) return data 4.3 可变参数123456def test(a, *b): print a for i in b print itest(&#x27;hello&#x27;, &#x27;bob&#x27;, &#x27;james&#x27;, &#x27;adophi&#x27;) # &#x27;hello&#x27;, &#x27;bob&#x27;, &#x27;james&#x27;, &#x27;adophi&#x27; 可变参数必须定义为最后一个（在可变字典参数前） 4.4 可变字典参数1234567def test(a, *b, **c): keys = sorted(c.keys()) for kw in keys: print kw, &quot;:&quot;, keywords[kw]test(&#x27;box&#x27;, &#x27;value1&#x27;, &#x27;value2&#x27;, width=100, height=200, color=&quot;red&quot;, rttt = 21) 可变字典参数必须定义在最后一个 4.5. lambda表达式形式 1lambda 函数参数列表: 函数体 eg: 使用Lambda表达式给列表排序 123456pairs = [(1, &#x27;one&#x27;), (2, &#x27;two&#x27;), (3, &#x27;three&#x27;), (4, &#x27;four&#x27;)]pairs.sort(key = lambda pair: pair[0])pairs[(4, &#x27;four&#x27;), (1, &#x27;one&#x27;), (3, &#x27;three&#x27;), (2, &#x27;two&#x27;)] 5. 装饰器参见这里 6. 序列首先看看迭代器类型，Python常用的序列类型有list, tuple, str 12345678910111213141516171819squares = [1, 4, 9, 16, 25] # 列表squares = [&#x27;spam&#x27;, &#x27;eggs&#x27;, 100, 1234] # 支持不同类型squares[1] = &quot;eeee&quot; # 支持索引，越界会报错last = squares[-1] # 复数表示从最后开始## 支持切片（支持list,tuple,str）squares[a:b:c] # 表示从下标a到下标b且不包含下标b，取步长为c的集合，步长为正向右，步长为负向左a = squares[1:3] # [&#x27;eeee&#x27;, 100]squares[1:3] = [] # 删除下标为1-2的项squares[-2:100] = [] # 切片范围越界不报错，自动取临界值squares # [&#x27;spam&#x27;, 1234]squares[1:5:2] # 支持步长，每次进两个元素，默认为一个[4, 16]squares[5:1:-2] # 步长为负数，表示从后往前：[25, 9]# range函数range(10) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]range(5, 10) # [5, 6, 7, 8, 9]range(0, 12, 3) # [0, 3, 6, 9] 6.1. 字符串字符串是特殊的列表 1234567891011print &#x27;&quot;Yes,&quot; he said.&#x27; # 使用单双引号表示单行字符串：&quot;...&quot; &#x27;...&#x27;print &#x27;First line.\\nSecond line.&#x27; # 使用反斜杠`\\`转义，print &quot;C:\\some\\name&quot; # 换行print r&#x27;C:\\some\\name&#x27; # 字符串前面添加`r`表示`\\`不转义# 使用三个引号定义多行字符串 &quot;&quot;&quot;...&quot;&quot;&quot; &#x27;&#x27;&#x27;...&#x27;&#x27;&#x27;print &quot;&quot;&quot;\\ # 行尾使用反斜杠`\\`表示该行后面接下一行aafdsafdsbb&quot;&quot;&quot; # 结束 格式化字符串，Python使用%隔开格式化字符串和值 123from math import piprint &#x27;Hello %s, pi is %10.2f&#x27; % (&#x27;World&#x27;, pi)# Hello World, pi is 3.14 当像%s这种符号变多了之后，就很难分清楚哪个和哪个了，Python支持使用dict作为格式化参数，如下 12print &#x27;%(name)s is %(age)d years old&#x27; % &#123;&#x27;name&#x27;: &#x27;bomo&#x27;, &#x27;age&#x27;: 18&#125;# bomo is 18 years old 还有这种方式 12print &#x27;&#123;name&#125; is &#123;age:2d&#125; years old&#x27;.format(name=&#x27;bomo&#x27;, age=18)# bomo is 18 years old Python格式化字符串还支持索引 12print &#x27;&#123;name&#125; is &#123;1:2d&#125; years old&#x27;.format(12, 18, name=&#x27;bomo&#x27;)# bomo is 18 years old 最后一种方式是最Pythonic的，也是最推荐的方式 6.2 序列常用操作 加法乘法 12squares + [&#x27;a&#x27;, &#x27;b&#x27;] # [&#x27;spam&#x27;, 1234, &#x27;a&#x27;, &#x27;b&#x27;]l = squares * 2 # [&#x27;spam&#x27;, 1234, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;spam&#x27;, 1234, &#x27;a&#x27;, &#x27;b&#x27;] 元素操作 1234567squares.append(&#x27;jobs&#x27;) # 添加squares.extend([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]) # 添加集合squares.insert(0, x) # 插入元素squares.remove(&#x27;b&#x27;) # 删除值为&#x27;b&#x27;的第一个元素squares.pop([1]) # 删除第1个元素，并返回该元素squares.index(&#x27;b&#x27;) # 获取值为&#x27;b&#x27;的索引squares.count(&#x27;b&#x27;) # 获取值为&#x27;b&#x27;的出现次数 统计操作 123len(squares)max(squares)min(squares) 删除操作 123a = [-1, 1, 66.25, 333, 333, 1234.5]del a[0] # [1, 66.25, 333, 333, 1234.5]del a[2:] # [1, 66.25] 6.3 切片的原理切片内部是调用__getitem__，__setitem__,__delitem__和slice函数 1234a = [1, 2, 3, 4, 5, 6]x = a[1: 5] # x = a.__getitem__(slice( 1, 5, None ))a[1: 3] = [10, 11, 12] # a.__setitem__(slice(1, 3, None), [10, 11, 12])del a[1: 4] # a.__delitem__(slice(1, 4, None)) 7. 元组tuple元组相当于多维数组，与序列一样，元组元素支持任意类型，用括号表示，括号有时可以省略（不产生歧义的情况下） 123456789101112131415t = (1, 2)t = 1, 2 # 省略括号t = (&#x27;a&#x27;, 23)t = ([&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2])# 空元组empty = ()# 单元素元组，逗号不能少single = (11,)single = 11,# 如sqlite操作的时候cursor.execute(&#x27;select * from user where gender = ?&#x27;, (&#x27;female&#x27;,)) 元组各个元素可以同时赋值 123t = (1, 2)x, y = t # x = 1, y = 2x, y = 1, 2 # 同上 元组使得函数返回多个值变得更加方便 12def get_point(): return (2, 4) 与列表不同，元组是不可变的，如果想修改，只能生成新的元组 8. 字典dict用法与其他语言类似 1234567891011121314151617tel = &#123;&#x27;jack&#x27;: 4098, &#x27;sape&#x27;: 4139, &#x27;bomo&#x27;: 10086&#125;tel[&#x27;guido&#x27;] = 4127del d[&#x27;bomo&#x27;]tel = dict(jack=4098, sape=4139)# 空字典tel = &#123;&#125;# 迭代for key in tel: print keyfor value in tel.itervalues(): print valuefor (key, value) in tel.iteritems(): print &#x27;key=%s, value=%s&#x27; % (key, value) 列表推倒式和字典推导式 列表推导式形式：[expression for value in collection if condition]，相当于 12345result = []for value in collection: if condition: result.append(expression)return result 例如 1[i for i in range(1,100) if i &gt; 90] # [91, 92, 93, 94, 95, 96, 97, 98, 99] 字典推导式形式：&#123;key_expression: value_expression for value in tuple&#125; ，相当于 12345result = &#123;&#125;for value in collection: if condition: result[key_expression] = value_expressionreturn result 例如： 1&#123;x+1: x**2 for x in (2, 4, 6, 8) if x &lt;= 6&#125; # &#123;3: 4, 5: 16, 7: 36&#125; 9. 无序集set1234567891011basket = [&#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;, &#x27;banana&#x27;]fruit = set(basket) # [&#x27;orange&#x27;, &#x27;pear&#x27;, &#x27;apple&#x27;, &#x27;banana&#x27;]# 操作符（自动去重）a = set(&#x27;abracadabra&#x27;) # set([&#x27;a&#x27;, &#x27;r&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;])b = set(&#x27;alacazam&#x27;) # set([&#x27;a&#x27;, &#x27;c&#x27;, &#x27;z&#x27;, &#x27;m&#x27;, &#x27;l&#x27;])a - b # set([&#x27;r&#x27;, &#x27;d&#x27;, &#x27;b&#x27;])a | b # set([&#x27;a&#x27;, &#x27;c&#x27;, &#x27;b&#x27;, &#x27;d&#x27;, &#x27;m&#x27;, &#x27;l&#x27;, &#x27;r&#x27;, &#x27;z&#x27;])a &amp; b # set([&#x27;a&#x27;, &#x27;c&#x27;])a ^ b # set([&#x27;r&#x27;, &#x27;d&#x27;, &#x27;b&#x27;, &#x27;m&#x27;, &#x27;z&#x27;, &#x27;l&#x27;]) 10. 迭代器类型常用操作 enumerate使用enumerate函数可以同时得到索引和值 12for i, v in enumerate([&#x27;tic&#x27;, &#x27;tac&#x27;, &#x27;toe&#x27;]): print(i, v) zip多个循环可以用zip打包，以最短的list为准 12345678910questions = [&#x27;name&#x27;, &#x27;quest&#x27;, &#x27;favorite color&#x27;]answers = [&#x27;lancelot&#x27;]cc = [&#x27;lancelot&#x27;, &#x27;the holy grail&#x27;, &#x27;blue&#x27;, &#x27;eeeee&#x27;]for q, a, c in zip(questions, answers, cc): print &#x27;What is your &#123;0&#125;? It is &#123;1&#125;.&#123;2&#125;&#x27;.format(q, a, c)# 输出# What is your name? It is lancelot.# What is your quest? It is the holy grail.# What is your favorite color? It is blue. reversed反序 1234for i in reversed([1,2,3]): print(i)# 输出：3, 2, 1&gt;&gt;&gt; iteritems遍历字典使用iteritems可以同事获得key, value 123456knights = &#123;&#x27;gallahad&#x27;: &#x27;the pure&#x27;, &#x27;robin&#x27;: &#x27;the brave&#x27;&#125;for k, v in knights.iteritems(): print k, v# 输出# gallahad the pure# robin the brave filter过滤器，给定过滤函数和集合: filter(function, sequence) 123def f(x): return x % 3 == 0 or x % 5 == 0filter(f, range(2, 25)) # [3, 5, 6, 9, 10, 12, 15, 18, 20, 21, 24] map给定集合和操作函数，返回操作后的集合：map(function, sequence) 123def cube(x): return x*xmap(i, range(1, 6)) # [1, 4, 9, 16, 25, 36] reduce首先操作前两个数，然后结果与后一个数运算，以此类推：reduce(function, sequence) 12345def add(x,y): return x+yreduce(add, range(1, 11)) # 1+2+3+4+5+6+7+8+9+10=55reduce(lambda (x, y): x + y, range(1, 11)) # 55 11. 迭代器与生成器参见这里 12 类12.1 构造函数__init__，析构函数__del__12345678910class test: def __init__(self, x, y): self.x = x self.y = y def __del__(self): print &#x27;对象被释放&#x27;t = test(10, 20)t.x + t.y 注意，Python的构造函数不支持重载，只能有一个构造函数，可以通过可变参数实现多构造函数在调用父类的构造方法见后面新式类和经典类 12.2 方法与变量类变量定义在类中，实例变量定义在构造函数中，Python中的类实例可以直接设置属性，如果属性不存在，则添加属性 123456789101112131415161718192021222324class test: count = 0; # 定义类变量 def __init__(self, c): # 构造函数 self.count = c; # 定义实例变量count self.name = &#x27;bomo&#x27; # 定义实例变量name self.__class__.count = self.__class__.count + 1; # 操作类变量 def sayHi(self): # 实例方法 print &#x27;Hello, your name is?&#x27;,self.name @staticmethod #声明静态，去掉则编译报错;还有静态方法不能直接访问类变量和实例变量 def sayName(): print &quot;my name is king&quot; @classmethod # 静态变量无法直接访问到类变量，类方法可以，通过cls参数 def test2(cls): print clst = test(10)test.count # 1tt = test(20)test.count # 2t.count # 10tt.count # 20 12.3 类里面引用全局变量当类里面需要引用外部的全局变量的时候需要，加上global关键字 12345678910111213global_count = 0global_count2 = 0def test(): global global_count # 声明全局变量 global_count += 10 global_count2 = 10 # 局部变量 print &#x27;%d, %d&#x27; % (global_count, global_count2)print &#x27;%d, %d&#x27; % (global_count, global_count2)test()print &#x27;%d, %d&#x27; % (global_count, global_count2) 12.4 实例方法，类方法，静态方法在Python中这几种方法特别容易，类属性和方法不能重名，否则会相互覆盖 1234567891011121314class Person: staticName = &#x27;bomo&#x27; def __init__(self,name): self.name = name def sayHi(self): # 实例方法加上self参数 print &#x27;Hello &#x27; + self.name @staticmethod # 声明静态方法，下面方法都为静态方法 def sayName(): # 没有self参数 print &quot;static method&quot; + Person.staticName # 静态方法通过类名调用静态实例staticName @classmethod # 声明类方法，下面方法都为类方法 def classMethod(cls): # 有一个cls参数，类对象 print &quot;class method&quot; + Person.staticName 其他语言如java和C#都只有静态方法和类方法，而Python多了一个类方法，在大多数情况下，使用静态方法即可，在需要获取调用类的信息的时候（如类变量，类类型，类名等），则需要使用类方法 方法的第一个参数被命名为 self。这仅仅是一个约定：对 Python 而言，名称 self 绝对没有任何特殊含义(但是请注意：如果不遵循这个约定，对其他的 Python 程序员而言你的代码可读性就会变差，而且有些类查看器程序也可能是遵循此约定编写的。)，在交互式命令行中会报错 12.5 继承父类放在子类定义的类名后的括号内，Python支持多继承 1234class DerivedClassName(Base1, Base2, Base3): passclass son(father): pass 单继承：如果子类有自己实现的构造函数，则不会自动调用父类的构造函数，如果子类没有实现构造函数，则会继承父类的构造函数多继承：如果子类有自己实现的构造函数，同单继承，不会主动调用父类的构造函数，如果子类没有实现自己的构造函数，则会从父类中优先选择有构造函数的父类（__深度搜索__） 判断实例与继承关系 12345678s = son()# 判断实例isinstance(s, son) # Trueisinstance(s, father) # True# 判断继承关系issubclass(son, father) # True, son继承自fatherisinstance(obj, Class) # 判断实例是否是某个类 12.6 新式类和经典类新式类：从object类继承的类，继承顺序广度优先经典类：不从object继承的类，继承顺序深度优先，不支持super 12345678910111213141516171819202122232425262728293031# 新式类class Parent(object): def __init__(self): print &#x27;parent&#x27; def hi(self): print &#x27;parent hi&#x27;class Son(Parent): def __init__(self): # 新式类支持super super(Son, self).__init__() print &#x27;son&#x27; def hi(self): super(Son, self).hi() print &#x27;son hi&#x27;# 经典类class Parent: def __init__(self): print &#x27;parent&#x27; def hi(self): print &#x27;parent hi&#x27;class Son(Parent): def __init__(self): # 不支持super Parent.__init__(self) print &#x27;son&#x27; def hi(self): Parent.hi(self) print &#x27;son hi&#x27; 子类可以通过super(类, 对象)获取父对象父类对象的实例，然后可以调用父类的（同名）方法，就相当于Java中的super，C#中的base 13. 模块module, 包package Python在处理功能复用组织结构切分为模块,包和面向对象的类，其结构类似于C#&#x2F;Java的命名空间，用于 13.1 引用模块1234567891011121314151617181920import math # 引用math模块print math.sqrt(2) # 正确输出print sqrt(2) # 报错，未导入sqrt函数##########################import math as nmath # 引用math模块，并取别名nmathprint nmath.sqrt(2) # 正确输出print math.sqrt(2) # 报错，未找到math的定义##########################from math import sqrt # 导入模块中的函数print sqrt(2) # 正确输出print math.sqrt(2) # 会报错，没有导入math##########################from math import * # 不导入单下划线开头的函数和属性，不建议这么做，这么写语义不明确，并且在多模块中存在冲突的风险print sqrt(2) 文件名就是模块的名字：test.py的模块名为test 第一次导入模块的时候会自动执行模块内的所有代码 通过Python执行py模块的时候__name__变量会被设为__main__，如果是import，则不会，可以通过__name__变量判断是否是命令行执行 使用下划线_前缀定义类私有函数或变量 _xxx 单下划线开头，在from module import *导入会忽略，但不是私有方法 __xxx__ 双下划线开头和结尾，系统定义名字 __xxx 双下划线开头，类中的私有变量名 13.2 dir函数查看模块可以通过dir函数查看模块内定义的所有变量和函数 12import mathdir(math) 13.3 模块搜索路径在导入模块的时候，Python会自动从以下目录搜索该模块是否存在 输入脚本的目录(当前目录)。 环境变量 PYTHONPATH 表示的目录列表中搜索 Python 默认安装路径中搜索 可以通过sys.path查看所有目录 12import syssys.path 13.4 package包多个模块组织成一个package，类似于java的jar包，C#的dll可执行文件，包在Python中相当于一个文件夹，包文件夹包含__init__.py文件，该文件用于初始化package 1234567sound/ Top-level package __init__.py Initialize the sound package formats/ Subpackage for file format conversions __init__.py wavread.py wavwrite.py aiffread.py 使用package方式与module类似 12345# 使用wavread需要引用sound.formatimport sound.format.wavread# 可以直接使用wavreadfrom wavread import sound.format 13.5 __init__.py文件__init__.py文件可以包含一些包初始化的内容，可以定义默认导入的模块 1__all__ = [&quot;wavread&quot;, &quot;wavwrite&quot;] 在使用from sound.formats import *的时候只会导入wavread, wavwrite两个模块，而不会导入aiffread模块 导入包的时候，先初始化__init__.py文件，再初始化模块文件 13.6 包内引用只有包才能引用包，纯目录不能互相引用，所以只有目录下有__init__.py文件才能被其他目录的模块引用 123from . import echo # 当前包同目录下的echo模块from .. import formats # 当前包上级目录下的formats模块from ..filters import equalizer # 当前包上级目录下的filters目录下的equalizer模块 13.7 模块操作删除模块属性&#x2F;函数 1234567891011121314class test: a = 10 def f(self, i): print it = test()t.a = 10 # 10t.f(&#x27;hello world&#x27;) # hello worlddel test.a # remove property adel test.f # remove method ft.a # 报错：test instance has no attribute &#x27;a&#x27;t.f(&#x27;hello world&#x27;) # 报错：test instance has no attribute &#x27;f&#x27; Python算是动态语言，属性和函数即写即用，不需要提前定义好，模块也可以即时导入即时卸载 14. 文档注释文档注释跟在相应的定义后面：函数定义，类定义，文件定义（文件头） 123456789#!usr/bin/env Python&quot;&quot;&quot;foo.py -- 模块注释&quot;&quot;&quot;class Foo(object): &quot;&quot;&quot;这里是类注释，这是一个类为空&quot;&quot;&quot;def printmsg(msg): &quot;&quot;&quot;这里是方法注释&quot;&quot;&quot; print msg 可以通过help或__doc__访问注释内容 12345# 列出整个模块的所有注释help(foo)# 列出类Foo的类注释Foo.__doc__ 15. 异常Python的异常处理和其他语言类似:try-except-finally，抛出异常使用raise 1234567try: raise Exception(&#x27;spam&#x27;, &#x27;eggs&#x27;) # 手动抛出异常except Exception as inst: # 设置异常实例别名，用于引用 print type(inst) # 获取异常类型 print inst.args # 获取异常实例finally: # 无论是否抛出异常，都会执行，与JAVA,C#其他语言一样 print &quot;始终会执行&quot; 16. 多线程参见这里 17. Python常用模块time12345678910111213141516import timeimport datetime# 格式化输出当前本地时间：[https://docs.Python.org/2/library/time.html#time.strftime](https://docs.Python.org/2/library/time.html#time.strftime)print = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime())today = datetime.date.today()oneday = datetime.datetime(2016, 06, 08, 13, 14, 15, 16)# 时间差timespan = today - onedayprint timespan.total_seconds()# 构造时间差timespan = datetime.timedelta(day=1) IO123456789101112131415161718192021222324252627282930313233343536# 打印到屏幕print &#x27;hello world&#x27;# 输入一行，输入的值被当做变量str = raw_input(&quot;请输入变量str：&quot;);# 输入一个表达式str = input(&#x27;请输入一个表达式：&#x27;)# 打开并写入文件fo = open(&quot;foo.txt&quot;, &quot;wb&quot;)fo.write(&quot;hello world!\\n&quot;);# 打开并读取文件fo = open(&quot;foo.txt&quot;, &quot;r+&quot;)str = fo.read(10);position = fo.tell(); # 获取文件当前读取到的位置position = fo.seek(2, 1); # 从当前位置向前移动2个字节# 关闭文件fo.close()# 重命名文件import osos.rename(&#x27;old.txt&#x27;, &#x27;new.txt&#x27;)os.remove(&#x27;old.txt&#x27;)os.mkdir(&#x27;newFolder&#x27;)# 修改当前目录os.chdir(&quot;/Users/bomo/Downloads&quot;)# 获取当前目录print os.getcwd()# 删目录os.rmdir(&#x27;/Users/bomo/Downloads/newFolder&#x27;) 正则表达式1234567import re# 匹配从头匹配print(re.match(r&#x27;www&#x27;, &#x27;www.runoob.com&#x27;).span())# 查找匹配print(re.search(r&#x27;www&#x27;, &#x27;www.runoob.com&#x27;).span())# 替换print re.sub(pattern, replaceString, inputString) match和search有第三个参数flag，match(pattern, input, flag) 1print(re.search(r&#x27;WWW&#x27;, &#x27;www.runoob.com&#x27;, flags=re.I).string) flag 用法 I 忽略大小写 M 多行模式 S 单选模式——点任意匹配模式 L 使预定字符类 \\w \\W \\b \\B \\s \\S 取决于当前区域设定 U 使预定字符类 \\w \\W \\b \\B \\s \\S \\d \\D 取决于unicode定义的字符属性 X 详细模式。该模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。 本文记录自己在学习过程中总结的一些Python要点，接触过Java，C#，OC，Python的语法确实简单优雅，很少多余的东西，人生苦短，Python是岸","categories":[{"name":"python","slug":"python","permalink":"http://zhengbomo.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://zhengbomo.github.io/tags/python/"}]},{"title":"iOS获取当前ViewController","slug":"find-current-viewcontroller","date":"2016-05-11T06:36:16.000Z","updated":"2016-05-11T06:36:16.000Z","comments":true,"path":"2016-05-11/find-current-viewcontroller/","link":"","permalink":"http://zhengbomo.github.io/2016-05-11/find-current-viewcontroller/","excerpt":"做iOS开发的时，很多时候我们需要对获取当前所在的ViewController，搜了一下，大多数答案都不靠谱，都不能正确获取到当前的控制器，不一定能获取到当前的ViewController，于是自己写了一个方法","text":"做iOS开发的时，很多时候我们需要对获取当前所在的ViewController，搜了一下，大多数答案都不靠谱，都不能正确获取到当前的控制器，不一定能获取到当前的ViewController，于是自己写了一个方法 iOS自带的ViewController有两种 一种是普通控制器：UIViewController, UITableViewController, UISearchBarController等 一种是容器控制器： UINavigationController：通过childViewController.lastObject获取当前控制器 UITabBarController通过selectedViewController 获取当前控制器 页面跳转有push和present，如果有present控制器，则直接取弹出的控制器，如果是导航控制器，则取最后一个，然后一层一层往下取，代码如下 12345678910111213141516171819202122232425262728293031323334/** 获取当前控制器 */+ (UIViewController *)currentVC&#123; UIWindow *window = [[UIApplication sharedApplication] keyWindow]; //当前windows的根控制器 UIViewController *controller = window.rootViewController; //通过循环一层一层往下查找 while (YES) &#123; //先判断是否有present的控制器 if (controller.presentedViewController) &#123; //有的话直接拿到弹出控制器，省去多余的判断 controller = controller.presentedViewController; &#125; else &#123; if ([controller isKindOfClass:[UINavigationController class]]) &#123; //如果是NavigationController，取最后一个控制器（当前） controller = [controller.childViewControllers lastObject]; &#125; else if ([controller isKindOfClass:[UITabBarController class]]) &#123; //如果TabBarController，取当前控制器 UITabBarController *tabBarController = (UITabBarController *)controller; controller = tabBarController.selectedViewController; &#125; else &#123; if (controller.childViewControllers.count &gt; 0) &#123; //如果是普通控制器，找childViewControllers最后一个 controller = [controller.childViewControllers lastObject]; &#125; else &#123; //没有present，没有childViewController，则表示当前控制器 return controller; &#125; &#125; &#125; &#125;&#125; 上面代码只处理了NavigationController和TabBarController，如果你没有修改过NavigationController和TabBarController的默认行为，页面跳转使用默认的push和present，那么是可以正常获取到的","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"}]},{"title":"函数式编程","slug":"functional-programming-tip","date":"2016-05-05T03:24:28.000Z","updated":"2016-05-05T03:24:28.000Z","comments":true,"path":"2016-05-05/functional-programming-tip/","link":"","permalink":"http://zhengbomo.github.io/2016-05-05/functional-programming-tip/","excerpt":"函数式编程（英语：functional programming）或称函数程序设计，又称泛函编程，是一种编程范型，它将电脑运算视为数学上的函数计算，并且避免使用程序状态以及易变对象。函数编程语言最重要的基础是λ演算（lambda calculus）。而且λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。","text":"函数式编程（英语：functional programming）或称函数程序设计，又称泛函编程，是一种编程范型，它将电脑运算视为数学上的函数计算，并且避免使用程序状态以及易变对象。函数编程语言最重要的基础是λ演算（lambda calculus）。而且λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。 上面是维基百科上的解释，可以把编程语言中的函数视为数学函数一样，函数可以与普通变量一样，作为另一个函数的参数，如下 123f(x) = x * x + 2g(x) = f(x) + f(x + 2)h(x) = g(x) + f(x - 1) 函数式编程有以下几个特点（下面例子用的是python） 避免状态变量，注重状态传递，而不是状态维护非函数式 1234a = 0def increment1(): global a a += 1 函数式 12def increment2(a): return a + 1 函数是一等公民即函数与变量一样，可以作为参数传递 123456789101112131415# 定义一个过滤器def myFilter(x): return x &lt; 5# 过滤函数def myMap(filter, array): result = [] for i in array: if filter(i): result.append(i) return result# 过滤集合print myMap(myFilter, [1,2,5,7,8,9])# 输出 [1, 2] 高阶函数高阶函数满足以下两个特点 函数可以作为参数被传递 函数可以作为返回值输出 123456789101112# 函数作为参数def add(x, y, f): return f(x) + f(y)# 函数作为返回值def calc(x): # 接收第一个参数 def square(n): # 接收第二个参数 return n * n + x; # 计算 return s(x);c = calc(4) # n*n+4print c(3) # 3*3+4 从上面例子可以看出来，一个n * n + x计算是通过两步进行的，并且参数也分成多个单一的参数，这种过程称为函数的柯里化(Currying)，下面是维基百科上的解释 在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。 惰性求职 在使用函数处可以不直接执行函数，在需要的时候执行函数，如上高阶函数以函数作为返回值，在调用calc的时候并没有进行计算，而是后面调用返回的函数才进行计算 闭包闭包就是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。有时候你不需要知道闭包的概念，也能很好的应用它，有一个直观的解释：可以自由访问变量(局部变量和内部变量)的代码块 1234567outa = 200def calc(x): a = 100 def square(n): # 这里可以访问局部变量a，也可以访问函数外的自由变量outa return n * n + a + outa + x; return s(x); 例如objc的block，就是对闭包的支持 面向功能，而不面向过程，重视功能粒度化，函数化函数式 12345names = [&quot;Mary&quot;, &quot;Isla&quot;, &quot;Sam&quot;]# 使用map，reducename_lengths = map(len, names)print name_lengths# =&gt; [4, 4, 3] 非函数式 12345# 而不是forname_lengths = []for n in names: name_lengths.append(len(n))print name_lengths 函数式编程就是功能函数化，粒度化，注重行为，而不注重过程，注重操作，而不注重状态的一种方编程思想，可以很大程度的提高代码的阅读性，因为函数本身就是一种注释，这种粒度使得代码可以更好的自解释，而闭包的特性使得代码拥有更高的聚合度，减少函数多带来的代码松散问题 我的理解是编程思想只是思考问题的一些不同的角度，并不是绝对的，可能一些代码中既有函数式编程的特点也有面向对象的思想，例如Python就是一种多范式语言，所以在实际应用中不需要过于刻意的区分，而是根据这些特点和具体业务找到合适的方式","categories":[{"name":"技术","slug":"技术","permalink":"http://zhengbomo.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://zhengbomo.github.io/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"为自己的库添加CocoaPods支持","slug":"cocoapod-specs-start","date":"2016-05-04T08:39:17.000Z","updated":"2023-06-11T03:02:51.859Z","comments":true,"path":"2016-05-04/cocoapod-specs-start/","link":"","permalink":"http://zhengbomo.github.io/2016-05-04/cocoapod-specs-start/","excerpt":"做iOS开发的基本上都知道cocoapod，几乎每一种语言都有一种包管理工具，如C#的Nuget，Ruby的Brew，Nodejs的npm等，当然cocoapod就是objc&#x2F;swift的包管理的工具了，几乎所有的objc&#x2F;swift的开源类库都挂在cocoapod上，cocoapod可以让项目很方便的引用第三方类库，今天介绍一下如果把自己的写的库挂到cocoapod上，像SDWebImage, AFNetworking一样","text":"做iOS开发的基本上都知道cocoapod，几乎每一种语言都有一种包管理工具，如C#的Nuget，Ruby的Brew，Nodejs的npm等，当然cocoapod就是objc&#x2F;swift的包管理的工具了，几乎所有的objc&#x2F;swift的开源类库都挂在cocoapod上，cocoapod可以让项目很方便的引用第三方类库，今天介绍一下如果把自己的写的库挂到cocoapod上，像SDWebImage, AFNetworking一样 1. 创建仓库首先我们需要建立仓库用于存放我们的类库，cocoapod支持git仓库，大多数类库都存放在github上，当然也可以用别的git仓库，如OSChina，coding，当然，仓库必须是public的 新建仓库后，需要添加LICENCE，大多数git工具在仓库初始化的时候都可以选择添加 当然最好也添加README.md文件，对项目做一些描述 接下来是把Responsitory clone下来，然后添加工程，添加Demo 123456├── xxx # 库相关文件：.h文件，.m文件，.a库，bundle资源，.framework库等├── xxxDemo # 最好提供Demo，方便别人快速了解和熟悉你的类库，可选├── .gitignore # 过滤文件规则├── xxx.podspec # cocoapod库描述文件，后面说到├── LICENCE # 许可说明，通常用的是 MIT└── README.md # 仓库说明文件，可选 2. 创建podspec文件podspec是一个库描述文件，描述一个库如何被加入到工程中，下面举个例子如JSONModel的podspec文件 12345678910111213141516171819202122232425262728293031323334353637383940Pod::Spec.new do |s| s.name = &quot;JSONModel&quot; s.version = &quot;1.2.0&quot; s.summary = &quot;Magical Data Modelling Framework for JSON. Create rapidly powerful, atomic and smart data model classes.&quot; s.homepage = &quot;http://www.jsonmodel.com&quot; s.license = &#123; :type =&gt; &#x27;MIT&#x27;, :file =&gt; &#x27;LICENSE_jsonmodel.txt&#x27; &#125; s.author = &#123; &quot;Marin Todorov&quot; =&gt; &quot;touch-code-magazine@underplot.com&quot; &#125; s.source = &#123; :git =&gt; &quot;https://github.com/icanzilb/JSONModel.git&quot;, :tag =&gt; &quot;1.2.0&quot; &#125; # 最低支持版本 s.ios.deployment_target = &#x27;6.0&#x27; s.osx.deployment_target = &#x27;10.7&#x27; s.watchos.deployment_target = &#x27;2.0&#x27; s.tvos.deployment_target = &#x27;9.0&#x27; # 源文件 s.source_files = &#x27;JSONModel/**/*.&#123;m,h&#125;&#x27; # bundle资源文件 # s.resources = &#x27;Assets&#x27; # public头文件 s.public_header_files = &#x27;JSONModel/**/*.h&#x27; # 是否开启ARC模式 s.requires_arc = true # 系统依赖框架 s.frameworks = &#x27;Foundation&#x27;, &#x27;UIKit&#x27; # 第三方依赖库 #s.dependency &#x27;AFNetworking&#x27;, &#x27;~&gt; 2.6&#x27; # 静态库.a或.framework # s.vendored_libraries = &#x27;lib/Mipush.a&#x27; # xcconfig配置 #s.xcconfig = &#123;&#x27;OTHER_LDFLAGS&#x27; =&gt; &#x27;-ObjC&#x27;&#125;end podspec可以通过下面命令创建，也可以直接拿上面内容或其他第三方库的podspec进行修改 1$ pod spec create podspec_name podspec文件是用ruby写的，基本上可以直接看得懂，关于podspec文件官方有详细的说明：https://guides.cocoapods.org/syntax/podspec.html 3. 推送到github编辑完podspec文件后，我们把所有文件push到github，push之前，如果在podspec设置source关联tag，见这里，那么我们需要给当前的仓库打一个版本标签，版本与podspec描述的版本一致 123$ git tag &#x27;1.2.0&#x27; $ git push --tags$ git push origin master 4. 在cocoapod注册trunk信息cocoapod使用trunk的方式管理和提交podspec文件，关于trunk的更多说明，参见官网 注册trunk 1$ pod trunk register zhengbomo@hotmail.com &#x27;bomo&#x27; --description=&#x27;iOS player&#x27; --verbose 执行完成后，你的邮箱会受到一个验证邮件，打开验证通过，验证通过后，可以通过pod trunk me查看自己的信息，下面是我的信息 12345678ACA80164:Responsitory zhengxiankai$ pod trunk me - Name: bomo - Email: zhengbomo@hotmail.com - Since: May 3rd, 01:23 - Pods: None - Sessions: - May 3rd, 01:23 - September 8th, 01:25. IP: 106.120.250.167 Description: iOS player 如果能看到自己注册的信息，就可以了，cocoapod不通过密码验证用户，而是通过session token，这个时候就可以提交pod了 5. 提交podspec文件注册完成后，先设置一下需要验证的版本 12set the new version to 1.2.0set the new tag to 1.2.0 cd到xxx.podspec文件所在的目录，验证一下本地的podspec文件是否正确 1234$ pod lib lint# 验证成功会有提示xxx passed validation. 上面过程都没有问题，上传podspec到pod服务器 1$ pod trunk push xxx.podspec 等待几分钟，如果验证通过，就直接发布了，如果是更新库，则需要改版本号，方法与发布一样 自己发布的库只有自己才能修改&#x2F;更新，可以添加所有者授权别人修改，xxx为库名称如SDWebImage 1$ pod trunk add-owner xxx zhengbomo@hotmail.com 6. 验证如果提交完成，就可以通过pod search搜索出来了 1$ pod search xxx 如果搜索不出来，可以尝试更新一下本地的pod库列表 1$ pod setup 7. 参考链接 http://blog.csdn.net/wzzvictory/article/details/20067595 http://yulingtianxia.com/blog/2014/05/26/publish-your-pods-on-cocoapods-with-trunk/","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"cocoapod","slug":"cocoapod","permalink":"http://zhengbomo.github.io/tags/cocoapod/"}]},{"title":"合并和分离.a和.framework库","slug":"merge-ios-lib","date":"2016-04-29T10:50:52.000Z","updated":"2016-04-29T10:51:41.000Z","comments":true,"path":"2016-04-29/merge-ios-lib/","link":"","permalink":"http://zhengbomo.github.io/2016-04-29/merge-ios-lib/","excerpt":"Xcode在生成库（.a或.framework）的时候，通常会生成两个版本，一个是用于真机的版本，一个是用于模拟器的版本 真机：armv7, armv7s, arm64架构 模拟器：i386, x86_64","text":"Xcode在生成库（.a或.framework）的时候，通常会生成两个版本，一个是用于真机的版本，一个是用于模拟器的版本 真机：armv7, armv7s, arm64架构 模拟器：i386, x86_64 如果在库和项目在同一个工程中，通常会自动根据当前是模拟器还是真机自动引用相关的库文件 在使用第三方库的时候通常只有一个.a库，这个库既能用于真机调试，又能用于模拟器调试，这个时候我们需要对不同的架构的库进行合并 使用lipo对不同架构的库进行合并，在编译的时候会自动识别 一、.a库合并与拆分例如有两个不同架构的库liba-arm64.a, liba-i386.a 查看库的架构信息 123lipo -info liba-arm64.ainput file liba-arm64.a is not a fat fileNon-fat file: liba-arm64.a is architecture: arm64 如果静态库支持多种架构，那么就是一个fat file 合并两个库 1lipo -create liba-arm64.a liba-i386.a -output liba.a 合并成liba.a到当前目录 抽取出arm64库 1lipo liba.a -thin arm64 -output liba-arm64.a 二、.Framework库合并与拆分.framework库与.a库类似，只是.framework库可以包含Header和Bundle，其实相当于一个目录，所以操作的是里面的库文件，而不是xxx.framework文件 例如有两个不同架构的库 IJKMediaFramework_x86_64.framework IJKMediaFramework_arm64.framework 查看.framework信息 123lipo -info IJKMediaFramework_arm64.framework/IJKMediaFrameworkinput file IJKMediaFramework_arm64.framework/IJKMediaFramework is not a fat fileNon-fat file: IJKMediaFramework_arm64.framework/IJKMediaFramework is architecture: arm64 合并库 1lipo -create IJKMediaFramework_x86_64.framework/IJKMediaFramework IJKMediaFramework_arm64.framework/IJKMediaFramework -output IJKMediaFramework 得到通用的库IJKMediaFramework替换到IJKMediaFramework_x86_64.framework/IJKMediaFramework，这时候IJKMediaFramework_x86_64.framework就是通用framework 抽取出arm64库 1lipo IJKMediaFramework_x86_64.framework/IJKMediaFramework -thin x86_64 -output IJKMediaFramework 三、xcode脚本自动合并库如果是自己生成的库，有个技巧，xcode生成库的时候自动执行脚本完成合并的操作，需要选择真机和模拟器分别编译一遍 在Build Phases添加Run Script 123456789101112131415161718192021222324252627282930# 编译的时候if [ &quot;$&#123;ACTION&#125;&quot; = &quot;build&quot; ]then# 生成通用framework的目录INSTALL_DIR=$&#123;SRCROOT&#125;/Products/$&#123;PRODUCT_NAME&#125;.framework# 需要合并的frameworkDEVICE_DIR=$&#123;BUILD_ROOT&#125;/$&#123;CONFIGURATION&#125;-iphoneos/$&#123;PRODUCT_NAME&#125;.frameworkSIMULATOR_DIR=$&#123;BUILD_ROOT&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator/$&#123;PRODUCT_NAME&#125;.framework# 如果已经存在，则删除if [ -d &quot;$&#123;INSTALL_DIR&#125;&quot; ]thenrm -rf &quot;$&#123;INSTALL_DIR&#125;&quot;fi# 创建目录mkdir -p &quot;$&#123;INSTALL_DIR&#125;&quot;# 拷贝Header到目标目录cp -R &quot;$&#123;DEVICE_DIR&#125;/&quot; &quot;$&#123;INSTALL_DIR&#125;/&quot;# 合并frameworklipo -create &quot;$&#123;DEVICE_DIR&#125;/$&#123;PRODUCT_NAME&#125;&quot; &quot;$&#123;SIMULATOR_DIR&#125;/$&#123;PRODUCT_NAME&#125;&quot; -output &quot;$&#123;INSTALL_DIR&#125;/$&#123;PRODUCT_NAME&#125;&quot;# 编译完成后打开文件夹#open &quot;$&#123;DEVICE_DIR&#125;&quot;open &quot;$&#123;SRCROOT&#125;/Products/$&#123;PRODUCT_NAME&#125;.framework&quot;fi 切换到Release模式，分别切换到模拟器和真机编译一次，编译完成后会自动打开输出文件夹，通过lipo命令查看 完成，接下来可以直接用了合并后的库了","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"}]},{"title":"hexo不生成categories和tags的index页","slug":"hexo-no-generate-categories-tags-index-page","date":"2016-04-28T09:42:44.000Z","updated":"2016-04-28T10:09:15.000Z","comments":true,"path":"2016-04-28/hexo-no-generate-categories-tags-index-page/","link":"","permalink":"http://zhengbomo.github.io/2016-04-28/hexo-no-generate-categories-tags-index-page/","excerpt":"问题使用第三方主题的时候，有时候会遇到hexo不能自动生成/categories/index.html和/tags/index.html页面的问题，导致进入分类或标签主页无法正常显示该页面，如下图","text":"问题使用第三方主题的时候，有时候会遇到hexo不能自动生成/categories/index.html和/tags/index.html页面的问题，导致进入分类或标签主页无法正常显示该页面，如下图 解决通过终端执行 12$ hexo new page categories$ hexo new page tags 会在source文件夹创建两个文件夹categories, tags，并分别创建index.md文件 12345├── source├── categories| ├── index.md└── tags └── index.md 编辑index.md文件 source/categories/index.md 12345---title: 分类type: categoriesdate: 2016-04-28 17:32:38--- source/tags/index.md 12345---title: 标签type: tagsdate: 2016-04-28 17:32:38--- 从新生成就有了 12$ hexo generate$ hexo server","categories":[{"name":"技术","slug":"技术","permalink":"http://zhengbomo.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://zhengbomo.github.io/tags/hexo/"}]},{"title":"ijkplayer编译","slug":"ijkplayer-build","date":"2016-04-20T04:00:58.000Z","updated":"2016-04-20T04:00:58.000Z","comments":true,"path":"2016-04-20/ijkplayer-build/","link":"","permalink":"http://zhengbomo.github.io/2016-04-20/ijkplayer-build/","excerpt":"编译哔哩哔哩开源的ijkplayer iOS版本记录，只是为了更方便使用ijkplayer基于ffmpeg，几乎支持所有视频，音频格式，最低支持到iOS6，在低端机如iphone4，itouch4上测试运行效果良好，搞播放器的同学可以基于这个来做，节省不少时间","text":"编译哔哩哔哩开源的ijkplayer iOS版本记录，只是为了更方便使用ijkplayer基于ffmpeg，几乎支持所有视频，音频格式，最低支持到iOS6，在低端机如iphone4，itouch4上测试运行效果良好，搞播放器的同学可以基于这个来做，节省不少时间 编译前编译前的准备，需要安装homebrew, git, yasm 1234# install homebrew, git, yasmruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;brew install gitbrew install yasm 设置编译脚本使用module-default.sh脚本，默认情况下module.sh指向的是module-lite-hevc.sh 123456cd configrm module.shln -s module-default.sh module.shcd ../iossh compile-ffmpeg.sh clean 编译编译ffmpeg库 12345678910git clone https://github.com/Bilibili/ijkplayer.git ijkplayer-ioscd ijkplayer-iosgit checkout -B latest k0.5.1./init-ios.sh# 这一步会等待一段时间，需要下载ffmpeg源码cd ios./compile-ffmpeg.sh clean./compile-ffmpeg.sh all 接下来是漫长的等待… 编译完成后得到6个lib 1234567├── ios/build/universal/lib| ├── libavcodec.a | ├── libavfilter.a | ├── libavformat.a | ├── libavutil.a | ├── libswresample.a | ├── libswscale.a 编译ijkplayer库打开ios&#x2F;IJKMediaDemo&#x2F;IJKMediaDemo.xcodeproj，编译通过，默认编译为当前architecture（CPU架构）的库，为了方便使用，我们需要framework编译成多架构的库（armv7 i386 x86_64 arm64）我们只需要引用一个文件，就可以在不同的CPU架构使用了 关于库的合并，可以参考这里 编译完成，得到IJKMediaFramework.framework，支持 armv7 i386 x86_64 arm64","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://zhengbomo.github.io/tags/ffmpeg/"}]},{"title":"Mac上让Finder显示隐藏文件","slug":"show-finder-hidden-file","date":"2016-04-20T04:00:58.000Z","updated":"2023-06-11T03:02:51.859Z","comments":true,"path":"2016-04-20/show-finder-hidden-file/","link":"","permalink":"http://zhengbomo.github.io/2016-04-20/show-finder-hidden-file/","excerpt":"在Mac上默认不显示隐藏文件，对于开发人员来说，有时候需要修改一些隐藏文件中的配置，或是删除隐藏文件，在Finder上操作显得特别麻烦，可以在终端用下面命令让Finder的显示&#x2F;不显示隐藏文件","text":"在Mac上默认不显示隐藏文件，对于开发人员来说，有时候需要修改一些隐藏文件中的配置，或是删除隐藏文件，在Finder上操作显得特别麻烦，可以在终端用下面命令让Finder的显示&#x2F;不显示隐藏文件 OSX Mavericks或 OSX Yosemite 系统以上显示隐藏文件 1$ defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder 不显示隐藏文件 1$ defaults write com.apple.finder AppleShowAllFiles -boolean false ; killall Finder OSX Mountain Lion之前显示隐藏文件 1$ defaults write com.apple.finder AppleShowAllFiles TRUE ; killall Finder 不显示隐藏文件 1$ defaults write com.apple.finder AppleShowAllFiles FALSE ; killall Finder","categories":[{"name":"技术","slug":"技术","permalink":"http://zhengbomo.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://zhengbomo.github.io/tags/Mac/"}]},{"title":"git学习笔记","slug":"git-start","date":"2016-04-19T14:21:21.000Z","updated":"2016-05-03T02:56:32.000Z","comments":true,"path":"2016-04-19/git-start/","link":"","permalink":"http://zhengbomo.github.io/2016-04-19/git-start/","excerpt":"使用git很久了，期间踩了一些坑，通常来说对git理解和使用不熟的话踩得坑都是致命的（哭死），所以花了点时间总结了一些用法，加深对git的一些理解","text":"使用git很久了，期间踩了一些坑，通常来说对git理解和使用不熟的话踩得坑都是致命的（哭死），所以花了点时间总结了一些用法，加深对git的一些理解 远程主机remote相当于远程仓库的别名（如ip与域名），git上默认主机名为:origin 查看主机 1234$ git remote$ git remote show$ git remote -v$ git remote show &lt;主机名&gt; 主机操作 123$ git remote add &lt;主机名&gt; &lt;网址&gt;$ git remote rm &lt;主机名&gt;$ git remote rename &lt;原主机名&gt; &lt;新主机名&gt; 通常情况下只需要一个远程主机，有时候我们需要本地代码同事push到两个仓库（如：OSChina和github），这个时候可以配置主机的Url 添加主机的Url，可以添加多个网址 1$ git remote set-url --add &lt;主机名&gt; &lt;网址&gt; 当push到主机的时候会自动同步到添加的网址拉去的时候会直接则取第一个url，修改可以在config(.git/config)文件进行修改 克隆仓库cloneclone是远程操作的第一步，把远程仓库取回到本地 1$ git clone &lt;版本库的网址&gt; &lt;本地目录名&gt; 指定主机名 1$ git clone -o &lt;主机名&gt; &lt;版本库的网址&gt; &lt;本地目录名&gt; 拉取更新fetch当远程仓库有更新的时候，可以通过fetch拉取 1$ git fetch &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 远程分支名缺省，则拉去与本地分支有track关系远程分支拉去后不会merge到当前分支，而是放到一个临时分支上 拉取并合并更新pull1$ git pull &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; push推送更新 1$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 如果分支不存在，则创建如果本地分支名为空，表示删除远程分支 删除远程分支 1$ git push &lt;远程主机名&gt; --delete &lt;远程分支名&gt;:&lt;本地分支名&gt; 只要没有push的改变都只是在本地，包括branch，commit，reset，都可以撤销和删除 比较pull和fetchpull相当于fetch+merge 123456789$ git pull origin Development # 相当于拉取完直接合并到本地分支上$ git fetch origin Development:Development $ git merge origin/Development $ git fetch # 命令相当于创建一个临时分支，用于拉取 $ git fetch origin Development:tmp 分支 Branck1234567891011121314151617181920212223242526# 查看分支(所有)$ git branch -a# 查看本地分支$ git branch# 查看远程分支$ git branch -r# 创建分支（不会自动切换）$ git branch TestBranck# 切换分支$ git checkout TestBranck# 创建并切换$ git checkout -b TestBranck# 推送本地分支到主机$ git push origin TestBranck# 删除分支（本地）$ git branch -d TestBranck# 删除远程分支（本地）$ git push origin :TestBranck 提交 Commit 修改&#x2F;添加文件 test.txt 此时文件没有被跟踪，状态为 Unchecked Files丢弃对文件的添加修改，不带文件则撤销全部工作区的修改（__不可恢复__，慎用） 1$ git checkout -- text.txt 把 test.txt 文件add到当前分支的暂存区，文件状态为 Changed to be commited 1$ git add test.txt 添加文件到暂存区后可以取消暂存（此命令不会影响工作区，如果不带文件则撤销全部） 1$ git reset HEAD test.txt 继续修改文件 test.txt，此时暂存区的文件和工作区的文件不一样了，此时在工作区的副本文件的状态为 Changes not staged for commit 提交test.txt文件 1$ git commit 添加了一个test.txt文件 撤销提交，撤销commit比较麻烦，需要拿到上一次提交的commitId 1$ git reset --hard commit_id 如果是撤销上一次commit，等价于用下面命令 1$ git reset --hard HEAD^ 只有添加到暂存区的文件才能提交，所以我们只提交了第一次修改，第二次修改没有被提交 暂存区的文件都是只读的，不能修改，只有工作区的文件才能修改 问题 发现刚刚commit漏提交了一个文件（或者提交说明写错了），需要修改上一次commit 解决一：此时为push到远程仓库，修正上一个commit，把相关需要补充的文件或修改add到HEAD暂存区（保持commitId不变）1$ git add test.txt执行1$ git commit --amend上面命令会追加暂存区的提交到上一次commit，并重新编辑提交说明 解决二：撤销上一个commit，然后重新commit（新的commitId）撤销上一次提交1$ git reset --hard HEAD^回复到指定的commitid1$ git reset --hard commit_id上面操作不会影响工作区 如果commit已经push到远程 有时候我们在本地修改后并且push到远程，这个时候发现，需要撤销，如果我们使用git reset撤销后push到远程主机 12$ git reset --HARD HEAD^ # 撤销上一次commit$ git push origin master # 这时候push会报错，因为本地的分支比远程的分支落后 上面push会报错，有两种方式解决 使用fast-forward方式推送，直接覆盖远程分支，这种方式有风险，有可能在这之前有其他人的push都会一并被覆盖，慎用1$ git push -f origin master reset换成revert命令，这种方式会新增一个commit，而不是回退，这个时候当前的分支就不会比远程分支落后了，两者区别见后面1234$ git revert head^ # 撤销上一次commit，恢复到AAAA，并生成新的commitId# 这个时候可能会产生冲突，解决冲突，commit$ git push origin master 推荐使用这种方式解决远程恢复的问题 文件操作（添加，修改，删除，重命名）本地对文件的所以修改，都存放在工作区，需要下面命令将修改放到暂存区，才能提交 123$ git add test.txt $ git rm test.txt $ git mv test.txt 通常这些操作都借助GUI工具完成 撤销提交 reset&#x2F;revert保留原来的commit，会退到历史的点，创建新commit并commit 1$ git reset --hard 重置后的修改会被放到暂存区，需要自己commit 1$ git reset --soft mixed为默认参数，重置后的所有修改会被放到工作区 1$ git reset --mixed 注意 12$ git reset --hard 会清空工作区$ git reset --soft 不会清空工作区 在使用之前，尽量保证工作区和暂存区没有文件，避免多重冲突 历史是不可以修改的Reflog git跟踪过的所有的操作都会成为历史，所有的操作都是添加，所以远程的所有操作理论上都是可以恢复的 git能跟踪所有commit, checkout, reset命令，所有这些命令都可以恢复，可以通过reflog查看所有这些操作 1$ git reflog 恢复到指定的SHA 1$ git reset --hard &lt;SHA&gt; 暂存管理Stash 有时候我们对本地修改到一半时，这时候要去拉去远程更新，为了防止冲突，可以把本地的工作现场保存到另一个暂存区，拉去完成后，在恢复当前工作现场。 Stash可以当前工作区和暂存区的所有修改保存起来，暂存区是全局的，不同分支也共享一个Stash，Stash可以存放多个工作现场 保存当前工作现场（保存暂存区的文件，不保存工作区的文件） 1$ git stash 保存当前工作现场（保存暂存区和工作区的文件） 123$ git stash --include-untracked#或者$ git stash -u 注意：暂存工作区文件有风险，当工作区的文件存在冲突的时候，工作区的文件无法恢复，并且无法自动解决冲突，暂存区的文件可以 恢复工作现场 123456#恢复上一个保存的工作现场$ git stash pop#恢复到指定工作现场（并从stash堆中删除）$ git stash pop stash@&#123;num&#125;#恢复到某个工作现场（不从stash堆中删除）$ git stash apply stash@&#123;num&#125; 查看文件状态（暂存区和工作区） 通常我们通过GUI工具查看 1$ git status 取消git版本控制如果一个目录取消git的版本控制，恢复成正常的目录，可以直接把.git目录删了，包含目录下所有文件和该目录本身 1$ rm -rf .git 分歧与Fast-Forward123456789 #1 #2 #3 #4master 〇 ─── 〇 ─────────────── 〇 ─────── 〇 | ↑ ↑ A ├───────── 〇 ────── ↑ | checkout push ↑ | ↑ B └───────── 〇 ──────────── ↑ checkout push A和B都从master分支的的#2checkout代码，假设A对文件README.md做了修改，并push到master，B也对文件README.md做了修改，然后push到master，在默认情况下这个时候就会发生冲突，必须先fetch同步远程最新的代码并merge解决冲突后再提交才能push成功，这是为了防止B的修改直接覆盖A的修改 在默认情况下系统为non-fast-forward，即非快进模式，必须以时间顺序提交，也就是B必须基于#3的代码修改才能提交 解决方法：1、fetch远程代码后merge解决冲突，然后commmit，再push2、忽略冲突，直接覆盖远程代码，可以开启fast-forward模式强制覆盖远程的操作 1$ git push -f 此操作还会覆盖远程的commit记录，尽量少用，fast-forward模式，特别是在多人开发的时候，会覆盖别人的代码，还会覆盖别人的提交，不利于回滚代码 rebase与mergerebase和merge都有合并代码的功能，二者的区别在于 merge合并后会保留两个分支的所有commit rebase合并后会丢弃合并分支的commit 如下两个分支 master：A &lt;- B &lt;- C &lt;- D test: A &lt;- B &lt;- C &lt;- E __Merge__：合并test到master合并之后为：A &lt;- B &lt;- C &lt;- D &lt;- E &lt;- M __Rebase__：合并test到master 合并之后为：A &lt;- B &lt;- C &lt;- D &lt;- R 使用rebase可以减少一些多余的commit，让分支历史基本在一条直线上，有利有弊，看使用场景选择merge或rebase 使用git pull默认使用merge，可以加参数--rebase让其使用rebase合并 1$ git pull --rebase 合并后，当git无法自动解决冲突的时候，查看分支会出现(no branch, rebasing master)，表示不再任何分支上工作 123ACA80164:Test bomo$ git branch* (no branch, rebasing master) master 这个时候手动解决冲突，然后执行add 123$ git add .# 注意，不需要commit$ git rebase --continue 总结 所有commmit和reset操作都是可以恢复的（reflog&#x2F;reset&#x2F;revert） 工作区的文件通常是不可恢复的 checkout是撤销工作区修改，不可恢复，慎用checkout pull之前防止冲突，通常把所有文件放到暂存区（为了防止冲突），然后stash，解决冲突，在stash pop 只有放到暂存区的文件的冲突才能被识别，如果是工作去的冲突，会直接被覆盖 从工作区add文件到暂存区不会识别冲突 所有的commit都可以恢复，建议多commit（提高代码粒度） 所有的操作都是本地的，对远程仓库的操作只有同步操作，如果要修改远程仓库，在本地改完push到服务器","categories":[{"name":"技术","slug":"技术","permalink":"http://zhengbomo.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"git","slug":"git","permalink":"http://zhengbomo.github.io/tags/git/"}]},{"title":"删除远程分支","slug":"delete-remote-branch","date":"2016-04-19T10:08:29.000Z","updated":"2023-06-11T03:02:51.859Z","comments":true,"path":"2016-04-19/delete-remote-branch/","link":"","permalink":"http://zhengbomo.github.io/2016-04-19/delete-remote-branch/","excerpt":"有时候会不消息把本地一些小分支push到远程服务器，删除远程分支与本地不一样，可以通过下面命令删除","text":"有时候会不消息把本地一些小分支push到远程服务器，删除远程分支与本地不一样，可以通过下面命令删除 删除本地分支 1$ git branch -D branch-name 解除远程分支的track关系（本地） 1$ git branch -r -d origin/branch-name 推送空到远程分支 1$ git push origin :branch-name 也可以使用 1$ git push origin --delete master","categories":[{"name":"技术","slug":"技术","permalink":"http://zhengbomo.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"git","slug":"git","permalink":"http://zhengbomo.github.io/tags/git/"}]},{"title":"使用Hexo和github pages搭建博客","slug":"hexo-for-blog","date":"2016-04-18T11:50:26.000Z","updated":"2016-04-18T11:50:26.000Z","comments":true,"path":"2016-04-18/hexo-for-blog/","link":"","permalink":"http://zhengbomo.github.io/2016-04-18/hexo-for-blog/","excerpt":"1. 简介hexo是一个基于node.js的静态博客程序，可以方便的生成静态网页（纯html）支持多个平台（Windows&#x2F;MAC&#x2F;Linux），风格优雅，更适合写技术博客，与hexo类似的博客程序还有jekyll，jekyll被github着力推荐官方就提供了jekyll教程，但是jekyll是基于ruby写的，并且关于代码高亮没找到比较好的方案，就选择了用hexo","text":"1. 简介hexo是一个基于node.js的静态博客程序，可以方便的生成静态网页（纯html）支持多个平台（Windows&#x2F;MAC&#x2F;Linux），风格优雅，更适合写技术博客，与hexo类似的博客程序还有jekyll，jekyll被github着力推荐官方就提供了jekyll教程，但是jekyll是基于ruby写的，并且关于代码高亮没找到比较好的方案，就选择了用hexo 2. 配置环境2.1 安装git作者用的是mac，可以使用brew下面命令安装 1$ brew install git 也可以直接上git官网下载安装 2.2 安装node.js同样的，mac可以使用brew安装，新版的node.js已经包含npm工具，不需要再另外安装了 1$ brew install node 可以通过下面命令检查是否已安装 12$ node -v$ npm -v 如果是windows用户可以通过官网下载 jode.js 2.3 Hexo安装上面的安装完成后，接下来安装hexo 123456npm install hexo-cli -g #-g表示全局安装, npm默认为当前项目安装hexo init blog #在当前目录下新建blog目录初始化博客cd blog #进入blog目录#npm install hexo generate #根据当前配置生成静态页面hexo server #启动本地服务，默认为：[http://localhost:4000/](http://localhost:4000/) 接下来就可以通过http://localhost:4000/查看效果了 3. 配置github pages每个github账户都可以有一个外部空间&#x2F;Responsitory，可以直接通过用户名.github.io访问到该仓库的内容 在github上新增一个responsitory，仓库名为 用户名.github.io 或 用户名.github.com 创建完成后，github会自动将 用户名.github.io指向该仓库，默认访问根目录下的index.html页面 可以进入Responsitory的Setting页查看 github会提供几个模板搭建站点，我们可以不用他提供的模板，可以在仓库里面，添加一个简单的index.html文件，如果能通过用户名.github.com访问，则表明创建成功了 4. 写博客hexo的文章存放在source目录下 123├── source | ├── _posts #存放文章 | └── _drafts #存放草稿 1$ hexo new post &quot;postName&quot; # 在source/_posts 目录下创建postName.md文件 创建文件的命名格式可以在_config.yml文件配置 12# Writingnew_post_name: :year-:month-:day-:title.md 文件创建完成后会自动生成以下格式（可以自己添加） 123456---title: 使用Hexo和github pages搭建博客date: 2016-04-18 19:50:26categories: blog # 分类tags: [blogs, hexo] # 标签，格式：[标签, 标签2]--- 关与写作的各种参数可以参见：https://hexo.io/docs/writing.html 写完后预览的时候发现，文章在首页就全部显示出来了，如果不想全部显示，可以在文章中间添加下面标记，在首页列表就会出现Read More的标记 1&lt;!--more--&gt; Hexo支持使用Markdown语法写文章，我比较习惯用Atom写Markdown，Atom有个hexo插件 5. 主题官方自带主题基本够用，有能力可以自己改造，当然，网上已经有很多人做了一些很好看的主题了，我们可以直接拿来用，下面是官方列出的一些主题，找到喜欢的可以直接用 https://github.com/hexojs/hexo/wiki/Themeshttps://hexo.io/themes 在hexo上，主题放在themes目录下，我们只需要把别人做好的主题clone下来就好了，然后在_config.yml修改一下配置例如：我们可以https://github.com/xiangming/landscape-plus这个主题clone下来 1git clone git@github.com:xiangming/landscape-plus.git themes/landscape-plus 修改设置_config.yml 1theme: landscape-plus 6. 添加多说评论插件到多说官网注册和创建一个站点 修改配置到themes/landscape-plus/_config.yml添加多说的配置，shortname即注册的站点名称 12# Duoshuoduoshuo_shortname: bomo 参见官方说明，替换评论相关的代码http://dev.duoshuo.com/threads/541d3b2b40b5abcd2e4df0e9 完成，如下图评论有了 7. 部署到github上修改配置_config.yml 1234deploy: type: git repository: https://github.com/zhengbomo/zhengbomo.github.io.git branch: master 安装 hexo-deployer-git 1$ npm install hexo-deployer-git --save 部署hexo到git上 1$ hexo deploy 部署过程需要输入账号密码，然后会push到github上，参考：https://hexo.io/docs/deployment.html hexo部署时会把最终生成的博客文件（public目录下的文件）push到git远程仓库，而博客程序还是在本地，当我们切换电脑的时候，无法对博客进行重新编辑和发布，这个时候我们可以在git添加一个分支hexo用来存放博客程序和编写的内容，详情可以参见： git创建分支hexo存放博客程序 8. 域名绑定 通常域名在godaddy注册比较靠谱，这个是最大的域名提供商，而且不需要备案，支持支付宝付款，购买的时候可以使用优惠码会便宜一些，网上有很多优惠码，可以自行搜索，购买过程很简单，这里就不贴了 注册和配置DNS服务器Godaddy自带的域名解析服务器比较慢，在国内推荐使用DNSpod：快，免费，稳定。 到DNSpod注册登陆，然后到用户中心，添加域名，例如我的域名为bomobox.org 进入设置 添加两个A记录指向github提供的ip，参见这里 12192.30.252.153192.30.252.154 添加一个CNAME记录指向自己的github域名：username.github.io把其他的删除 注册域名和配置DNS 到Godaddy购买域名完成后完成后进入MyAccount 进入DNS Manager修改DNS服务器 12f1g1ns1.dnspod.netf1g1ns2.dnspod.net 到github仓库的根目录添加CNAME文件，文件内添加自己的域名，否则会出现404访问错误，也可以在hexo的source目录下添加，然后不熟到github 上面步骤设置完成后可能会有几个小时的延迟，才能生效，总的来说还是比较简单的 9. 问题在使用别人的主题的时候可能会报错或者有些功能用不了，原因可能是部分插件没有安装，例如RSS用不了，那可能是hexo-generator-feed没安装，下面列举一些常用的插件，建议都安装，没有用到也没有关系，需要先到hexo程序目录下在执行命令，插件位于node_modules目录下 123456789$ npm install hexo-generator-feed --save #支持RSS$ npm install hexo-generator-sitemap --save #生成站点地图$ npm install hexo-generator-baidu-sitemap --save #生成百度站点地图$ npm install hexo-html-minifier --save #HTML 压缩$ npm install hexo-uglify --save #JavaScript 压缩$ npm install hexo-clean-css --save #CSS 压缩插件$ npm install hexo-generator-seo-friendly-sitemap --save #SEO优化$ npm install hexo-deployer-git --save #git部署插件 并在博客配置文件_config.yml配置plugin 123Plugins:- hexo-generator-feed- hexo-generator-sitemap 更多插件可以在https://hexo.io/plugins/找到 10. Atom插件由于我编写md使用的是Atom，这里推荐几个Atom上的插件 markdown-scroll-sync：Markdown预览实时滚动，自带的预览不支持实时滚动 markdown-writer：Markdown协作工具 Date：快速插入当前时间的工具 atom-hexo：快速添加draft，post，publish，deploy 11. 总结使用hexo搭建博客环境还是非常方便的，基本上都是自动的，当然还有一些详细的配置，例如分页，分类，评论等，Hexo支持的插件也相当多的，接下来可以好好写博客了，以后再慢慢完善了，今天先到这里 12. 参考链接 https://hexo.io","categories":[{"name":"blog","slug":"blog","permalink":"http://zhengbomo.github.io/categories/blog/"}],"tags":[{"name":"blogs","slug":"blogs","permalink":"http://zhengbomo.github.io/tags/blogs/"},{"name":"hexo","slug":"hexo","permalink":"http://zhengbomo.github.io/tags/hexo/"}]},{"title":"SQLCipher数据库加解密","slug":"sqlcipher-start","date":"2016-04-18T03:23:00.000Z","updated":"2023-06-11T03:02:51.859Z","comments":true,"path":"2016-04-18/sqlcipher-start/","link":"","permalink":"http://zhengbomo.github.io/2016-04-18/sqlcipher-start/","excerpt":"介绍使用SQLite数据库的时候，有时候对于数据库要求比较高，特别是在iOS8.3之前，未越狱的系统也可以通过工具拿到应用程序沙盒里面的文件，这个时候我们就可以考虑对SQLite数据库进行加密，这样就不用担心sqlite文件泄露了","text":"介绍使用SQLite数据库的时候，有时候对于数据库要求比较高，特别是在iOS8.3之前，未越狱的系统也可以通过工具拿到应用程序沙盒里面的文件，这个时候我们就可以考虑对SQLite数据库进行加密，这样就不用担心sqlite文件泄露了 通常数据库加密一般有两种方式 对所有数据进行加密 对数据库文件加密 第一种方式虽然加密了数据，但是并不完全，还是可以通过数据库查看到表结构等信息，并且对于数据库的数据，数据都是分散的，要对所有数据都进行加解密操作会严重影响性能，通常的做法是采取对文件加密的方式 iOS 免费版的sqlite库并不提供了加密的功能，SQLite只提供了加密的接口，但并没有实现，iOS上支持的加密库有下面几种 The SQLite Encryption Extension (SEE) 收费，有以下几种加密方式 RC4AES-128 in OFB modeAES-128 in CCM modeAES-256 in OFB mode SQLiteEncrypt 收费，使用AES加密 SQLiteCrypt 收费，使用256-bit AES加密 SQLCipher 开源，托管在github上，实现了SQLite官方的加密接口，也加了一些新的接口，详情参见这里 前三种都是收费的，SQLCipher是开源的，这里我们使用SQLCipher 集成如果你使用cocoapod的话就不需要自己配置了，为了方便，我们直接使用FMDB进行操作数据库，FMDB也支持SQLCipher pod ‘FMDB&#x2F;SQLCipher’, ‘~&gt; 2.6.2’ 打开加密数据库使用方式与原来的方式一样，只需要数据库open之后调用setKey设置一下秘钥即可下面摘了一段FMDatabase的open函数，在sqlite3_open成功后调用setKey方法设置秘钥 123456789101112131415161718192021- (BOOL)open &#123; if (_db) &#123; return YES; &#125; int err = sqlite3_open([self sqlitePath], &amp;_db ); if(err != SQLITE_OK) &#123; NSLog(@&quot;error opening!: %d&quot;, err); return NO; &#125; else &#123; //数据库open后设置加密key [self setKey:encryptKey_]; &#125; if (_maxBusyRetryTimeInterval &gt; 0.0) &#123; // set the handler [self setMaxBusyRetryTimeInterval:_maxBusyRetryTimeInterval]; &#125; return YES;&#125; 为了不修改FMDB的源代码，我们可以继承自FMDatabase类重写需要setKey的几个方法，这里我继承FMDatabase定义了一个 FMEncryptDatabase 类，提供打开加密文件的功能（具体定义见 Demo ） 123456@interface FMEncryptDatabase : FMDatabase+ (instancetype)databaseWithPath:(NSString*)aPath encryptKey:(NSString *)encryptKey;- (instancetype)initWithPath:(NSString*)aPath encryptKey:(NSString *)encryptKey;@end 用法与FMDatabase一样，只是需要传入secretKey SQLite数据库加解密SQLCipher提供了几个命令用于加解密操作 加密1234$ ./sqlcipher plaintext.db sqlite&gt; ATTACH DATABASE &#x27;encrypted.db&#x27; AS encrypted KEY &#x27;testkey&#x27;; sqlite&gt; SELECT sqlcipher_export(&#x27;encrypted&#x27;); sqlite&gt; DETACH DATABASE encrypted; 打开非加密数据库 创建一个新的加密的数据库附加到原数据库上 导出数据到新数据库上 卸载新数据库 解密12345$ ./sqlcipher encrypted.db sqlite&gt; PRAGMA key = &#x27;testkey&#x27;; sqlite&gt; ATTACH DATABASE &#x27;plaintext.db&#x27; AS plaintext KEY &#x27;&#x27;; -- empty key will disable encryptionsqlite&gt; SELECT sqlcipher_export(&#x27;plaintext&#x27;); sqlite&gt; DETACH DATABASE plaintext; 打开加密数据库 创建一个新的不加密的数据库附加到原数据库上 导出数据到新数据库上 卸载新数据库 代码操作 /** encrypt sqlite database to new file */ + (BOOL)encryptDatabase:(NSString *)sourcePath targetPath:(NSString *)targetPath encryptKey:(NSString *)encryptKey &#123; const char* sqlQ = [[NSString stringWithFormat:@&quot;ATTACH DATABASE &#39;%@&#39; AS encrypted KEY &#39;%@&#39;;&quot;, targetPath, encryptKey] UTF8String]; sqlite3 *unencrypted_DB; if (sqlite3_open([sourcePath UTF8String], &amp;unencrypted_DB) == SQLITE_OK) &#123; char *errmsg; // Attach empty encrypted database to unencrypted database sqlite3_exec(unencrypted_DB, sqlQ, NULL, NULL, &amp;errmsg); if (errmsg) &#123; NSLog(@&quot;%@&quot;, [NSString stringWithUTF8String:errmsg]); sqlite3_close(unencrypted_DB); return NO; &#125; // export database sqlite3_exec(unencrypted_DB, &quot;SELECT sqlcipher_export(&#39;encrypted&#39;);&quot;, NULL, NULL, &amp;errmsg); if (errmsg) &#123; NSLog(@&quot;%@&quot;, [NSString stringWithUTF8String:errmsg]); sqlite3_close(unencrypted_DB); return NO; &#125; // Detach encrypted database sqlite3_exec(unencrypted_DB, &quot;DETACH DATABASE encrypted;&quot;, NULL, NULL, &amp;errmsg); if (errmsg) &#123; NSLog(@&quot;%@&quot;, [NSString stringWithUTF8String:errmsg]); sqlite3_close(unencrypted_DB); return NO; &#125; sqlite3_close(unencrypted_DB); return YES; &#125; else &#123; sqlite3_close(unencrypted_DB); NSAssert1(NO, @&quot;Failed to open database with message &#39;%s&#39;.&quot;, sqlite3_errmsg(unencrypted_DB)); return NO; &#125; &#125; /** decrypt sqlite database to new file */ + (BOOL)unEncryptDatabase:(NSString *)sourcePath targetPath:(NSString *)targetPath encryptKey:(NSString *)encryptKey &#123; const char* sqlQ = [[NSString stringWithFormat:@&quot;ATTACH DATABASE &#39;%@&#39; AS plaintext KEY &#39;&#39;;&quot;, targetPath] UTF8String]; sqlite3 *encrypted_DB; if (sqlite3_open([sourcePath UTF8String], &amp;encrypted_DB) == SQLITE_OK) &#123; char* errmsg; sqlite3_exec(encrypted_DB, [[NSString stringWithFormat:@&quot;PRAGMA key = &#39;%@&#39;;&quot;, encryptKey] UTF8String], NULL, NULL, &amp;errmsg); // Attach empty unencrypted database to encrypted database sqlite3_exec(encrypted_DB, sqlQ, NULL, NULL, &amp;errmsg); if (errmsg) &#123; NSLog(@&quot;%@&quot;, [NSString stringWithUTF8String:errmsg]); sqlite3_close(encrypted_DB); return NO; &#125; // export database sqlite3_exec(encrypted_DB, &quot;SELECT sqlcipher_export(&#39;plaintext&#39;);&quot;, NULL, NULL, &amp;errmsg); if (errmsg) &#123; NSLog(@&quot;%@&quot;, [NSString stringWithUTF8String:errmsg]); sqlite3_close(encrypted_DB); return NO; &#125; // Detach unencrypted database sqlite3_exec(encrypted_DB, &quot;DETACH DATABASE plaintext;&quot;, NULL, NULL, &amp;errmsg); if (errmsg) &#123; NSLog(@&quot;%@&quot;, [NSString stringWithUTF8String:errmsg]); sqlite3_close(encrypted_DB); return NO; &#125; sqlite3_close(encrypted_DB); return YES; &#125; else &#123; sqlite3_close(encrypted_DB); NSAssert1(NO, @&quot;Failed to open database with message &#39;%s&#39;.&quot;, sqlite3_errmsg(encrypted_DB)); return NO; &#125; &#125; /** change secretKey for sqlite database */ + (BOOL)changeKey:(NSString *)dbPath originKey:(NSString *)originKey newKey:(NSString *)newKey &#123; sqlite3 *encrypted_DB; if (sqlite3_open([dbPath UTF8String], &amp;encrypted_DB) == SQLITE_OK) &#123; sqlite3_exec(encrypted_DB, [[NSString stringWithFormat:@&quot;PRAGMA key = &#39;%@&#39;;&quot;, originKey] UTF8String], NULL, NULL, NULL); sqlite3_exec(encrypted_DB, [[NSString stringWithFormat:@&quot;PRAGMA rekey = &#39;%@&#39;;&quot;, newKey] UTF8String], NULL, NULL, NULL); sqlite3_close(encrypted_DB); return YES; &#125; else &#123; sqlite3_close(encrypted_DB); NSAssert1(NO, @&quot;Failed to open database with message &#39;%s&#39;.&quot;, sqlite3_errmsg(encrypted_DB)); return NO; &#125; &#125; 总结SQLCipher使用起来还是很方便的，基本上不需要怎么配置，需要注意的是，尽量不要在操作过程中修改secretKey，否则，可能导致读不了数据，在使用第三方库的时候尽量不去修改源代码，可以通过扩展或继承的方式修改原来的行为，这样第三方库代码可以与官方保持一致，可以跟随官方版本升级，具体代码可以到我的github上下载咯 参考 http://www.cocoachina.com/industry/20140522/8517.html https://www.zetetic.net/sqlcipher/","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"}],"tags":[{"name":"SQLCipher","slug":"SQLCipher","permalink":"http://zhengbomo.github.io/tags/SQLCipher/"},{"name":"SQLite","slug":"SQLite","permalink":"http://zhengbomo.github.io/tags/SQLite/"}]}],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/categories/iOS/"},{"name":"树莓派","slug":"树莓派","permalink":"http://zhengbomo.github.io/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"OpenGL","slug":"OpenGL","permalink":"http://zhengbomo.github.io/categories/OpenGL/"},{"name":"flutter","slug":"flutter","permalink":"http://zhengbomo.github.io/categories/flutter/"},{"name":"Flutter","slug":"Flutter","permalink":"http://zhengbomo.github.io/categories/Flutter/"},{"name":"操作系统","slug":"操作系统","permalink":"http://zhengbomo.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"C++","slug":"C","permalink":"http://zhengbomo.github.io/categories/C/"},{"name":"docker","slug":"docker","permalink":"http://zhengbomo.github.io/categories/docker/"},{"name":"路由器","slug":"路由器","permalink":"http://zhengbomo.github.io/categories/%E8%B7%AF%E7%94%B1%E5%99%A8/"},{"name":"python","slug":"python","permalink":"http://zhengbomo.github.io/categories/python/"},{"name":"技术","slug":"技术","permalink":"http://zhengbomo.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"linux","slug":"linux","permalink":"http://zhengbomo.github.io/categories/linux/"},{"name":"blog","slug":"blog","permalink":"http://zhengbomo.github.io/categories/blog/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhengbomo.github.io/tags/iOS/"},{"name":"树莓派","slug":"树莓派","permalink":"http://zhengbomo.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"OpenGL","slug":"OpenGL","permalink":"http://zhengbomo.github.io/tags/OpenGL/"},{"name":"flutter","slug":"flutter","permalink":"http://zhengbomo.github.io/tags/flutter/"},{"name":"key","slug":"key","permalink":"http://zhengbomo.github.io/tags/key/"},{"name":"Swift","slug":"Swift","permalink":"http://zhengbomo.github.io/tags/Swift/"},{"name":"操作系统","slug":"操作系统","permalink":"http://zhengbomo.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"C++","slug":"C","permalink":"http://zhengbomo.github.io/tags/C/"},{"name":"逆向","slug":"逆向","permalink":"http://zhengbomo.github.io/tags/%E9%80%86%E5%90%91/"},{"name":"docker","slug":"docker","permalink":"http://zhengbomo.github.io/tags/docker/"},{"name":"ARM64","slug":"ARM64","permalink":"http://zhengbomo.github.io/tags/ARM64/"},{"name":"lldb","slug":"lldb","permalink":"http://zhengbomo.github.io/tags/lldb/"},{"name":"Reveal","slug":"Reveal","permalink":"http://zhengbomo.github.io/tags/Reveal/"},{"name":"https","slug":"https","permalink":"http://zhengbomo.github.io/tags/https/"},{"name":"路由器","slug":"路由器","permalink":"http://zhengbomo.github.io/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"},{"name":"frp","slug":"frp","permalink":"http://zhengbomo.github.io/tags/frp/"},{"name":"斐讯","slug":"斐讯","permalink":"http://zhengbomo.github.io/tags/%E6%96%90%E8%AE%AF/"},{"name":"IAP","slug":"IAP","permalink":"http://zhengbomo.github.io/tags/IAP/"},{"name":"block","slug":"block","permalink":"http://zhengbomo.github.io/tags/block/"},{"name":"python","slug":"python","permalink":"http://zhengbomo.github.io/tags/python/"},{"name":"flask","slug":"flask","permalink":"http://zhengbomo.github.io/tags/flask/"},{"name":"crontab","slug":"crontab","permalink":"http://zhengbomo.github.io/tags/crontab/"},{"name":"scrapy","slug":"scrapy","permalink":"http://zhengbomo.github.io/tags/scrapy/"},{"name":"sql","slug":"sql","permalink":"http://zhengbomo.github.io/tags/sql/"},{"name":"pycharm","slug":"pycharm","permalink":"http://zhengbomo.github.io/tags/pycharm/"},{"name":"linux","slug":"linux","permalink":"http://zhengbomo.github.io/tags/linux/"},{"name":"virtualenv","slug":"virtualenv","permalink":"http://zhengbomo.github.io/tags/virtualenv/"},{"name":"mysql","slug":"mysql","permalink":"http://zhengbomo.github.io/tags/mysql/"},{"name":"VPS","slug":"VPS","permalink":"http://zhengbomo.github.io/tags/VPS/"},{"name":"swift","slug":"swift","permalink":"http://zhengbomo.github.io/tags/swift/"},{"name":"爬虫","slug":"爬虫","permalink":"http://zhengbomo.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"编码","slug":"编码","permalink":"http://zhengbomo.github.io/tags/%E7%BC%96%E7%A0%81/"},{"name":"urllib","slug":"urllib","permalink":"http://zhengbomo.github.io/tags/urllib/"},{"name":"sqlite","slug":"sqlite","permalink":"http://zhengbomo.github.io/tags/sqlite/"},{"name":"Python","slug":"Python","permalink":"http://zhengbomo.github.io/tags/Python/"},{"name":"多线程","slug":"多线程","permalink":"http://zhengbomo.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"技术","slug":"技术","permalink":"http://zhengbomo.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"cocoapod","slug":"cocoapod","permalink":"http://zhengbomo.github.io/tags/cocoapod/"},{"name":"hexo","slug":"hexo","permalink":"http://zhengbomo.github.io/tags/hexo/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://zhengbomo.github.io/tags/ffmpeg/"},{"name":"Mac","slug":"Mac","permalink":"http://zhengbomo.github.io/tags/Mac/"},{"name":"git","slug":"git","permalink":"http://zhengbomo.github.io/tags/git/"},{"name":"blogs","slug":"blogs","permalink":"http://zhengbomo.github.io/tags/blogs/"},{"name":"SQLCipher","slug":"SQLCipher","permalink":"http://zhengbomo.github.io/tags/SQLCipher/"},{"name":"SQLite","slug":"SQLite","permalink":"http://zhengbomo.github.io/tags/SQLite/"}]}