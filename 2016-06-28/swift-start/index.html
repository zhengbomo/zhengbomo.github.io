<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhengbomo.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="一直没有时间好好看一下swift，最近复习了一遍语法，这里记录swift学习过程中遇到的一些问题和要点，和Object-C的一些相关特性这里也不做介绍，只记录swift特有的一些特性swift借鉴了很多语言的语法，特别是脚本语言，在swift里，可以看到python语言的一些影子，还有其他编程语言的影子">
<meta property="og:type" content="article">
<meta property="og:title" content="swift学习笔记">
<meta property="og:url" content="http://zhengbomo.github.io/2016-06-28/swift-start/index.html">
<meta property="og:site_name" content="bomo的开发随笔">
<meta property="og:description" content="一直没有时间好好看一下swift，最近复习了一遍语法，这里记录swift学习过程中遇到的一些问题和要点，和Object-C的一些相关特性这里也不做介绍，只记录swift特有的一些特性swift借鉴了很多语言的语法，特别是脚本语言，在swift里，可以看到python语言的一些影子，还有其他编程语言的影子">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2016-06-28T07:00:04.000Z">
<meta property="article:modified_time" content="2016-12-16T07:00:04.000Z">
<meta property="article:author" content="bomo">
<meta property="article:tag" content="swift">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://zhengbomo.github.io/2016-06-28/swift-start/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>swift学习笔记 | bomo的开发随笔</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="bomo的开发随笔" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">bomo的开发随笔</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录工作学习点滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-exclamation-circle fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">45</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">13</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">99</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zhengbomo.github.io/2016-06-28/swift-start/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="懒人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bomo的开发随笔">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          swift学习笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-06-28 15:00:04" itemprop="dateCreated datePublished" datetime="2016-06-28T15:00:04+08:00">2016-06-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2016-12-16 15:00:04" itemprop="dateModified" datetime="2016-12-16T15:00:04+08:00">2016-12-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>一直没有时间好好看一下swift，最近复习了一遍语法，这里记录swift学习过程中遇到的一些问题和要点，和Object-C的一些相关特性这里也不做介绍，只记录swift特有的一些特性<br>swift借鉴了很多语言的语法，特别是脚本语言，在swift里，可以看到python语言的一些影子，还有其他编程语言的影子</p>
<span id="more"></span>

<h2 id="一、基础语法"><a href="#一、基础语法" class="headerlink" title="一、基础语法"></a>一、基础语法</h2><ul>
<li>swift语句结束不需要分号（写了也没有问题），有一种情况需要分号，如果一行代码中有多条语句，这时候就必须要分号隔开</li>
<li>swift字符串，数组语法糖，字典语法糖不需要<code>@</code>标示</li>
<li>swift是类型安全的语言，所有的类型都不会自动转换（如：Int和UInt类型不能直接运算），同事swift具有强大的类型推测，所以很多时候我们不需要声明类型</li>
<li>swift的多行注释支持嵌套<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这是第一个多行注释的开头</span></span><br><span class="line"><span class="comment"><span class="comment">/* 这是第二个被嵌套的多行注释 */</span></span></span><br><span class="line"><span class="comment">这是第一个多行注释的结尾 */</span></span><br></pre></td></tr></table></figure></li>
<li>swift的布尔值使用小写true和false，判断语句只能使用Bool类型</li>
</ul>
<h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><ul>
<li>与objc一样，swift支持以前（objc）使用的所有数据类型，swift的类型名字首字母大写，如Int, Float, NSInteger</li>
<li>swift支持可选类型（Optionals）类型，相当于C#中的可空类型，标识变量可能为空，基础数据类型也可为空，可选类型不能直接赋非可选类型<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a: <span class="type">Int</span>? <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b: <span class="type">Int</span> <span class="operator">=</span> a          <span class="comment">// 报错，不同类型不能赋值</span></span><br></pre></td></tr></table></figure></li>
<li>swift的布尔类型使用<code>true/false</code>，而不用<code>YES/NO</code></li>
<li>swift支持使用<code>_</code>来分割数值来增强可读性而不影响值，如一亿可以表示为下面形式<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oneMillion <span class="operator">=</span> <span class="number">1_000_000</span></span><br></pre></td></tr></table></figure></li>
<li>swift数值类型进行运算符计算的时候不会自动进行类型转换，通常可以通过类型的构造方法进行类型转换<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a: <span class="type">Int</span> <span class="operator">=</span> <span class="number">12</span></span><br><span class="line"><span class="keyword">var</span> b: <span class="type">Float</span> <span class="operator">=</span> <span class="number">23</span></span><br><span class="line"><span class="keyword">var</span> c <span class="operator">=</span> a <span class="operator">+</span> b           <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> d <span class="operator">=</span> <span class="type">Float</span>(a) <span class="operator">+</span> b    <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li>
<li>swift的基础数据类型与对象类型一视同仁，可以混用，不需要装箱和拆箱</li>
</ul>
<h3 id="TODO：Any-AnyObject"><a href="#TODO：Any-AnyObject" class="headerlink" title="TODO：Any, AnyObject,"></a>TODO：Any, AnyObject,</h3><h2 id="三、常量变量"><a href="#三、常量变量" class="headerlink" title="三、常量变量"></a>三、常量变量</h2><ul>
<li>与<code>C/Obj-C</code>不同，swift的常量更为广义，支持__任意类型__，常量只能赋值一次</li>
<li>swift的变量和常量在声明的时候类型就已经确定（由编译器自动识别或开发者指定）</li>
<li>使用let声明的集合为可变集合，使用var声明的集合为不可变集合</li>
<li>如果你的代码中有不需要改变的值，请使用 let 关键字将它声明为常量。只将需要改变的值声明为变量。这样可以尽量数据安全，并且常量是线程安全</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常量：使用let声明，赋值后就不能再修改</span></span><br><span class="line"><span class="keyword">let</span> a <span class="operator">=</span> <span class="type">NSMutableArray</span>()</span><br><span class="line"><span class="keyword">let</span> b <span class="operator">=</span> <span class="number">12</span></span><br><span class="line"><span class="keyword">let</span> c: <span class="type">Float</span> <span class="operator">=</span> <span class="number">12</span>       <span class="comment">// 类型标注(type annotation)</span></span><br><span class="line"><span class="keyword">let</span> d <span class="operator">=</span> b <span class="operator">+</span> <span class="number">12</span></span><br><span class="line">a.addObject(<span class="number">11</span>)         <span class="comment">// str == [11]</span></span><br><span class="line"><span class="keyword">let</span> e <span class="operator">=</span> a               <span class="comment">// str == [11], d == [11]</span></span><br><span class="line">a.addObject(<span class="number">12</span>)         <span class="comment">// str == [11, 12], d == [11, 12]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量：使用var声明</span></span><br><span class="line"><span class="keyword">var</span> f: <span class="type">Double</span>? <span class="operator">=</span> <span class="number">12</span></span><br><span class="line"><span class="keyword">var</span> g <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="类型标注"><a href="#类型标注" class="headerlink" title="类型标注"></a>类型标注</h3><p>在声明变量和常量的时候可以如果可以由编译器自动识别，可以不用制定类型，如下</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a <span class="operator">=</span> <span class="number">12</span>    <span class="comment">//常量a会编译为Int类型</span></span><br><span class="line"><span class="keyword">var</span> b <span class="operator">=</span> <span class="number">1.3</span>   <span class="comment">//变量b会编译为Double类型</span></span><br></pre></td></tr></table></figure>
<p>我们也可以指定类型</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="type">Double</span> <span class="operator">=</span> <span class="number">12</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="type">Float</span> <span class="operator">=</span> <span class="number">1.3</span></span><br></pre></td></tr></table></figure>
<p>可以在一行声明多个变量&#x2F;常量，在最后一个声明类型</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> red, green, blue: <span class="type">UInt</span></span><br></pre></td></tr></table></figure>



<h2 id="四、序列和集合"><a href="#四、序列和集合" class="headerlink" title="四、序列和集合"></a>四、序列和集合</h2><h3 id="1-数组Array"><a href="#1-数组Array" class="headerlink" title="1. 数组Array"></a>1. 数组Array</h3><p>swift的数组可以是有类型的（泛型），存放同类型的数据，如果添加一个错误的类型会报编译错误，默认情况下编译器会自动识别</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 数组的写法为：Array&lt;Int&gt;，也可以简写成[Int]</span></span><br><span class="line"><span class="comment">//2. 数组初始化与NSArray类似，直接用中括号括起来，里面值用逗号隔开</span></span><br><span class="line"><span class="keyword">var</span> array0 <span class="operator">=</span> [<span class="type">Int</span>]()</span><br><span class="line"><span class="keyword">var</span> array1: [<span class="type">Int</span>] <span class="operator">=</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">var</span> array2: <span class="type">Array</span>&lt;<span class="type">Int</span>&gt; <span class="operator">=</span> array1</span><br><span class="line"></span><br><span class="line">array1.append(<span class="number">11</span>)             <span class="comment">// [1, 3, 5, 7, 9, 11]</span></span><br><span class="line">array1.insert(<span class="number">0</span>, atIndex: <span class="number">0</span>)  <span class="comment">// [0, 1, 3, 5, 7, 9, 11]</span></span><br><span class="line">array1.isEmpty                <span class="comment">// False</span></span><br><span class="line">array1.count                  <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 如果初始化时不指定类型，而编译器也不能识别出类型，这时候，会被当成NSArray处理</span></span><br><span class="line"><span class="keyword">var</span> array3 <span class="operator">=</span> []                       <span class="comment">// array3 为 NSArray类型的空数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 如果声明的时候使用不同的类型，编译器会把数组识别为NSObject类型</span></span><br><span class="line"><span class="keyword">var</span> array4 <span class="operator">=</span> [<span class="string">&quot;fdsa&quot;</span>, <span class="number">121</span>]            <span class="comment">// array4 为 Array&lt;NSObject&gt; 类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 集合支持加法运算，相当于NSMutableArray的addObjectsFromArray</span></span><br><span class="line">array1 <span class="operator">+=</span> [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]    <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 使用let声明的数组不可变，不能修改数组array3</span></span><br><span class="line"><span class="keyword">let</span> array5: [<span class="type">Int</span>] <span class="operator">=</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="comment">//array5.append(2)              // 报编译错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 集合使用下标索引，支持区间索引，区间不可越界</span></span><br><span class="line"><span class="keyword">var</span> array6: [<span class="type">Int</span>] <span class="operator">=</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">array6[<span class="number">1</span>] <span class="operator">=</span> <span class="number">4</span>                       <span class="comment">// [1, 3, 5, 7, 9]</span></span><br><span class="line">array6[<span class="number">1</span><span class="operator">...</span><span class="number">3</span>] <span class="operator">=</span> [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]           <span class="comment">// [1, 2, 3, 4, 9]</span></span><br><span class="line">array6[<span class="number">0</span><span class="operator">...</span><span class="number">2</span>] <span class="operator">=</span> array6[<span class="number">1</span><span class="operator">...</span><span class="number">3</span>]       <span class="comment">// [2, 3, 4, 4, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 迭代数组的时候，如果需要索引，可以用enumerate方法</span></span><br><span class="line"><span class="keyword">for</span> (index, value) <span class="keyword">in</span> array4.enumerated() &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-字典Dictionary"><a href="#2-字典Dictionary" class="headerlink" title="2. 字典Dictionary"></a>2. 字典Dictionary</h3><p>与数组类型一样，字典也支持泛型，其键值类型都可以指定或有编译器识别，其中Key的类型，必须是可Hash的，swift中基础数据类型都是可hash的（String、Int、Double和Bool）</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 用法与oc类似，初始化不需要@</span></span><br><span class="line"><span class="keyword">var</span> dict1 <span class="operator">=</span> [<span class="string">&quot;key1&quot;</span>: <span class="number">1</span>, <span class="string">&quot;key2&quot;</span>: <span class="number">2</span>, <span class="string">&quot;key3&quot;</span>: <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 声明方式</span></span><br><span class="line"><span class="keyword">var</span> dict2: <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">Int</span>&gt; <span class="operator">=</span> dict1        <span class="comment">//dict2与dict1不是一个对象</span></span><br><span class="line"><span class="keyword">var</span> dict3: [<span class="type">String</span>: <span class="type">Int</span>] <span class="operator">=</span> dict1                  <span class="comment">//通常采用这种方式声明类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 不声明类型，编译器又无法识别，则为NSDictionary</span></span><br><span class="line"><span class="keyword">var</span> dict4 <span class="operator">=</span> [:]</span><br><span class="line"><span class="keyword">var</span> dict5: [<span class="type">Int</span>: <span class="type">String</span>] <span class="operator">=</span> [:]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 修改或添加键值对</span></span><br><span class="line">dict1[<span class="string">&quot;key3&quot;</span>] <span class="operator">=</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 删除键</span></span><br><span class="line">dict1[<span class="string">&quot;key3&quot;</span>] <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. key不存在不报错，返回可空类型nil</span></span><br><span class="line"><span class="keyword">let</span> value4 <span class="operator">=</span> dict1[<span class="string">&quot;key4&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 字典迭代返回key/value元组，类似python</span></span><br><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> dict1 &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(key)</span> = <span class="subst">\(value)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>数组（Array）或字典（Dictionary），如果声明为变量（var），则为可变，如果为常量（let），则为不可变<br>常量数组或字典编译器会对其进行优化，所以尽量把不可变的数组定义为常量数组</p>
</blockquote>
<h3 id="3-Set"><a href="#3-Set" class="headerlink" title="3. Set"></a>3. Set</h3><p>Set集合用于存放无序不重复的对象，用法与数组类似，重复的项会被忽略</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s: <span class="type">Set</span>&lt;<span class="type">Int</span>&gt; <span class="operator">=</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">7</span>]    <span class="comment">// [1, 3, 4, 5, 6, 7]</span></span><br><span class="line">s.count</span><br><span class="line">s.isEmpty</span><br><span class="line">s.insert(<span class="number">3</span>)</span><br><span class="line">s.remove(<span class="number">3</span>)</span><br><span class="line">s.contains(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>集合操作</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oddDigits: <span class="type">Set</span> <span class="operator">=</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">let</span> evenDigits: <span class="type">Set</span> <span class="operator">=</span> [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"><span class="keyword">let</span> singleDigitPrimeNumbers: <span class="type">Set</span> <span class="operator">=</span> [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//合操作</span></span><br><span class="line">oddDigits.union(evenDigits).sort()                <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//交操作</span></span><br><span class="line">oddDigits.intersection(evenDigits).sorted()       <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//减操作</span></span><br><span class="line">oddDigits.subtracting(singleDigitPrimeNumbers).sorted()           <span class="comment">// [1, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不重叠集合</span></span><br><span class="line">oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted()   <span class="comment">// [1, 2, 9]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用“是否相等”运算符( &#x3D;&#x3D; )来判断两个 合是否包含全部相同的值。</li>
<li>使用 isSubset(of:) 方法来判断一个 合中的值是否也被包含在另外一个 合中。</li>
<li>使用 isSuperset(of:) 方法来判断一个 合中包含另一个 合中所有的值。</li>
<li>使用 isStrictSubset(of:) 或者 isStrictSuperset(of:) 方法来判断一个 合是否是另外一个 合的子 合或 者父 合并且两个 合并不相等。</li>
<li>使用 isDisjoint(with:) 方法来判断两个 合是否不含有相同的值(是否没有交 )</li>
</ul>
<h3 id="4-元组Tuple"><a href="#4-元组Tuple" class="headerlink" title="4. 元组Tuple"></a>4. 元组Tuple</h3><p>与python类似，swift也支持元组，可以很方便的使用元组包装多个值，也使得函数返回多个值变得更加方便，特别是临时组建值得时候</p>
<ul>
<li>支持任意类型</li>
<li>支持同时赋值</li>
<li>支持自定义key，支持索引</li>
<li><strong>元组不是对象，不是<code>AnyObject</code>类型，由于swift是强类型的，所以元组有时不能当做普通的对象使用，例如不能把元组加到数组里面，元组内的所有类型必须是明确的</strong></li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 声明一个元组，元组支持任意类型</span></span><br><span class="line"><span class="keyword">let</span> httpError1 <span class="operator">=</span> (<span class="number">404</span>, <span class="string">&quot;Not Found&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> point <span class="operator">=</span> (<span class="number">100</span>, <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 可以分别赋值</span></span><br><span class="line"><span class="keyword">let</span> (x, y) <span class="operator">=</span> point</span><br><span class="line"><span class="built_in">print</span>(x)      <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">print</span>(y)      <span class="comment">// 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用下标取元组元素，下标从0开始</span></span><br><span class="line"><span class="built_in">print</span>(httpError1.<span class="number">0</span>)      <span class="comment">// 404</span></span><br><span class="line"><span class="built_in">print</span>(httpError1.<span class="number">1</span>)      <span class="comment">// Not Found</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 可以给数组元素取名</span></span><br><span class="line"><span class="keyword">let</span> httpError2 <span class="operator">=</span> (code: <span class="number">404</span>, errorMessage: <span class="string">&quot;Not Found&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(httpError2.code)               <span class="comment">// 404</span></span><br><span class="line"><span class="built_in">print</span>(httpError2.errorMessage)       <span class="comment">// Not Found</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 可以用下划线表示忽略部分值</span></span><br><span class="line"><span class="keyword">let</span> (a, <span class="keyword">_</span>) <span class="operator">=</span> point</span><br></pre></td></tr></table></figure>
<blockquote>
<p>元组在临时组织值得时候很有用，可以不用重新定义数据结构</p>
</blockquote>
<h3 id="5-字符串String"><a href="#5-字符串String" class="headerlink" title="5. 字符串String"></a>5. 字符串String</h3><p>swift字符串是由Character字符组成的集合，支持<code>+</code>操作符，可以与NSString无缝桥接，swift的字符串完全兼容unicode<br>字符串与值类型（与Int, Float）一样，是值类型，在传值的时候都会进行拷贝，当然这回带来一定的性能损耗，<em>swift编译器在编译的时候会进行优化，保证只在必要的情况下才进行拷贝</em></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 与NSString不同，声明不需要@前缀，支持转移字符</span></span><br><span class="line"><span class="keyword">let</span> name1 <span class="operator">=</span> <span class="string">&quot;bomo<span class="subst">\n</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 空串（下面两种方式等价）</span></span><br><span class="line"><span class="keyword">let</span> name2 <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">let</span> name3 <span class="operator">=</span> <span class="type">String</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 字符串由字符Character组成，定义字符</span></span><br><span class="line"><span class="keyword">let</span> character1: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 常见属性，方法</span></span><br><span class="line">name1.isEmpty                   <span class="comment">// 判空</span></span><br><span class="line">name1.characters.count          <span class="comment">// 获取字符串的字符数</span></span><br><span class="line">name1.uppercaseString</span><br><span class="line">name1.lowercaseString</span><br><span class="line">name1.hasPrefix(<span class="string">&quot;bo&quot;</span>)</span><br><span class="line">name1.hasSuffix(<span class="string">&quot;mo&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 加法运算</span></span><br><span class="line"><span class="keyword">let</span> hello <span class="operator">=</span> <span class="string">&quot;hello &quot;</span> <span class="operator">+</span> name1   <span class="comment">// hello bomo\n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 比较（比较值，而不是地址）</span></span><br><span class="line"><span class="keyword">let</span> name4 <span class="operator">=</span> <span class="string">&quot;b&quot;</span> <span class="operator">+</span> <span class="string">&quot;omo<span class="subst">\n</span>&quot;</span></span><br><span class="line">name4 <span class="operator">==</span> name1                 <span class="comment">// True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 字符串插值（使用反斜杠和括号站位）</span></span><br><span class="line"><span class="keyword">let</span> city <span class="operator">=</span> <span class="string">&quot;广州&quot;</span></span><br><span class="line"><span class="keyword">let</span> hello2 <span class="operator">=</span> <span class="string">&quot;I&#x27;m <span class="subst">\(name1)</span> from <span class="subst">\(city)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 格式化字符串</span></span><br><span class="line"><span class="keyword">let</span> f <span class="operator">=</span> <span class="number">123.3233</span></span><br><span class="line"><span class="keyword">var</span> s <span class="operator">=</span> <span class="type">String</span>(format: <span class="string">&quot;%.2f&quot;</span>, f)     <span class="comment">//123.32</span></span><br></pre></td></tr></table></figure>


<h3 id="6-集合的赋值和拷贝行为"><a href="#6-集合的赋值和拷贝行为" class="headerlink" title="6. 集合的赋值和拷贝行为"></a>6. 集合的赋值和拷贝行为</h3><p>swift的集合通常有Array和Dictionary，他们在赋值或传递的时候，行为上有所不同，字典类型Dictionary或数组类型Array在赋值给变量或常量的时候，只要有做修改，就会进行值拷贝，并且不会作用到原来变量上</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dict1 <span class="operator">=</span> [<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>]</span><br><span class="line"><span class="keyword">var</span> dict2 <span class="operator">=</span> dict1</span><br><span class="line"><span class="built_in">print</span>(dict1 <span class="operator">==</span> dict2)         <span class="comment">// true</span></span><br><span class="line">dict2[<span class="string">&quot;a&quot;</span>] <span class="operator">=</span> <span class="number">3</span>                <span class="comment">// 修改dict2</span></span><br><span class="line"><span class="built_in">print</span>(dict1 <span class="operator">==</span> dict2)         <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1 <span class="operator">=</span> [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>]</span><br><span class="line"><span class="keyword">var</span> arr2 <span class="operator">=</span> arr1</span><br><span class="line"><span class="built_in">print</span>(arr1 <span class="operator">==</span> arr2)           <span class="comment">// true</span></span><br><span class="line">arr1[<span class="number">0</span>] <span class="operator">=</span> <span class="string">&quot;c&quot;</span>                 <span class="comment">// 修改arr1</span></span><br><span class="line"><span class="comment">// arr1.append(&quot;c&quot;)</span></span><br><span class="line"><span class="built_in">print</span>(arr1 <span class="operator">==</span> arr2)           <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>当数组或字典作为参数传递给函数的时候，由于在Swift3中不推荐使用变量参数，故所有函数参数不可变，故也不进行拷贝</p>
<h2 id="五、可选类型（可空类型）"><a href="#五、可选类型（可空类型）" class="headerlink" title="五、可选类型（可空类型）"></a>五、可选类型（可空类型）</h2><p>swift加入了可空类型让我们使用数据的时候更为安全，我们需要在可空的地方使用可选类型声明该变量可为空，不能给非可选类型设值<code>nil</code>值，在使用的时候可以明确的知道对象是否可能为nil，有点像ObjC的对象，对象可以为nil，也可以不为nil，而swift得可选类型范围更广可以作用于任何类型（基础类型，类，结构体，枚举）</p>
<h3 id="1-声明"><a href="#1-声明" class="headerlink" title="1. 声明"></a>1. 声明</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 声明可选类型，在类型后面加上?</span></span><br><span class="line"><span class="keyword">var</span> obj1: <span class="type">NSObject</span>?</span><br><span class="line">obj1 <span class="operator">=</span> <span class="type">NSObject</span>()</span><br><span class="line">obj1 <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 不能给一个可选类型赋nil，下面会报错，</span></span><br><span class="line"><span class="keyword">var</span> obj <span class="operator">=</span> <span class="type">NSObject</span>()</span><br><span class="line">obj <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 如果声明可选变量时没有赋值，则默认为nil</span></span><br><span class="line"><span class="keyword">var</span> i: <span class="type">Int</span>?</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 一个函数返回一个可选类型</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">getdog</span>() -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;wangcai&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 不能把可选类型赋值给非可选类型，下面会报错</span></span><br><span class="line"><span class="keyword">let</span> cat: <span class="type">String</span> <span class="operator">=</span> dog</span><br></pre></td></tr></table></figure>

<h3 id="2-强制解析"><a href="#2-强制解析" class="headerlink" title="2. 强制解析"></a>2. 强制解析</h3><p>可选类型不能直接使用，需要通过取值操作符<code>!</code>取得变量的值，才能使用，如果变量有值，则返回该值，如果变量为空，则会运行时错误</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b: <span class="type">Int</span>?</span><br><span class="line"><span class="keyword">var</span> a: <span class="type">Int</span></span><br><span class="line">a <span class="operator">=</span> <span class="number">12</span></span><br><span class="line">b <span class="operator">=</span> <span class="number">13</span></span><br><span class="line"><span class="keyword">let</span> c <span class="operator">=</span> a <span class="operator">+</span> b<span class="operator">!</span>              <span class="comment">// 先对b取值，再运算</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b: <span class="type">Bool</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> b<span class="operator">!</span> &#123;                     <span class="comment">// b为空，编译不报错，运行时报错</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;true&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;false&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-可选绑定"><a href="#3-可选绑定" class="headerlink" title="3. 可选绑定"></a>3. 可选绑定</h3><p>使用可选绑定可以判断一个可选类型是否有值，如果有值，则绑定到变量上，如果没有值，返回false，使用<code>if-let</code>组合实现</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i: <span class="type">Int</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> number <span class="operator">=</span> i &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(number)</span>&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;nil&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可选绑定还支持绑定条件</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i: <span class="type">Int</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> number <span class="operator">=</span> i <span class="keyword">where</span> i <span class="operator">&gt;</span> <span class="number">10</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i不为空且大于10 <span class="subst">\(number)</span>&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;nil&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可选绑定还支持多个绑定，不许所有的绑定都满足才返回true</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstNumber <span class="operator">=</span> <span class="number">1</span>, <span class="keyword">let</span> secondNumber <span class="operator">=</span> <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 &quot;4 &lt; 42 &lt; 100&quot;</span></span><br><span class="line"> <span class="keyword">if</span> <span class="keyword">let</span> firstNumber <span class="operator">=</span> <span class="type">Int</span>(<span class="string">&quot;4&quot;</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">let</span> secondNumber <span class="operator">=</span> <span class="type">Int</span>(<span class="string">&quot;42&quot;</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> firstNumber <span class="operator">&lt;</span> secondNumber <span class="operator">&amp;&amp;</span> secondNumber <span class="operator">&lt;</span> <span class="number">100</span> &#123;</span><br><span class="line">             <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(firstNumber)</span> &lt; <span class="subst">\(secondNumber)</span> &lt; 100&quot;</span>)</span><br><span class="line">&#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-隐式解析"><a href="#4-隐式解析" class="headerlink" title="4. 隐式解析"></a>4. 隐式解析</h3><p>声明类型的时候可以使用隐式解析，即在使用可选变量的时候自动取值，不需要调用<code>!</code>操作符，</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个函数返回一个可选类型</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">getdog</span>() -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;wangcai&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假定我们通过getdog方法返回的值一定不为空</span></span><br><span class="line"><span class="keyword">var</span> dog: <span class="type">String</span>? <span class="operator">=</span> getdog()</span><br><span class="line"><span class="keyword">let</span> cat: <span class="type">String</span> <span class="operator">=</span> dog<span class="operator">!</span>          <span class="comment">// 使用前需要通过!强制取值</span></span><br></pre></td></tr></table></figure>
<p>使用dog的时候都需要取值我们觉得太麻烦了，可以声明成隐式可选类型，使用的时候自动取值</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dog: <span class="type">String</span>! <span class="operator">=</span> getdog()     <span class="comment">// 实际上dog还是可选类型，只是使用的时候回自动取值</span></span><br><span class="line"><span class="keyword">let</span> cat: <span class="type">String</span> <span class="operator">=</span> dog           <span class="comment">// 在使用dog的时候会自动进行取值，不需要取值操作符</span></span><br></pre></td></tr></table></figure>

<h3 id="5-可选类型自判断链接"><a href="#5-可选类型自判断链接" class="headerlink" title="5. 可选类型自判断链接"></a>5. 可选类型自判断链接</h3><p>在使用可选类型之前，需要进行判断其是否有值，才能使用，通过<code>!</code>操作符取值后使用（保证有值的情况下），或通过<code>if-let</code>可选绑定的方式，swift提供了一种类似C#语言的语法糖可以让代码更为简洁，可以自动判断值，如果有值，则操作，无值则不操作，并返回nil，在使用前加上<code>?</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> favDog: <span class="type">Dog</span>?</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p <span class="operator">=</span> <span class="type">Person</span>()</span><br><span class="line"><span class="keyword">var</span> d <span class="operator">=</span> <span class="type">Dog</span>()</span><br><span class="line"><span class="comment">// p.favDog = d</span></span><br><span class="line">p.favDog<span class="operator">?</span>.name <span class="operator">=</span> <span class="string">&quot;tobi&quot;</span>   <span class="comment">// 如果p.favDog为空，不设置name</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> name <span class="operator">=</span> p.favDog<span class="operator">?</span>.name &#123;</span><br><span class="line">    <span class="comment">// p.favDog不为空且p.favDog.name不为空</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// p.favDog为空或p.favDog.name为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自判断链接还支持多连接如</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> identifier <span class="operator">=</span> john.residence<span class="operator">?</span>.address<span class="operator">?</span>.buildingIdentifier</span><br></pre></td></tr></table></figure>

<h3 id="6-可选关联运算符"><a href="#6-可选关联运算符" class="headerlink" title="6. 可选关联运算符"></a>6. 可选关联运算符</h3><p>可选关联运算符可对可选类型进行拆包，如果可选类型对象为nil，返回第二个操作数，第二个操作数类型必须和第一个操作数同类型（可选或不可选）</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> defaultColorName <span class="operator">=</span> <span class="string">&quot;red&quot;</span></span><br><span class="line"><span class="keyword">var</span> userDefinedColorName: <span class="type">String</span>?   <span class="comment">// defaults to nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colorNameToUse <span class="operator">=</span> userDefinedColorName <span class="operator">??</span> defaultColorName</span><br></pre></td></tr></table></figure>
<ul>
<li>defaultColorName和userDefinedColorName必须是同类型（String或String?）</li>
<li>如果userDefinedColorName不为空，返回其值，如果userDefinedColorName为空，返回defaultColorName</li>
<li>返回值colorNameToUse的类型同<code>??</code>的第二个操作数的类型，为<code>String</code></li>
</ul>
<h2 id="六、运算符"><a href="#六、运算符" class="headerlink" title="六、运算符"></a>六、运算符</h2><p>swift运算符在原有的基础上做了一些改进，还添加了一下更高级的用法，还有新的运算符</p>
<ul>
<li><p><code>=</code>运算符不返回值</p>
</li>
<li><p>符合运算符<code>+=</code>, <code>-=</code>等不返回值</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面语句会报错</span></span><br><span class="line"><span class="keyword">let</span> b <span class="operator">=</span> a <span class="operator">*=</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li><p>比较运算符可以用于元组的比较（逐个比较，如果遇到不等的元素，则返回，默认最多只能比较7个元素的元组，超过则需要自定义）</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="string">&quot;zebra&quot;</span>) <span class="operator">&lt;</span> (<span class="number">2</span>, <span class="string">&quot;apple&quot;</span>)     <span class="comment">// true，因为 1 小于 2</span></span><br></pre></td></tr></table></figure></li>
<li><p>字符串String，字符Character支持<code>+</code>运算符</p>
</li>
<li><p>浮点数支持<code>%</code>求余运算</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> <span class="operator">%</span> <span class="number">2.5</span> <span class="comment">// 等于 0.5</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>++/--</code>运算在swift3被抛弃，用<code>+=/-=</code>代替</p>
</li>
<li><p>支持溢出运算符（<code>&amp;+</code>, <code>&amp;-</code>, <code>&amp;*</code>），可以在溢出时进行(高位)截断</p>
</li>
<li><p>支持位运算符（<code>&gt;&gt;</code>, <code>&lt;&lt;</code>）</p>
</li>
<li><p>支持三目运算符（<code>a ? b : c</code>）</p>
</li>
<li><p>支持逻辑运算符（<code>&amp;&amp;</code>, <code>||</code>, <code>!</code>）</p>
</li>
<li><p>与其他高级语言类似，swift运算符支持重载，可以为类添加自定义的运算符逻辑，后面会讲到</p>
</li>
<li><p><code>!=</code>, <code>==</code>, <code>===</code>, <code>!==</code>（恒等于&#x2F;不恒等于）<br><code>===</code>：这两个操作符用于引用类型，用于判断两个对象是否指向同一地址<br><code>!===</code>：与<code>===</code>相反，表示两个变量&#x2F;常量指向的的地址不同<br><code>==</code>：表示两个对象逻辑相等，可以通过重载运算符实现相等的逻辑，两个值相等的对象可以是不同地址的对象<br><code>!=</code>：与<code>==</code>相反，表示两个对象逻辑不等</p>
</li>
<li><p>区间运算符<br>  可以使用<code>a...b</code>表示一个范围，有点类似于Python的<code>range(a, b)</code></p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(i)          <span class="comment">// 1, 2, 3, 4, 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <code>a...b</code>: 从a到b并包含a和b<br>  <code>a..&lt;b</code>: 包含a不包含b</p>
<blockquote>
<p><code>a..b</code>表示半闭区间的用法已经被放弃</p>
</blockquote>
<p>  范围运算符也可以作用于字符串<br>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> az <span class="operator">=</span> <span class="string">&quot;a&quot;</span><span class="operator">...</span><span class="string">&quot;z&quot;</span>      <span class="comment">// 返回的是CloseInteval或HalfOpenInterval</span></span><br><span class="line">az.contains(<span class="string">&quot;e&quot;</span>)        <span class="comment">// True</span></span><br></pre></td></tr></table></figure></p>
</li>
<li><p>空合运算符<code>??</code>（与C#类似）<br>  对于可选类型取值，如果不为空则返回该值，如果为空则去第二个操作数</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> a <span class="operator">??</span> b</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="七、流程控制"><a href="#七、流程控制" class="headerlink" title="七、流程控制"></a>七、流程控制</h2><p>swift使用三种语句控制流程：<code>for-in</code>、<code>for</code>、<code>switch-case</code>、<code>while</code>和<code>repeat-while</code>，且判断条件的括号可以省略</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names <span class="operator">=</span> [<span class="string">&quot;Anna&quot;</span>, <span class="string">&quot;Alex&quot;</span>, <span class="string">&quot;Brian&quot;</span>, <span class="string">&quot;Jack&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, <span class="subst">\(name)</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不需要使用到迭代的值，使用下划线`_`忽略该值</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">10</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>流程控制语句的条件返回值必须是Bool，下面会报错</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dd: <span class="type">Bool</span>? <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> dd &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;fd&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>条件判断可以与<code>let</code>结合使用，当值为nil时，视为false（即：<code>可选绑定</code>）</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dd: <span class="type">Bool</span>? <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> ee <span class="operator">=</span> dd &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;fd&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Swift2.0以后，不支持<code>do-while</code>语句，使用<code>repeat-while</code>代替，用法与<code>do-while</code>一样</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeat</span> &#123;  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;repeat while : <span class="subst">\(j)</span>&quot;</span>)  </span><br><span class="line">    j<span class="operator">++</span>  </span><br><span class="line">&#125; <span class="keyword">while</span> j <span class="operator">&lt;</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="guard-else"><a href="#guard-else" class="headerlink" title="guard-else"></a>guard-else</h3><p>翻译为保镖模式，在执行操作前，进行检查，如果不符合，则拦截，使用方式与if有些类似，如果与let结合使用，可以对可选类型解包，先看看普通的<code>if-else</code>模式</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">test</span>(<span class="params">i</span>: <span class="type">Int</span>?) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> i <span class="operator">=</span> i <span class="keyword">where</span> i <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 符合条件的处理</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不符合条件的处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的处理把条件放在了条件判断内部，使用guard与之相反，把正确的情况放在最外部，而异常情况放在条件判断内部</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">test</span>(<span class="params">i</span>: <span class="type">Int</span>?) &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> i <span class="operator">=</span> i <span class="keyword">where</span> i <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里拦截，处理不符合条件的情况</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 符合条件的处理，这个时候已经对i进行了拆包，i是非可选类型，可以直接使用</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保镖模式可以避免代码中过多的流程判断代码导致过多的代码块嵌套，增强可读性</p>
<blockquote>
<p>保镖模式<code>guard-else</code>内的代码块必须包含<code>break</code>, <code>return</code>等跳出代码块的关键字</p>
</blockquote>
<h3 id="switch-case"><a href="#switch-case" class="headerlink" title="switch-case"></a>switch-case</h3><ul>
<li>switch语句支持更多数据类型（String，Int, Float, 元组, 枚举），理论上switch支持任意类型的对象（需要实现<code>~=</code>方法或<code>Equatable</code>协议，详情参见<a target="_blank" rel="noopener" href="http://www.jianshu.com/p/ff660a3e3d8a">这里</a>）</li>
<li>case可以带多个值，用逗号隔开</li>
<li>case可以支持区间（<code>a...b</code>），支持元组，区间可以嵌套在元组内使用</li>
<li>case多条语句不需要用大括号包起来</li>
<li>case语句不需要break，除了空语句，如果需要执行下面的case，可以使用<code>fallthrough</code></li>
<li>如果case不能命中所有的情况，必须要<code>default</code>，如Int，String类型，否则编译会失败</li>
<li>可以用<code>fallthrough</code>关键字声明接着执行下一条case语句，注意，如果case语句有赋值语句（<code>let</code>），则<code>fallthrough</code>无效</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">HttpStatus</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">ServerError</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">NetworkError</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Success</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Redirect</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> status <span class="operator">=</span> <span class="type">HttpStatus</span>.<span class="type">Redirect</span></span><br><span class="line"><span class="keyword">switch</span> status &#123;</span><br><span class="line"><span class="comment">// case可以接收多个值</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">HttpStatus</span>.<span class="type">ServerError</span>, <span class="type">HttpStatus</span>.<span class="type">NetworkError</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">    <span class="comment">// case语句结束显式写break，除非是空语句</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> .<span class="type">Redirect</span>:             <span class="comment">// 如果编译器可以识别出枚举类型，可以省略枚举名</span></span><br><span class="line">    print (<span class="string">&quot;redirect&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span>             <span class="comment">// 像C语言一样，继续执行下一条case</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">HttpStatus</span>.<span class="type">Success</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//元组，区间</span></span><br><span class="line"><span class="keyword">let</span> request <span class="operator">=</span> (<span class="number">0</span>, <span class="string">&quot;https://baidu.com&quot;</span>)</span><br><span class="line"><span class="keyword">switch</span> request &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="keyword">let</span> a):                  <span class="comment">// 支持绑定</span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (a, b) <span class="keyword">where</span> a <span class="operator">==</span> <span class="number">1</span>:      <span class="comment">// 绑定可以卸载元组外面，支持where判断</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;cancel <span class="subst">\(b)</span>&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="number">2</span><span class="operator">...</span><span class="number">10</span>, <span class="keyword">_</span>):                 <span class="comment">// 支持区间，支持忽略值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;error&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;unknown&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// case可以与where进行进一步判断</span></span><br><span class="line"><span class="keyword">let</span> request2 <span class="operator">=</span> (<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">switch</span> request2 &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="keyword">let</span> y) <span class="keyword">where</span> y <span class="operator">&lt;</span> <span class="number">5</span>:</span><br><span class="line"><span class="string">&quot;success&quot;</span>   <span class="comment">//被输出</span></span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="keyword">let</span> y) <span class="keyword">where</span> y <span class="operator">&gt;=</span> <span class="number">5</span>:</span><br><span class="line"><span class="string">&quot;error&quot;</span>   <span class="comment">//被输出</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="string">&quot;unknown&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>case除了和swift一起使用外，还支持与if语句结合使用，用法与switch一样</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bb <span class="operator">=</span> (<span class="number">12</span>, <span class="string">&quot;bomo&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> (<span class="number">1</span><span class="operator">...</span><span class="number">20</span>, <span class="keyword">let</span> cc) <span class="operator">=</span> bb <span class="keyword">where</span> cc <span class="operator">==</span> <span class="string">&quot;bomo&quot;</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(cc)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;nil&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="带标签的语句"><a href="#带标签的语句" class="headerlink" title="带标签的语句"></a>带标签的语句</h3><p>如果有多层嵌套的情况下，有时候我们需要在某处直接退出多层循环，在objc下并没有比较好的方式实现，需要添加退出标识，然后一层一层退出，而在swift可以很方便的退出多层循环，首先需要使用标签标识不通的循环体，形式如下</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">labelName : <span class="keyword">while</span> condition &#123; statements &#125;</span><br></pre></td></tr></table></figure>

<p>看下面例子</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">outerLoop1 : <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">10</span> &#123;</span><br><span class="line">    outerLoop2 : <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">10</span> &#123;</span><br><span class="line">        outerLoop3 : <span class="keyword">for</span> k <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> j <span class="operator">&gt;</span> <span class="number">5</span> &#123;</span><br><span class="line">                <span class="comment">// 1. 跳出一层循环（默认）继续outerLoop2的循环</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 跳出两层循环，继续outerLoop1的循环</span></span><br><span class="line">                <span class="comment">// break outerLoop2</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3. 跳出三层循环，退出整个循环，继续后面的语句</span></span><br><span class="line">                <span class="comment">// break outerLoop1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八、函数"><a href="#八、函数" class="headerlink" title="八、函数"></a>八、函数</h2><h3 id="1-基本形式"><a href="#1-基本形式" class="headerlink" title="1. 基本形式"></a>1. 基本形式</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有返回值</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">函数名</span>(<span class="params">参数名1</span>:参数类型<span class="number">1</span>, <span class="params">参数名2</span>:参数类型<span class="number">2</span>) -&gt; 返回值类型 &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多个返回值（元组）</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">getPoint</span>() -&gt; (x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p <span class="operator">=</span> getPoint()</span><br><span class="line">p.x</span><br><span class="line"></span><br><span class="line"><span class="comment">//无参数无返回值</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">sayHello</span>() &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//egg</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">add</span>(<span class="params">a</span>: <span class="type">Int</span>, <span class="params">b</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">+</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">add(<span class="number">12</span>, b: <span class="number">232</span>)</span><br></pre></td></tr></table></figure>
<p>函数调用除了第一个参数，后面所有的参数必须带上参数名（符合Objc的函数命名规则）如果是调用构造器，第一个参数也需要显示声明</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">sayHello</span>(<span class="params">msg</span>: <span class="type">String</span>, <span class="params">count</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span>count &#123;</span><br><span class="line">            print (msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a <span class="operator">=</span> <span class="type">A</span>(name: <span class="string">&quot;bomo&quot;</span>)               <span class="comment">// 构造器所有参数都必须显示声明参数名</span></span><br><span class="line">a.sayHello(<span class="string">&quot;hello&quot;</span>, count: <span class="number">2</span>)         <span class="comment">// 函数参数除了第一个其他都需要显示声明参数名</span></span><br></pre></td></tr></table></figure>

<h3 id="2-可变参数"><a href="#2-可变参数" class="headerlink" title="2. 可变参数"></a>2. 可变参数</h3><p>可变参数只能作为最后一个参数，一个方法最多只有一个可变参数</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sum</span>(<span class="params">numbers</span>: <span class="type">Int</span>...) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        sum <span class="operator">+=</span> number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-外部参数名"><a href="#3-外部参数名" class="headerlink" title="3. 外部参数名"></a>3. 外部参数名</h3><p>默认情况下，如果不指定外部参数名，swift编译器会自动为函数参数声明与内部参数名同名的外部参数名（格式为：<code>外部参数名 内部参数名: 类型名</code>）</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认情况下，外部参数名与内部参数名一样</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">add</span>(<span class="params">first</span> <span class="params">a</span>: <span class="type">Int</span>, <span class="params">second</span> <span class="params">b</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">+</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">add(first: <span class="number">10</span>, second: <span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<p>如果函数在第一个参数定义外部参数名，必须显示指定，当然我们还可以通过下划线<code>_</code>让函数忽略参数名</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">add</span>(<span class="params">a</span>: <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">+</span> b</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="4-函数默认值"><a href="#4-函数默认值" class="headerlink" title="4. 函数默认值"></a>4. 函数默认值</h3><p>函数还支持声明默认值，（格式为：<code>外部参数名 内部参数名: 类型名 = 默认值</code>）</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">log</span>(<span class="params">msg</span>: <span class="type">String</span>, <span class="params">isDebug</span>: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> isDebug &#123;</span><br><span class="line">        <span class="built_in">print</span>(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">log(<span class="string">&quot;fail&quot;</span>)</span><br><span class="line">log(<span class="string">&quot;success&quot;</span>, isDebug: <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>如果使用默认值并且默认值不是出现在最后，那调用的时候必须写全所有参数</p>
<blockquote>
<p>建议把默认参数放到最后面，这样可以确保非默认参数的赋值顺序，减少参数混乱的情况</p>
</blockquote>
<h3 id="5-闭包"><a href="#5-闭包" class="headerlink" title="5. 闭包"></a>5. 闭包</h3><ul>
<li>函数作为变量</li>
<li>函数作为函数参数</li>
<li>函数作为函数返回值</li>
<li>闭包函数声明<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">add</span>(<span class="params">a</span>: <span class="type">Int</span>, <span class="params">b</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">+</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数作为变量，函数hello赋给somefunc，并调用</span></span><br><span class="line"><span class="keyword">let</span> somefunc: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="operator">=</span> add</span><br><span class="line">somefunc(<span class="number">10</span>, <span class="number">20</span>)      <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数作为参数</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">logAdd</span>(<span class="params">a</span>:<span class="type">Int</span>, <span class="params">b</span>:<span class="type">Int</span>, <span class="params">function</span>: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="comment">// 函数内容</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;begin&quot;</span>)</span><br><span class="line">    function(a, b)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">logAdd(<span class="number">12</span>, b: <span class="number">23</span>, function: add)</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数作为返回值（包装一个函数，在执行前后输出信息），函数作为参数又作为返回值</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">addWrapper</span>(<span class="params">addFunc</span>: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>) -&gt; ((<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="comment">// 函数内容</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">wrapper</span>(<span class="params">a</span>: <span class="type">Int</span>, <span class="params">b</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;begin&quot;</span>)</span><br><span class="line">        <span class="keyword">let</span> res <span class="operator">=</span> addFunc(a, b)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newAdd <span class="operator">=</span> addWrapper(add)</span><br><span class="line">newAdd(<span class="number">12</span>, <span class="number">32</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>闭包函数声明形式</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; (parameters) -&gt; returnType <span class="keyword">in</span></span><br><span class="line">    statements      <span class="comment">// 可以有多行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>闭包函数</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个函数变量</span></span><br><span class="line"><span class="keyword">var</span> addfunc: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//闭包的写法</span></span><br><span class="line"><span class="comment">// 1. 完整写法</span></span><br><span class="line">add<span class="keyword">func</span> <span class="title function_">=</span> &#123;(a: <span class="type">Int</span>, b: <span class="type">Int</span>) -&gt; (<span class="type">Int</span>) <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//var c = a + 1       //函数体可以有多条语句，如果在同一行，需要用分号隔开，函数体不需要大括号</span></span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">+</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 前面的addfunc变量可以推断出后面函数的参数类型和返回值类型，故可以省略</span></span><br><span class="line">add<span class="keyword">func</span> <span class="title function_">=</span> &#123;(a, b) <span class="keyword">in</span> <span class="keyword">return</span> a <span class="operator">+</span> b&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 参数列表括号可以省去，函数只有一条语句时，return可以省略</span></span><br><span class="line">add<span class="keyword">func</span> <span class="title function_">=</span> &#123;a, b <span class="keyword">in</span> a <span class="operator">+</span> b&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 参数和in可以省去，通过$和索引取得参数</span></span><br><span class="line">add<span class="keyword">func</span> <span class="title function_">=</span> &#123;<span class="variable">$0</span> <span class="operator">+</span> <span class="variable">$1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作符需要的参数与函数参数一致，可以省去参数，并使用括号括起来，作为参数时，可不用括号</span></span><br><span class="line">add<span class="keyword">func</span> <span class="title function_">=</span> (<span class="operator">+</span>)</span><br></pre></td></tr></table></figure>

<h3 id="6-Trailing-尾行-闭包"><a href="#6-Trailing-尾行-闭包" class="headerlink" title="6. Trailing(尾行)闭包"></a>6. Trailing(尾行)闭包</h3><p>如果函数作为另一个函数的参数，并且是最后一个参数时，可以通过Trainling闭包来增强函数的可读性</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunctionThatTakesAClosure</span>(<span class="params">a</span>: <span class="type">Int</span>, <span class="params">closure</span>: () -&gt; ()) &#123;</span><br><span class="line">    <span class="comment">// 函数体部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 一般形式</span></span><br><span class="line">someFunctionThatTakesAClosure(<span class="number">10</span>, closure: &#123;</span><br><span class="line">    <span class="comment">// 闭包主体部分</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Trainling闭包的方式</span></span><br><span class="line">someFunctionThatTakesAClosure(<span class="number">10</span>) &#123;</span><br><span class="line">    <span class="comment">// 闭包主体部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 如果没有其他参数时，可以省略括号</span></span><br><span class="line">someFunctionThatTakesAClosure &#123;</span><br><span class="line">    <span class="comment">// 闭包主体部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-Escaping（逃逸）闭包"><a href="#7-Escaping（逃逸）闭包" class="headerlink" title="7. Escaping（逃逸）闭包"></a>7. Escaping（逃逸）闭包</h3><p>如果一个闭包&#x2F;函数作为参数传给另外一个函数，但这个闭包在传入函数返回之后才会执行，就称该闭包在函数中”逃逸”，需要在函数参数添加<code>@escaping</code>声明，来声明该闭包&#x2F;函数允许从函数中”逃逸”，如下</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> completionHandlers: [() -&gt; <span class="type">Void</span>] <span class="operator">=</span> []</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入的闭包/函数并没有在函数内执行，需要在函数类型钱添加@escaping声明</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">someFunctionWithEscapingClosure</span>(<span class="params">completionHandler</span>: <span class="keyword">@escaping</span> () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    completionHandlers.append(completionHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>逃逸闭包只是一个声明，以增强函数的意图</p>
</blockquote>
<h3 id="8-自动闭包"><a href="#8-自动闭包" class="headerlink" title="8. 自动闭包"></a>8. 自动闭包</h3><p>对于没有参数的闭包，swift提供了一种简写的方式，直接写函数体，不需要函数形式（返回值和参数列表），如下</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个自动闭包（无参数，可以有返回值，返回值类型swift可以自动识别）</span></span><br><span class="line"><span class="keyword">let</span> sayHello <span class="operator">=</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用闭包函数</span></span><br><span class="line">sayHello()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>自动闭包只是闭包的一种简写方式</p>
</blockquote>
<p>如果一个函数接受一个不带参数的闭包</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">logIfTrue</span>(<span class="params">predicate</span>: () -&gt; <span class="type">Bool</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> predicate() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;True&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的时候可以使用自动闭包</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logIfTrue(predicate: &#123; <span class="keyword">return</span> <span class="number">1</span> <span class="operator">&lt;</span> <span class="number">2</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简化return</span></span><br><span class="line">logIfTrue(predicate: &#123; <span class="number">1</span> <span class="operator">&lt;</span> <span class="number">2</span> &#125;)</span><br></pre></td></tr></table></figure>
<p>上面代码看起来可读性不是很好，swift引入了一个关键字<code>@autoclosure</code>，简化自动闭包的大括号，在闭包类型前面添加该关键字声明</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">logIfTrue</span>(<span class="params">predicate</span>: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">Bool</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> predicate() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;True&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">logIfTrue(predicate:<span class="number">1</span> <span class="operator">&lt;</span> <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>@autoclosure</code> 关键字是为了简化闭包的写法，增强可读性，这里的例子比较简单，可以参考：<a target="_blank" rel="noopener" href="http://swifter.tips/autoclosure/">@AUTOCLOSURE 和 ??</a></p>
</blockquote>
<h3 id="9-常量参数和变量参数"><a href="#9-常量参数和变量参数" class="headerlink" title="9. 常量参数和变量参数"></a>9. 常量参数和变量参数</h3><p>默认情况下所有函数参数都是常量，意味着参数是不可变的，我们可以显式的声明参数为变量</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">log</span>(<span class="params">msg</span>: <span class="type">String</span>) &#123;</span><br><span class="line">    msg <span class="operator">=</span> <span class="string">&quot;begin &quot;</span> <span class="operator">+</span> msg <span class="operator">+</span> <span class="string">&quot; end&quot;</span>       <span class="comment">// 会报错，因为msg为常量</span></span><br><span class="line">    <span class="built_in">print</span>(msg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">log</span>(<span class="params">var</span> <span class="params">msg</span>: <span class="type">String</span>) &#123;</span><br><span class="line">    msg <span class="operator">=</span> <span class="string">&quot;begin &quot;</span> <span class="operator">+</span> msg <span class="operator">+</span> <span class="string">&quot; end&quot;</span>       <span class="comment">// 变量参数正常运行</span></span><br><span class="line">    <span class="built_in">print</span>(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：变量参数在swift3被抛弃</p>
</blockquote>
<h3 id="10-输入输出参数"><a href="#10-输入输出参数" class="headerlink" title="10. 输入输出参数"></a>10. 输入输出参数</h3><p>在c语言里有指针，可以通过传址直接修改外部变量的值，在swift通过<code>inout</code>关键字声明函数内部可直接修改外部变量，外部通过<code>&amp;</code>操作符取得变量地址</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">swap</span>(<span class="params">inout</span> <span class="params">a</span>: <span class="type">Int</span>, <span class="params">inout</span> <span class="params">b</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp <span class="operator">=</span> a</span><br><span class="line">    a <span class="operator">=</span> b</span><br><span class="line">    b <span class="operator">=</span> temp</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a <span class="operator">=</span> <span class="number">19</span>, b <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="built_in">swap</span>(<span class="operator">&amp;</span>a, <span class="operator">&amp;</span>b)</span><br></pre></td></tr></table></figure>

<h3 id="11-嵌套函数"><a href="#11-嵌套函数" class="headerlink" title="11. 嵌套函数"></a>11. 嵌套函数</h3><p>swift的函数还支持嵌套，默认情况下，嵌套函数对外部不可见，只能在函数内部使用</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">chooseStepFunction</span>(<span class="params">backward</span>: <span class="type">Bool</span>) -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="comment">//定义两个内部函数</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">stepForward</span>(<span class="params">input</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> input <span class="operator">+</span> <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">stepBackward</span>(<span class="params">input</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> input <span class="operator">-</span> <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> backward <span class="operator">?</span> stepBackward : stepForward</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嵌套函数相当于objc函数内的block</p>
<h3 id="12-defer"><a href="#12-defer" class="headerlink" title="12. defer"></a>12. defer</h3><p>在swift2.0之后添加了<code>defer</code>关键字，可以定义代码块在函数执行完成之前的完成一些操作，<strong>并且在函数抛出错误的时候也可以执行</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">test</span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;begin1&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> &#123;             <span class="comment">// 入栈</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;end1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;begin2&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> &#123;             <span class="comment">// 入栈</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;end2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;begin4&quot;</span>)</span><br><span class="line">        <span class="keyword">defer</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;end4&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;begin5&quot;</span>)</span><br><span class="line">        <span class="keyword">defer</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;end5&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;do balabala&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面输出结果为</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">begi<span class="symbol">n1</span></span><br><span class="line">begi<span class="symbol">n2</span></span><br><span class="line">begi<span class="symbol">n4</span></span><br><span class="line">begi<span class="symbol">n5</span></span><br><span class="line">e<span class="symbol">nd5</span></span><br><span class="line">e<span class="symbol">nd4</span></span><br><span class="line"><span class="keyword">do</span> balabala</span><br><span class="line">e<span class="symbol">nd2</span></span><br><span class="line">e<span class="symbol">nd1</span></span><br></pre></td></tr></table></figure>
<p>通常可以用在需要成对操作的逻辑中（如：<code>open/close</code>）</p>
<h2 id="九、枚举"><a href="#九、枚举" class="headerlink" title="九、枚举"></a>九、枚举</h2><p>swift的枚举比C语言的枚举更为强大，支持更多特性，swift的枚举更像类和结构体，支持类和结构体的一些特性，与<code>ObjC</code>不同，如果不声明枚举的值，编译器不会给枚举设置默认值</p>
<blockquote>
<p>枚举与结构体一样，是值类型</p>
</blockquote>
<h3 id="1-声明和使用"><a href="#1-声明和使用" class="headerlink" title="1. 声明和使用"></a>1. 声明和使用</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CompassPoint</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">North</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">South</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">East</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">West</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 可以把枚举值定义在一行，用逗号隔开</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CompassPoint2</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">North</span>, <span class="type">South</span>, <span class="type">East</span>, <span class="type">West</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 像对象一样使用枚举，代码结构更为清晰，枚举更为简短</span></span><br><span class="line"><span class="keyword">let</span> direction <span class="operator">=</span> <span class="type">CompassPoint</span>.<span class="type">East</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 如果编译器可以识别出枚举的类型，可以省略枚举名</span></span><br><span class="line"><span class="keyword">let</span> direction2: <span class="type">CompassPoint</span></span><br><span class="line">direction2 <span class="operator">=</span> .<span class="type">East</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 如果编译器能确定case命中所有的情况，可以不需要default</span></span><br><span class="line"><span class="keyword">switch</span> direction &#123;</span><br><span class="line"><span class="keyword">case</span> .<span class="type">East</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;east&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> .<span class="type">West</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;west&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> .<span class="type">South</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;south&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> .<span class="type">North</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;north&quot;</span>)</span><br><span class="line">    <span class="comment">//所有值都被枚举，则不需要default</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-嵌套枚举"><a href="#2-嵌套枚举" class="headerlink" title="2. 嵌套枚举"></a>2. 嵌套枚举</h3><p>swift的枚举定义支持嵌套，在使用的时候一层一层引用</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Character</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Weapon</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Bow</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Sword</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Lance</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Dagger</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Helmet</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Wooden</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Iron</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Diamond</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Thief</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Warrior</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Knight</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> character <span class="operator">=</span> <span class="type">Character</span>.<span class="type">Thief</span></span><br><span class="line"><span class="keyword">let</span> weapon <span class="operator">=</span> <span class="type">Character</span>.<span class="type">Weapon</span>.<span class="type">Bow</span></span><br><span class="line"><span class="keyword">let</span> helmet <span class="operator">=</span> <span class="type">Character</span>.<span class="type">Helmet</span>.<span class="type">Iron</span></span><br></pre></td></tr></table></figure>

<h3 id="3-递归枚举"><a href="#3-递归枚举" class="headerlink" title="3. 递归枚举"></a>3. 递归枚举</h3><p>枚举的关联值的类型可以设为枚举自身，这样的枚举称为递归枚举</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">ArithmeticExpression</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> number(<span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">indirect</span> <span class="keyword">case</span> addition(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">    <span class="keyword">indirect</span> <span class="keyword">case</span> multiplication(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>带递归类型的枚举需要在case前面添加关键字声明<code>indirect</code>，也可以在enum前面加上声明，表示所有的成员是可以递归的</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">indirect</span> <span class="keyword">enum</span> <span class="title class_">ArithmeticExpression</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> number(<span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> addition(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">    <span class="keyword">case</span> multiplication(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用递归枚举取值的时候可以使用递归函数</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">evaluate</span>(<span class="keyword">_</span> <span class="params">expression</span>: <span class="type">ArithmeticExpression</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">   <span class="keyword">switch</span> expression &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="keyword">let</span> .number(value):</span><br><span class="line">       <span class="keyword">return</span> value</span><br><span class="line">   <span class="keyword">case</span> <span class="keyword">let</span> .addition(left, right):</span><br><span class="line">       <span class="keyword">return</span> evaluate(left) <span class="operator">+</span> evaluate(right)</span><br><span class="line">   <span class="keyword">case</span> <span class="keyword">let</span> .multiplication(left, right):</span><br><span class="line">       <span class="keyword">return</span> evaluate(left) <span class="operator">*</span> evaluate(right)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> five <span class="operator">=</span> <span class="type">ArithmeticExpression</span>.number(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">let</span> four <span class="operator">=</span> <span class="type">ArithmeticExpression</span>.number(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">let</span> sum <span class="operator">=</span> <span class="type">ArithmeticExpression</span>.addition(five, four)</span><br><span class="line"></span><br><span class="line"><span class="comment">// (5 + 4) * 2</span></span><br><span class="line"><span class="keyword">let</span> product <span class="operator">=</span> <span class="type">ArithmeticExpression</span>.multiplication(sum, <span class="type">ArithmeticExpression</span>.number(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(evaluate(product))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其实感觉这种嵌套多层的用法可读性并不是特别好，而且在取值的时候还需要递归，通常来说，嵌套一层就够了</p>
</blockquote>
<h3 id="4-原始值"><a href="#4-原始值" class="headerlink" title="4. 原始值"></a>4. 原始值</h3><p>与C语言一样，可以为每个枚举指定值，并且可以支持更多类型（<code>Int</code>, <code>Float</code>, <code>Character</code>, <code>String</code>）</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义枚举，并初始化原始值</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ASCIIControlCharacter</span>: <span class="title class_">Character</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Tab</span> <span class="operator">=</span> <span class="string">&quot;<span class="subst">\t</span>&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">LineFeed</span> <span class="operator">=</span> <span class="string">&quot;<span class="subst">\n</span>&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">CarriageReturn</span> <span class="operator">=</span> <span class="string">&quot;<span class="subst">\r</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通过两个属性获得原始值</span></span><br><span class="line"><span class="keyword">var</span> ch <span class="operator">=</span> <span class="type">ASCIIControlCharacter</span>.<span class="type">Tab</span></span><br><span class="line">ch.hashValue    <span class="comment">// 获取是否有原始值</span></span><br><span class="line">ch.rawValue     <span class="comment">// 获得原始值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 通过原始值构造枚举，如果不存在，则返回nil</span></span><br><span class="line"><span class="keyword">var</span> tab <span class="operator">=</span> <span class="type">ASCIIControlCharacter</span>.<span class="keyword">init</span>(rawValue: <span class="string">&quot;<span class="subst">\t</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 如果是原始值是整形值，后面的值默认自增1，如果不指定，则默认为空，而不是从0开始</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Planet</span>: <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Mercury</span> <span class="operator">=</span> <span class="number">1</span>, <span class="type">Venus</span>         <span class="comment">// Venus = 2</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Neptune</span>                    <span class="comment">// Neptune = 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 如果没有指定枚举原始值的类型，则默认为空，而不是整型</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CompassPoint</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">North</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">South</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">East</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">West</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//swift 不会为North, South, East, West设置为0,1,2,3，并且CompassPoint没有原始值（rawValue）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 有原始值的枚举可以通过原始值构造（构造器返回可选类型）</span></span><br><span class="line"><span class="keyword">let</span> lineFeed <span class="operator">=</span> <span class="type">ASCIIControlCharacter</span>(rawValue: <span class="string">&quot;<span class="subst">\n</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="5-关联值"><a href="#5-关联值" class="headerlink" title="5. 关联值"></a>5. 关联值</h3><p>上面我们说到，枚举与类和结构体类似，swift的枚举可以给不同的枚举值绑定关联值，如下</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Barcode</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">UPCA</span>(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>)        <span class="comment">//条形码，关联一个元组</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">QRCode</span>(<span class="type">String</span>)             <span class="comment">//二维码，关联一个字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> productBarcode <span class="operator">=</span> <span class="type">Barcode</span>.<span class="type">UPCA</span>(<span class="number">8</span>, <span class="number">85909_51226</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// var productBarcode = .QRCode(&quot;http://www.baidu.com&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> productBarcode &#123;</span><br><span class="line"><span class="keyword">case</span> .<span class="type">UPCA</span>(<span class="keyword">let</span> a, <span class="keyword">let</span> b, <span class="keyword">let</span> c):        <span class="comment">//在枚举的时候可以取得关联值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;barcode: <span class="subst">\(a)</span><span class="subst">\(b)</span><span class="subst">\(c)</span>&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">QRCode</span>(value):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;qrcode: <span class="subst">\(value)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上面这种轻量的数据，在OC上一般我们可能需要定义两个类实现，而swift的枚举可以轻松的处理这种轻量数据，而减少项目中类的定义和维护</p>
<h2 id="十、类与结构体"><a href="#十、类与结构体" class="headerlink" title="十、类与结构体"></a>十、类与结构体</h2><p>先来看看结构体和类的一些差异</p>
<ul>
<li>类是引用类型，结构体为值类型</li>
<li>类使用引用计数管理内存，结构体分配在栈上，有系统管理内存，变量传递的时候，结构体整个拷贝，而类默认只传递引用地址（有些类会进行一些额外的拷贝，详见<a href="">深拷贝和浅拷贝</a>）</li>
<li>结构体不支持继承，类支持继承</li>
<li>与ObjC不同，swift的结构体可以定义方法</li>
<li>类支持运行时类型检查，而结构体不支持</li>
<li>类有构造器和析构器，结构体只有构造器</li>
<li>常量结构体的成员的值不能改变</li>
</ul>
<blockquote>
<p>实际上，在 Swift 中，所有的基本类型:整数(Integer)、浮 点数(floating-point)、布尔值(Boolean)、字符串(string)、数组(array)和字典(dictionary)，都是 值类型，并且在底层都是以结构体的形式所实现。</p>
</blockquote>
<h3 id="1-结构体，类定义"><a href="#1-结构体，类定义" class="headerlink" title="1. 结构体，类定义"></a>1. 结构体，类定义</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">printPoint</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;x=<span class="subst">\(x)</span>, y=<span class="subst">\(y)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> someObj <span class="operator">=</span> <span class="type">NSObject</span>()          <span class="comment">// 定义属性，并初始化</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>                  <span class="comment">// 定义属性，并指定类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;              <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">hello</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;hello <span class="subst">\(<span class="keyword">self</span>.name)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;dealloc&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>swift中，许多基本类型如<code>String</code>, <code>Array</code>和<code>Dictionary</code>都是用结构体实现的，意味着在传递的时候都会进行值拷贝，当然swift也对这些类型进行了优化，只有在需要的时候进行拷贝</p>
<h3 id="2-静态属性，静态方法"><a href="#2-静态属性，静态方法" class="headerlink" title="2. 静态属性，静态方法"></a>2. 静态属性，静态方法</h3><p>swift中有两个<code>static</code>和<code>class</code>声明静态变量或方法，其中<code>class</code>只能用在类的方法和计算属性上，其他的都使用<code>static</code>，由于类支持继承，所以使用<code>class</code>声明的静态方法可以被继承，而static声明的静态方法不能被继承</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> instanceCount: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span>       <span class="comment">// 声明一个类属性</span></span><br><span class="line">    <span class="keyword">init</span> () &#123;</span><br><span class="line">        <span class="type">Person</span>.instanceCount <span class="operator">+=</span> <span class="number">1</span>           <span class="comment">// 通过类名引用类属性，子类可以访问基类的类属性</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用class声明的静态方法可以被继承</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">func</span> <span class="title class_">overrideableComputedTypeProperty</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(Person.instanceCount)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用static声明的静态方法不能被继承</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">printInstanceCount</span>() &#123;      <span class="comment">// 声明一个静态方法</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(Person.instanceCount)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类和结构体的声明和用法与类类似，使用<code>static</code></p>
<blockquote>
<p>注意：<code>class</code>只能用来声明计算属性和方法，不能用来声明普通属性</p>
</blockquote>
<h3 id="3-构造器和析构器"><a href="#3-构造器和析构器" class="headerlink" title="3. 构造器和析构器"></a>3. 构造器和析构器</h3><p>swift的构造器规则和限制比较多，关于构造器可以参见：<a href="/2016-07-07/swift-constructor/">这里</a></p>
<p>析构器相当于objc里面的<code>dealloc</code>方法，做一些需要手动释放资源的操作，析构器与构造器不同，没有参数，定义的时候不需要括号，类在释放的之前会自动调用父类的析构器，不需要主动调用</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;释放额外的资源，如通知&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-类型判断"><a href="#4-类型判断" class="headerlink" title="4. 类型判断"></a>4. 类型判断</h3><p>在objc中，我们通常使用<code>isKindOfClass</code>, <code>isMemberOfClass</code>, <code>isSubclassOfClass</code>等方法进行类型判断，swift使用<code>is</code>和<code>as</code>判断类型</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>: <span class="title class_">Parent</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s <span class="operator">=</span> <span class="type">Son</span>()</span><br><span class="line"><span class="comment">// isKindOfClass</span></span><br><span class="line">son <span class="keyword">is</span> <span class="type">Son</span>                <span class="comment">// true</span></span><br><span class="line">son <span class="keyword">is</span> <span class="type">Parent</span>             <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// isMemberOfClass</span></span><br><span class="line">son.dynamicType <span class="operator">==</span> <span class="type">Son</span>.<span class="keyword">self</span>         <span class="comment">// true</span></span><br><span class="line">son.dynamicType <span class="operator">==</span> <span class="type">Parent</span>.<span class="keyword">self</span>      <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// isSubclassOfClass 暂时没找到相关的API</span></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;TODO: swift动态性，反射</p>
<h3 id="5-弱引用"><a href="#5-弱引用" class="headerlink" title="5. 弱引用"></a>5. 弱引用</h3><p>与<code>ObjC</code>一样，swift的内存管理也使用引用计数管理，也使用weak声明弱引用变量</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> person: <span class="type">Person</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-访问级别"><a href="#6-访问级别" class="headerlink" title="6. 访问级别"></a>6. 访问级别</h3><p>在swift中，framework和bundle都被处理成模块</p>
<pre><code>* public：公开，可以被外部访问
* internal：内部，在模块（framework）内部使用，模块外访问不到
* private：只能在当前源文件中使用
</code></pre>
<p>swift默认的访问级别为Internal，使用的时候只需要在类&#x2F;变量&#x2F;函数前面加上访问级别即可</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">public</span> <span class="title class_">var</span> <span class="title class_">peopleCount</span>: <span class="title class_">Int</span> = 0    // 类变量，通过<span class="title class_">class</span>声明，类变量使用时使用类名引用</span><br><span class="line">    <span class="title class_">internal</span> <span class="title class_">var</span> <span class="title class_">age</span>: <span class="title class_">Int</span>                    // 实例变量</span><br><span class="line">    <span class="title class_">var</span> <span class="title class_">name</span>: <span class="title class_">String</span>                         // 不声明，则为<span class="title class_">internal</span></span><br><span class="line"></span><br><span class="line">    <span class="title class_">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.age <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="type">Person</span>.peopleCount<span class="operator">++</span>              <span class="comment">// 使用静态变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">sayHello</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>外层访问级别的必须是比成员更高，下面会报警告</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;                      <span class="comment">// 默认为internal</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> age: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span>         <span class="comment">// 为public，比类访问级别高，会有警告</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> gender: <span class="type">Int</span> <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">sayHello</span>() &#123;</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数的访问级别要比参数(或泛型类型)的访问级别低，否则会报警告</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">PrivatePerson</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> age: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> gender: <span class="type">Int</span> <span class="operator">=</span> <span class="number">10</span>          <span class="comment">// 报警告</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">sayHello</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">test</span>(<span class="params">person</span>:<span class="type">PrivatePerson</span>) &#123;    <span class="comment">//报编译错误：这里参数访问级别为private，所以函数访问级别不能高于private，则只能为private</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>枚举类型</code>的成员访问级别跟随枚举类型，嵌套类型默认最高访问级别为internal（外层为public，内层默认为internal）</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">CompassPoint</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">North</span>            <span class="comment">// 四个枚举成员访问级别都为public</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">South</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">East</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">West</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类访问级别不能高于父类（包括泛型类型），协议继承也同理，子协议访问级别不能高于父协议</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span>: <span class="title class_">Parent</span> &#123;       <span class="comment">// 报编译错误：Son访问级别必须低于Parent，应该为internal或private</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>元组</code>的访问级别为元组内所有类型访问级别中最低级的</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Son</span>: <span class="title class_">Parent</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">let</span> sometuple <span class="operator">=</span> (<span class="type">Son</span>(), <span class="type">Parent</span>())  <span class="comment">// 报编译错误：sometuple的访问级别不能高于成员类型的访问级别，由于Son为private，故sometuple必须为private</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量的访问级别不能高于类型</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">PrivateClass</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">var</span> value: <span class="type">PrivateClass</span>        <span class="comment">// 报编译错误：变量value的访问级别不能高于其类型，故value必须声明为private</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属性的 Setter 访问级别不能高于 Getter访问级别</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> num <span class="operator">=</span> <span class="number">1_000_000</span>      <span class="comment">// 声明属性num，getter访问级别没有声明，默认为Internal，setter访问级别为private</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">internal(set)</span> <span class="keyword">var</span> name <span class="operator">=</span> <span class="string">&quot;bomo&quot;</span>   <span class="comment">// 报编译错误：属性name的setter访问级别为internal，高于getter访问级别private</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>协议与类的访问级别关系</p>
<ul>
<li>协议中所有必须实现的成员的访问级别和协议本身的访问级别相同</li>
<li>其子协议的访问级别不高于父协议（与类相同）</li>
<li>如果类实现了协议，那类的访问级别必须低于或等于协议的访问级别</li>
</ul>
<p>类型别名访问级别与类型的关系</p>
<ul>
<li>类型别名的访问级别不能高于原类型的访问级别；</li>
</ul>
<p>函数构造函数默认访问级别为internal，如果需要给其他模块使用，需显式声明为public</p>
<blockquote>
<p>注意：swift的访问级别是作用于文件（private）和模块的（internal）的，而不只是类，所以只要在同一个文件内，private访问级别在不同类也可以直接访问，例如我们可以通过子类包装父类的方法以改变访问级别</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">someMethod</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">B</span>: <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">internal</span> <span class="keyword">func</span> <span class="title function_">someMethod</span>() &#123;   <span class="comment">// 在同一个文件，改变someMethod的访问级别</span></span><br><span class="line">        <span class="keyword">super</span>.someMethod()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-属性"><a href="#7-属性" class="headerlink" title="7. 属性"></a>7. 属性</h3><ul>
<li>使用关键字<code>lazy</code>声明一个懒加载 <strong>变量</strong> 属性，当属性被使用的时候（get），才会进行初始化</li>
<li>set方法的访问级别必须必get方法低</li>
<li>声明属性的时候可以使用<code>private(set)</code>和<code>internal(set)</code>改变set方法默认的访问级别</li>
<li>每个实例都有一个self属性，指向实例自身，通常在属性与函数参数有冲突的时候使用</li>
<li>对于常量属性，不许在定义它的类的构造器中赋值，不能再子类赋值</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataImporter</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataManager</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 只有第一次调用importer的get方法的时候才会初始化</span></span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> importer <span class="operator">=</span> <span class="type">DataImporter</span>()</span><br><span class="line">    <span class="keyword">var</span> data <span class="operator">=</span> [<span class="type">String</span>]()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> height: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 声明get方法和set方法的访问级别</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">private(set)</span> <span class="keyword">var</span> weight: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 自定义get/set方法</span></span><br><span class="line">    <span class="keyword">var</span> square: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">self</span>.width <span class="operator">+</span> <span class="keyword">self</span>.height)<span class="operator">/</span><span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//set &#123;                 //如果不指定名称，默认通过newValue使用新值</span></span><br><span class="line">        <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">            <span class="keyword">self</span>.width <span class="operator">=</span> newValue<span class="operator">/</span><span class="number">2.0</span>;</span><br><span class="line">            <span class="keyword">self</span>.height <span class="operator">=</span> newValue<span class="operator">/</span><span class="number">2.0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 只读属性，可以省略get，直接使用一个花括号</span></span><br><span class="line">    <span class="keyword">var</span> perimeter: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">self</span>.width <span class="operator">+</span> <span class="keyword">self</span>.height) <span class="operator">*</span> <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 属性监视器，在初始化的时候不会触发</span></span><br><span class="line">    <span class="keyword">var</span> someInt: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;       <span class="comment">//用法与set一样如果不指定名称，默认通过newValue使用旧值</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;set方法之前触发&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;        <span class="comment">//用法与set一样如果不指定名称，默认通过oldValue使用旧值</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;set方法完成后触发，可以在这里设置obj的值覆盖set方法设置的值&quot;</span>)</span><br><span class="line">            <span class="keyword">self</span>.someInt <span class="operator">=</span> <span class="number">0</span>      <span class="comment">// someInt的值永远为0，在监视器修改属性的值不会导致观察器被再次调用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用lazy声明的属性不是线程安全的，在多线程情况下可能产生多份，需要自己控制</p>
</blockquote>
<p>对于结构体，与OC不同，swift的结构体允许直接对属性的子属性直接修改，而不需要取出重新赋值</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someVideoMode.resolution.width <span class="operator">=</span> <span class="number">1280</span></span><br></pre></td></tr></table></figure>
<p>在oc上需要这样做</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var resolution = someVideoMode.resolution</span><br><span class="line">resolution.width = <span class="number">1024</span></span><br><span class="line">someVideoMode.resolution = resolution</span><br></pre></td></tr></table></figure>

<h3 id="8-继承"><a href="#8-继承" class="headerlink" title="8. 继承"></a>8. 继承</h3><p>我们都知道，在oc里所有的类都继承自NSObject&#x2F;NSProxy，而在swift中的类并不是从一个通用的基类继承的，所有没有继承其他父类的类都称为<code>基类</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">var</span> gender <span class="operator">=</span> <span class="string">&quot;unknown&quot;</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">gender</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.gender <span class="operator">=</span> gender</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">hello</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;parent hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>: <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="comment">// 重写可以改变父类方法的访问级别</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">hello</span>() &#123;                  <span class="comment">// 重写父类方法必须加上override，否则会报编译错误</span></span><br><span class="line">        <span class="comment">//super.hello()                               // 可以通过super访问父类成员，包括附属脚本</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;son hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重写属性的时候，如果属性提供了setter方法，则必须为提供getter方法<br>如果重写了属性的setter方法，则不能重写willSet和didSet方法<br>如果重写了willSet和didSet方法，则不能重写get和set方法</p>
</blockquote>
<p>父类的属性，方法，类方法，附属脚本，包括类本身都可以被子类继承和重写，可以通过<code>final</code>约束限制子类的重写（<code>final class</code>, <code>final var</code>, <code>final func</code>, <code>final class func</code>, 以及 <code>final subscript</code>）</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">var</span> gender <span class="operator">=</span> <span class="string">&quot;unknown&quot;</span>        <span class="comment">// 不允许被子类重写</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>                    <span class="comment">// 可以被子类重写</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">gender</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.gender <span class="operator">=</span> gender</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">func</span> <span class="title function_">hello</span>() &#123;                <span class="comment">// 不允许被重写</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;parent hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>swift编译器在识别数组类型的时候，如果数组元素有相同的基类，会被自动识别出来</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>: <span class="title class_">Person</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="title class_">Person</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> t1 <span class="operator">=</span> <span class="type">Teacher</span>()</span><br><span class="line"><span class="keyword">let</span> t2 <span class="operator">=</span> <span class="type">Teacher</span>()</span><br><span class="line"><span class="keyword">let</span> s1 <span class="operator">=</span> <span class="type">Student</span>()</span><br><span class="line"><span class="keyword">let</span> s2 <span class="operator">=</span> <span class="type">Student</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> people <span class="operator">=</span> [t1, t2, s1, s2]      <span class="comment">// people会被识别为[Person]类型</span></span><br></pre></td></tr></table></figure>

<p>向下类型转换<code>as!</code>, <code>as?</code>，<code>as!</code>返回非可选类型，如果类型不匹配会报错，<code>as?</code>返回可选类型，如果类型不匹配返回nil</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> person <span class="keyword">in</span> people &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> teacher <span class="operator">=</span> person <span class="keyword">as?</span> <span class="type">Teacher</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;teacher&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> student <span class="operator">=</span> person <span class="keyword">as?</span> <span class="type">Student</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;student&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-附属脚本subscript"><a href="#9-附属脚本subscript" class="headerlink" title="9. 附属脚本subscript"></a>9. 附属脚本subscript</h3><p>附属脚本可以让类、结构体、枚举对象快捷访问集合或序列，而不需要调用使用对象内的实例变量引用，看下面实例</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DailyMeal</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">MealTime</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Breakfast</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Lunch</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Dinner</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> meals: [<span class="type">MealTime</span> : <span class="type">String</span>] <span class="operator">=</span> [:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要使用DailyMeal的meals对象的，需要这么用</span></span><br><span class="line"><span class="keyword">var</span> dailyMeal <span class="operator">=</span> <span class="type">DailyMeal</span>()</span><br><span class="line">dailyMeal.meals[<span class="type">MealTime</span>.<span class="type">Breakfast</span>] <span class="operator">=</span> <span class="string">&quot;Toast&quot;</span></span><br></pre></td></tr></table></figure>

<p>使用附属脚本可以直接通过类对象索引访问meals的值</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DailyMeal</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">MealTime</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Breakfast</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Lunch</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Dinner</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> meals: [<span class="type">MealTime</span> : <span class="type">String</span>] <span class="operator">=</span> [:]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义附加脚本，类似属性</span></span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">realMealTime</span>: <span class="type">MealTime</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> value <span class="operator">=</span> meals[realMealTime] &#123;</span><br><span class="line">                <span class="keyword">return</span> value</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;unknown&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">            meals[realMealTime] <span class="operator">=</span> newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dailyMeal <span class="operator">=</span> <span class="type">DailyMeal</span>()</span><br><span class="line">dailyMeal[.<span class="type">Breakfast</span>] <span class="operator">=</span> <span class="string">&quot;sala&quot;</span></span><br><span class="line"><span class="built_in">print</span>(dailyMeal[.<span class="type">Breakfast</span>])</span><br></pre></td></tr></table></figure>

<p>附加脚本还支持多个参数</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> rows: <span class="type">Int</span>, columns: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> grid: [<span class="type">Double</span>]</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">rows</span>: <span class="type">Int</span>, <span class="params">columns</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.rows <span class="operator">=</span> rows</span><br><span class="line">        <span class="keyword">self</span>.columns <span class="operator">=</span> columns</span><br><span class="line">        grid <span class="operator">=</span> <span class="type">Array</span>(count: rows <span class="operator">*</span> columns, repeatedValue: <span class="number">0.0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">indexIsValidForRow</span>(<span class="params">row</span>: <span class="type">Int</span>, <span class="params">column</span>: <span class="type">Int</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> row <span class="operator">&gt;=</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> row <span class="operator">&lt;</span> rows <span class="operator">&amp;&amp;</span> column <span class="operator">&gt;=</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> column <span class="operator">&lt;</span> columns</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">row</span>: <span class="type">Int</span>, <span class="params">column</span>: <span class="type">Int</span>) -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="built_in">assert</span>(indexIsValidForRow(row, column: column), <span class="string">&quot;Index out of range&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> grid[(row <span class="operator">*</span> columns) <span class="operator">+</span> column]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="built_in">assert</span>(indexIsValidForRow(row, column: column), <span class="string">&quot;Index out of range&quot;</span>)</span><br><span class="line">            grid[(row <span class="operator">*</span> columns) <span class="operator">+</span> column] <span class="operator">=</span> newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> matrix <span class="operator">=</span> <span class="type">Matrix</span>(rows: <span class="number">2</span>, columns: <span class="number">2</span>)</span><br><span class="line">matrix[<span class="number">0</span>, <span class="number">1</span>] <span class="operator">=</span> <span class="number">1.5</span></span><br><span class="line">matrix[<span class="number">1</span>, <span class="number">0</span>] <span class="operator">=</span> <span class="number">3.2</span></span><br></pre></td></tr></table></figure>

<p>附加脚本类似属性，拥有get&#x2F;set方法，支持只读和读写两种方式，附加脚本也支持多个参数，附属脚本可以屏蔽外部对内部对象的直接访问，隐藏对象内部的细节，提高封装度，使得代码更加健壮和简洁</p>
<h3 id="10-类型嵌套"><a href="#10-类型嵌套" class="headerlink" title="10. 类型嵌套"></a>10. 类型嵌套</h3><p>与枚举一样，结构体和类都支持类型嵌套，可以在类里面再定义类&#x2F;结构体&#x2F;枚举</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="comment">// 类里面嵌套定义枚举</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Suit</span>: <span class="title class_">Character</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Spades</span> <span class="operator">=</span> <span class="string">&quot;♠&quot;</span>, <span class="type">Hearts</span> <span class="operator">=</span> <span class="string">&quot;♡&quot;</span>, <span class="type">Diamonds</span> <span class="operator">=</span> <span class="string">&quot;♢&quot;</span>, <span class="type">Clubs</span> <span class="operator">=</span> <span class="string">&quot;♣&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举里面嵌套定义结构体</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Values</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> first: <span class="type">Int</span>, second: <span class="type">Int</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类里面嵌套定义结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">        <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类里面嵌套定义类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> name: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">var</span> id: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用的时候像属性一样引用</span></span><br><span class="line"><span class="keyword">let</span> values <span class="operator">=</span> <span class="type">SomeClass</span>.<span class="type">Suit</span>.<span class="type">Values</span>(first: <span class="number">1</span>, second: <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="11-类型别名"><a href="#11-类型别名" class="headerlink" title="11. 类型别名"></a>11. 类型别名</h3><p>swift类型别名与c语言中取别名有点像，通过关键字<code>typealias</code>声明别名</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">MyInt</span> <span class="operator">=</span> <span class="type">Int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">add</span>(<span class="params">a</span>: <span class="type">MyInt</span>, <span class="params">b</span>: <span class="type">MyInt</span>) -&gt; <span class="type">MyInt</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">+</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通常在容易出现命名冲突的情况下会考虑使用类型别名</p>
</blockquote>
<h2 id="十一、扩展Extension"><a href="#十一、扩展Extension" class="headerlink" title="十一、扩展Extension"></a>十一、扩展Extension</h2><p>与oc一样，扩展就是对已有的类添加新的功能，与oc的category类似，swift的扩展可以：</p>
<ul>
<li>提供新的构造器（需要符合构造器的基本规则）</li>
<li>添加实例计算型属性和类计算性属性</li>
<li>添加实例方法和类方法</li>
<li>添加附加脚本</li>
<li>添加新的嵌套类型</li>
<li>使一个已有类型符合某个接口</li>
</ul>
<p>swift扩展不可以：</p>
<ul>
<li>不可以添加存储属性</li>
<li>不可以向已有属性添加属性观测器(willSet, didSet)</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">hello</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义扩展</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">fly</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;fly&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p <span class="operator">=</span> <span class="type">Person</span>()</span><br><span class="line">p.fly()</span><br></pre></td></tr></table></figure>

<p>扩展也可以作用在结构体和枚举上</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> width: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">let</span> height: <span class="type">Double</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> perimeter: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> <span class="operator">*</span> (<span class="keyword">self</span>.width <span class="operator">+</span> <span class="keyword">self</span>.height)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rect <span class="operator">=</span> <span class="type">Rectangle</span>(width: <span class="number">100</span>, height: <span class="number">200</span>)</span><br><span class="line"><span class="built_in">print</span>(rect.perimeter)</span><br></pre></td></tr></table></figure>
<p>扩展内的成员定义与类类似，这里不再说明</p>
<h3 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h3><p>由于swift不能扩展新的属性，有时候我们希望给类添加属性，在oc里可以用关联属性新增存储属性，在swift也可以，需要引入<code>ObjectiveC</code>模块</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ObjectiveC</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> y: <span class="type">Int</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> xoTag: <span class="type">UInt</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> z: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, <span class="operator">&amp;</span>xoTag) <span class="keyword">as!</span> <span class="type">Int</span></span><br><span class="line">        &#125; <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">            objc_setAssociatedObject(<span class="keyword">self</span>, <span class="operator">&amp;</span>xoTag, newValue, objc_AssociationPolicy.<span class="type">OBJC_ASSOCIATION_ASSIGN</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十二、协议Protocal"><a href="#十二、协议Protocal" class="headerlink" title="十二、协议Protocal"></a>十二、协议Protocal</h2><p>swift的协议在oc的基础上加了更多的支持，可以支持属性，方法，附加脚本，操作符等，协议的属性必须为变量<code>var</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="comment">// 属性要求</span></span><br><span class="line">    <span class="keyword">var</span> mustBeSettable: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="comment">// 只读属性</span></span><br><span class="line">    <span class="keyword">var</span> doesNotNeedToBeSettable: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="comment">// 只读静态属性</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> staticProperty: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">hello</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-mutating"><a href="#1-mutating" class="headerlink" title="1. mutating"></a>1. mutating</h3><p>在结构体&#x2F;枚举中的值类型变量，默认情况下不能对其进行修改，编译不通过，如果需要修改值类型的属性，需要在方法声明前加上<code>mutating</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">moveToPoint</span>(<span class="params">point</span>: <span class="type">Point</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x <span class="operator">=</span> point.x        <span class="comment">// 报错：不能对值类型的属性进行修改</span></span><br><span class="line">        <span class="keyword">self</span>.y <span class="operator">=</span> point.y        <span class="comment">// 报错：不能对值类型的属性进行修改</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">moveToPoint2</span>(<span class="params">point</span>: <span class="type">Point</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x <span class="operator">=</span> point.x        <span class="comment">// 编译通过</span></span><br><span class="line">        <span class="keyword">self</span>.y <span class="operator">=</span> point.y        <span class="comment">// 编译通过</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可变方法还可以对self进行修改，这个方法和moveToPoint2效果相同</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">moveToPoint3</span>(<span class="params">x</span> <span class="params">deltaX</span>: <span class="type">Int</span>, <span class="params">y</span> <span class="params">deltaY</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span> <span class="operator">=</span> <span class="type">Point</span>(x:deltaX, y:deltaY)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可变方法还可以修改枚举值自身的值</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">TriStateSwitch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Off</span>, <span class="type">Low</span>, <span class="type">High</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">next</span>() &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> .<span class="type">Off</span>:</span><br><span class="line">                <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">Low</span></span><br><span class="line">            <span class="keyword">case</span> .<span class="type">Low</span>:</span><br><span class="line">                <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">High</span></span><br><span class="line">            <span class="keyword">case</span> .<span class="type">High</span>:</span><br><span class="line">                <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">Off</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特别是在定义Protocal的时候，需要考虑到协议可能作用于枚举或结构体，在定义协议的时候需要在方法前加上<code>mutating</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">moveToPoint</span>(<span class="params">point</span>: <span class="type">Point</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-协议类型"><a href="#2-协议类型" class="headerlink" title="2. 协议类型"></a>2. 协议类型</h3><p>协议虽然没有任何实现，但可以当做类型来用，与oc的protocal类似，用协议类型表示实现了该协议的对象，与oc的<code>id&lt;SomeProtocol&gt;</code>一样</p>
<h3 id="3-协议组合"><a href="#3-协议组合" class="headerlink" title="3. 协议组合"></a>3. 协议组合</h3><p>有时候我们需要表示一个对象实现多个协议，可以使用协议组合来表示，如下</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SwimProtocal</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">fly</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">WalkProtocal</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">walk</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">through</span>(<span class="params">animal</span>: <span class="keyword">protocol</span><span class="operator">&lt;</span><span class="type">WalkProtocal</span>, <span class="type">SwimProtocal</span><span class="operator">&gt;</span>) &#123;</span><br><span class="line">    animal.walk()</span><br><span class="line">    animal.fly()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-自身类型"><a href="#4-自身类型" class="headerlink" title="4. 自身类型"></a>4. 自身类型</h3><p>有时候我们需要表示实现协议的类型，可以使用<code>Self</code>代替，如下</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">CompareProtocal</span> &#123;</span><br><span class="line">    <span class="comment">// Self表示实现协议自己的类型本身</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">compare</span>(<span class="params">other</span>: <span class="keyword">Self</span>) -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span>: <span class="title class_">CompareProtocal</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">compare</span>(<span class="params">other</span>: <span class="type">Product</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.id <span class="operator">==</span> other.id</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-objc协议"><a href="#5-objc协议" class="headerlink" title="5. @objc协议"></a>5. @objc协议</h3><p>swift声明的协议是不能直接被oc的代码桥接调用的，如果需要，需要在声明前加上<code>@objc</code>，使用<code>@objc</code>声明的协议不能被用于结构体和枚举</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">@objc</span> <span class="keyword">protocol</span> <span class="title class_">HasArea</span> &#123;            <span class="comment">// 协议可以被桥接到oc中使用</span></span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Double</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-Optional要求"><a href="#6-Optional要求" class="headerlink" title="6. Optional要求"></a>6. Optional要求</h3><p>在oc中的protocal可以定义可选方法，在swift默认不支持可选方法，swift只有在添加了<code>@objc</code>声明的协议才能定义可选方法，在定义前添加<code>optional</code>声明</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">@objc</span> <span class="keyword">protocol</span> <span class="title class_">HasArea</span> &#123;</span><br><span class="line">    <span class="keyword">optional</span> <span class="keyword">var</span> area: <span class="type">Double</span> &#123; <span class="keyword">get</span> &#125;     <span class="comment">// 定义可选属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="十三、错误"><a href="#十三、错误" class="headerlink" title="十三、错误"></a>十三、错误</h2><p>与其他高级语言异常处理有点类似，swift引入了错误的机制，可以在出现异常的地方抛出错误，错误对象继承自Error，抛出的错误函数会立即返回，并将错误丢给调用函数的函数处理，如果一个函数可能抛出错误，那么必须在函数定义的时候进行声明，如下</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义错误类型</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">OperationError</span>: <span class="title class_">Error</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">DivideByZero</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Other</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义可能抛出异常的函数，在函数声明的返回值前面加上throws</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">divide</span>(<span class="params">a</span>: <span class="type">Int</span>, <span class="params">b</span>: <span class="type">Int</span>) <span class="keyword">throws</span> -&gt; <span class="type">Float</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b <span class="operator">==</span> <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">OperationError</span>.<span class="type">DivideByZero</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Float</span>(a) <span class="operator">/</span> <span class="type">Float</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用可能出错的函数（调用出必须加上try）</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">try</span> divide(a: <span class="number">10</span>, b: <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">OperationError</span>.<span class="type">DivideByZero</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="comment">//其他错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果错误是一个对象，而不是枚举，可以用let绑定到变量上</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> divide(a: <span class="number">10</span>, b: <span class="number">0</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="keyword">let</span> err <span class="keyword">as</span> <span class="type">SomeErrorType</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(err.message)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;other error&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不处理错误的话可以使用<code>try?</code>，使用try?关键字的方法会被包装到一个可选类型中，如果发生错误，则会返回nil，如下面序列化的例子</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">serialize</span>(<span class="params">obj</span>: <span class="type">AnyObject</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> jsonString <span class="operator">=</span> <span class="keyword">try?</span> someSerializeFuncMayThrowError(obj) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(jsonString)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;fail&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>try?配合guard let一起使用效果更好</p>
</blockquote>
<h2 id="十四、断言"><a href="#十四、断言" class="headerlink" title="十四、断言"></a>十四、断言</h2><p>断言可以让我们在调试时候更好的发现问题，排查错误，几乎所有的高级语言都支持断言，swift也如此，断言的代码在release的时候回被忽略，不会影响发布程序的性能，只会在调试的时候生效</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果age小于0，程序会停止，并输出错误信息</span></span><br><span class="line"><span class="built_in">assert</span>(age <span class="operator">&gt;=</span> <span class="number">0</span>, <span class="string">&quot;A person&#x27;s age cannot be less than zero&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="十五、泛型"><a href="#十五、泛型" class="headerlink" title="十五、泛型"></a>十五、泛型</h2><p>关于泛型的介绍，这里不进行说明，swift的泛型是我认为最酷的特性之一，当然其他语言也有，可以让类或函数更大程度的重用，swift的泛型与其他语言的泛型有点类似</p>
<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>在类或函数声明的时候，指定一个泛型类型参数（通常为T）然后使用的时候直接把T当成类型使用</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型函数定义</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">swapTwoValues</span>&lt;<span class="type">T</span>&gt;(<span class="params">inout</span> <span class="params">a</span>: <span class="type">T</span>, <span class="params">inout</span> <span class="params">b</span>: <span class="type">T</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA <span class="operator">=</span> a</span><br><span class="line">    a <span class="operator">=</span> b</span><br><span class="line">    b <span class="operator">=</span> temporaryA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Result</span>&lt;<span class="title class_">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> code: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> errorMessage: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> data: <span class="type">T</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多个泛型类型参数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Result</span>&lt;<span class="title class_">T</span>, <span class="title class_">TK</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> code: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> errorMessage: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> data: <span class="type">T</span>?</span><br><span class="line">    <span class="keyword">var</span> subData: <span class="type">TK</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-泛型约束"><a href="#2-泛型约束" class="headerlink" title="2. 泛型约束"></a>2. 泛型约束</h3><p>我们还可以对泛型进行约束，泛型类型参数只能是某些类型的子类，或实现了某些协议</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">findIndex</span>&lt;<span class="type">T</span>&gt;(<span class="params">array</span>: [<span class="type">T</span>], <span class="params">valueToFind</span>: <span class="type">T</span>) -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.enumerate() &#123;</span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">==</span> valueToFind &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面函数会报编译错误，因为在swift里，并不是所有的类都能用<code>==</code>操作符比较，只有实现了Equatable协议的类才能用<code>==</code>操作符，修改为</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">findIndex</span>&lt;<span class="type">T</span>: <span class="type">Equatable</span>&gt;(<span class="params">array</span>: [<span class="type">T</span>], <span class="params">valueToFind</span>: <span class="type">T</span>) -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.enumerate() &#123;</span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">==</span> valueToFind &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-多泛型类型参数"><a href="#3-多泛型类型参数" class="headerlink" title="3. 多泛型类型参数"></a>3. 多泛型类型参数</h3><p>有时候我们需要用多个协议进行约束，可以使用下面方式（类与函数的使用方式类似）</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunc</span>&lt;<span class="type">T</span> : protocol&lt;<span class="type">StudyProtocal</span>, <span class="type">RunProtocal</span>&gt;<span class="operator">&gt;</span>(arg: <span class="type">T</span>) &#123;</span><br><span class="line">    <span class="comment">// do stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果约束既有类又有协议的话可以使用<code>where</code>添加限制条件</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunc</span>&lt;<span class="type">T</span>, <span class="type">TK</span> where <span class="type">T</span>:<span class="type">Student</span>, <span class="type">T</span>: <span class="type">StudyProtocal</span>&gt;(<span class="params">t</span>: <span class="type">T</span>, <span class="params">tk</span>: <span class="type">TK</span>) &#123;</span><br><span class="line">    <span class="comment">// do stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-泛型是不可变的"><a href="#4-泛型是不可变的" class="headerlink" title="4. 泛型是不可变的"></a>4. 泛型是不可变的</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dog1 <span class="operator">=</span> <span class="type">SomeClass</span>&lt;<span class="type">Parent</span>&gt;()</span><br><span class="line"><span class="keyword">var</span> dog2 <span class="operator">=</span> <span class="type">SomeClass</span>&lt;<span class="type">Son</span>&gt;()</span><br><span class="line"></span><br><span class="line">dog1 <span class="operator">=</span> dog2       <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于可变，不可变，逆变，协变参考这里：<a target="_blank" rel="noopener" href="http://swift.gg/2015/12/24/friday-qa-2015-11-20-covariance-and-contravariance/">http://swift.gg/2015/12/24/friday-qa-2015-11-20-covariance-and-contravariance/</a></p>
</blockquote>
<h3 id="5-泛型协议"><a href="#5-泛型协议" class="headerlink" title="5. 泛型协议"></a>5. 泛型协议</h3><p>swift的协议不支持泛型，不能像类一样定义泛型，而是通过类型参数定义泛型</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">GenericProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">T1</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">T2</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">someFunc</span>(<span class="params">t2</span>: <span class="type">T2</span>) -&gt; <span class="type">T1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span>&lt;<span class="title class_">T</span>&gt; : <span class="title class_">GenericProtocol</span> &#123;</span><br><span class="line">    <span class="comment">// 设置泛型类型</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">T1</span> <span class="operator">=</span> <span class="type">String</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">T2</span> <span class="operator">=</span> <span class="type">T</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">someFunc</span>(<span class="params">t2</span>: <span class="type">T2</span>) -&gt; <span class="type">T1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十六、运算符重载"><a href="#十六、运算符重载" class="headerlink" title="十六、运算符重载"></a>十六、运算符重载</h2><p>与其他高级语言的一样，swift也提供了运算符重载的功能，我们可以自定义运算符的实现，运算符通常分为三种类型</p>
<ul>
<li>单目运算符：<code>&lt;运算符&gt;&lt;操作数&gt;</code>或<code>&lt;操作数&gt;&lt;运算符&gt;</code>，如<code>!a</code></li>
<li>双目运算符：<code>&lt;操作数&gt;&lt;运算符&gt;&lt;操作数&gt;</code>，如：<code>1 + 1</code></li>
<li>三元运算符：<code>&lt;操作数&gt;&lt;运算符&gt;&lt;操作数&gt;&lt;运算符&gt;&lt;操作数&gt;</code>，如：<code>a ? b : c</code></li>
</ul>
<p>swift的运算符重载</p>
<ul>
<li>支持自定义运算符<code>/</code>, <code>=</code>, <code>-</code>, <code>+</code>, <code>*</code>, <code>%</code>, <code>&lt;</code>, <code>&gt;</code>, <code>!</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>.</code>, <code>~</code>的任意组合。可以脑洞大开创造颜文字。</li>
<li>不能对默认的赋值运算符<code>=</code>进行重载。组合赋值运算符可以被重载，如<code>==</code>，<code>!==!</code></li>
<li>无法对三元运算符<code>a ? b : c</code>进行重载</li>
<li>运算符声明和定义只能定义在全局作用域，不能定义在类&#x2F;结构体&#x2F;枚举内</li>
<li></li>
</ul>
<h3 id="1-前缀，中缀，后缀运算符"><a href="#1-前缀，中缀，后缀运算符" class="headerlink" title="1. 前缀，中缀，后缀运算符"></a>1. 前缀，中缀，后缀运算符</h3><ul>
<li>前缀<code>prefix</code>：默认的有-，!，~等</li>
<li>中缀<code>infix</code>：默认的有+，*，&#x3D;&#x3D;等</li>
<li>后缀<code>postfix</code>：默认的有：++，–等</li>
</ul>
<h3 id="1-1-声明运算符"><a href="#1-1-声明运算符" class="headerlink" title="1.1 声明运算符"></a>1.1 声明运算符</h3><p>如果实现不存在的运算符需要添加运算符声明（系统的提供的，可以不需要声明），声明必须放在全局作用域</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前缀运算符</span></span><br><span class="line"><span class="keyword">prefix</span> <span class="keyword">operator</span> <span class="title">+++</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中缀运算符（二元运算符）</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">+++</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后缀运算符</span></span><br><span class="line"><span class="keyword">postfix</span> <span class="keyword">operator</span> <span class="title">+++</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-实现上面三个运算符"><a href="#1-2-实现上面三个运算符" class="headerlink" title="1.2 实现上面三个运算符"></a>1.2 实现上面三个运算符</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义Point结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> y: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载操作符要放在全局作用域</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">+++</span> (<span class="params">left</span>: <span class="type">Point</span>, <span class="params">right</span>: <span class="type">Point</span>) -&gt; <span class="type">Point</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Point</span>(x: left.x <span class="operator">+</span> right.x, y: left.y <span class="operator">+</span> right.y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要修改操作数，需要添加inout关键字</span></span><br><span class="line"><span class="keyword">prefix</span> <span class="keyword">func</span> <span class="title function_">+++</span> (<span class="params">inout</span> <span class="params">left</span>: <span class="type">Point</span>) &#123;</span><br><span class="line">    left.x <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    left.y <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">postfix</span> <span class="keyword">func</span> <span class="title function_">---</span> (<span class="params">right</span>: <span class="type">Point</span>) -&gt; <span class="type">Point</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Point</span>(x: right.x <span class="operator">-</span> <span class="number">1</span>, y: right.y <span class="operator">-</span> <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-使用"><a href="#1-3-使用" class="headerlink" title="1.3 使用"></a>1.3 使用</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">12</span>, y: <span class="number">21</span>)</span><br><span class="line"><span class="keyword">var</span> p2 <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">12</span>, y: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 <span class="operator">=</span> p1<span class="operator">+++</span>p2            <span class="comment">// p3.x = 24, p3.y = 23</span></span><br><span class="line"><span class="operator">+++</span>p1                       <span class="comment">// p1.x = 13, p1.y = 3</span></span><br><span class="line">p1<span class="operator">---</span>                       <span class="comment">// p1.x = 12, p1.y = 2</span></span><br></pre></td></tr></table></figure>

<h3 id="2-优先级"><a href="#2-优先级" class="headerlink" title="2. 优先级"></a>2. 优先级</h3><p>这个很好理解，就是优先级高的运算符先执行，声明运算符的时候可以指明优先级</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">^</span> &#123;</span><br><span class="line">    associativity left        <span class="comment">// 结合性，后面说</span></span><br><span class="line">    precedence <span class="number">140</span>            <span class="comment">// 指定运算符优先级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://developer.apple.com/reference/swift/1851035-swift_standard_library_operators">这里</a>可以查看默认运算符的优先级</p>
<h3 id="3-结合性"><a href="#3-结合性" class="headerlink" title="3. 结合性"></a>3. 结合性</h3><p>运算符还可以定义结合性，对于双目运算符，当优先级一样的时候，可以定义运算符优先进行左结合还是右结合，运算符的结合性有下面三种</p>
<ul>
<li>left：左结合</li>
<li>right：右结合</li>
<li>none：无</li>
</ul>
<p>结合性设置为<code>left</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个双目操作符</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">^</span> &#123;</span><br><span class="line">    associativity left         <span class="comment">// 结合性</span></span><br><span class="line">    precedence <span class="number">140</span>             <span class="comment">// 指定运算符优先级</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">^</span> (<span class="params">left</span>: <span class="type">Int</span>, <span class="params">right</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Int</span>(pow(<span class="type">Double</span>(left), <span class="type">Double</span>(right)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a <span class="operator">=</span> <span class="number">2</span> <span class="operator">^</span> <span class="number">2</span> <span class="operator">^</span> <span class="number">2</span> <span class="operator">^</span> <span class="number">2</span>           <span class="comment">// 执行结果为256</span></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">let</span> aa <span class="operator">=</span> ((<span class="number">2</span> <span class="operator">^</span> <span class="number">2</span>) <span class="operator">^</span> <span class="number">2</span>) <span class="operator">^</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>如果我们设置结合性为<code>right</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个双目操作符</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">^</span> &#123;</span><br><span class="line">    associativity right         <span class="comment">// 结合性</span></span><br><span class="line">    precedence <span class="number">140</span>              <span class="comment">// 指定运算符优先级</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">^</span> (<span class="params">left</span>: <span class="type">Int</span>, <span class="params">right</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Int</span>(pow(<span class="type">Double</span>(left), <span class="type">Double</span>(right)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a <span class="operator">=</span> <span class="number">2</span> <span class="operator">^</span> <span class="number">2</span> <span class="operator">^</span> <span class="number">2</span> <span class="operator">^</span> <span class="number">2</span>           <span class="comment">// 执行结果为65536</span></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">let</span> aa <span class="operator">=</span> <span class="number">2</span> <span class="operator">^</span> (<span class="number">2</span> <span class="operator">^</span> (<span class="number">2</span> <span class="operator">^</span> <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>如果结合性设置为<code>none</code>，则会报错，无法判断</p>
<h2 id="十七、命名空间"><a href="#十七、命名空间" class="headerlink" title="十七、命名空间"></a>十七、命名空间</h2><p>在很多语言里面，都有命名空间的概念，可以分离代码，防止命名冲突，而swift也有类似命名空间的概念，通过访问级别实现命名空间<br>&#x2F;&#x2F;TODO</p>
<h2 id="十八、参考链接"><a href="#十八、参考链接" class="headerlink" title="十八、参考链接"></a>十八、参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Operator_associativity#Right-associativity_of_assignment_operators">运算符结合性</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/Swift_Programming_Language/AdvancedOperators.html">Swift高级运算符</a></li>
</ul>
<h2 id="十九、总结"><a href="#十九、总结" class="headerlink" title="十九、总结"></a>十九、总结</h2><p>总的来说，swift还是比较装逼的，整个很多新名词，新概念，例如，指定构造器，便利构造器，构造器代理，但其实这些东西在别的语言基本上有，没那么复杂，另外swift的关键字太多了，有些可有可无，是不是苹果看到什么好的就想往swift里面塞还是怎么着，另外感觉苹果还是太装逼了，例如do-while非要偏偏要搞成repeat-while啥的，个人感觉编程语言应该是轻便，简单，当然，并且能满足所有需求的，反正，没什么特别的好感</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Author
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://zhengbomo.github.io/2016-06-28/swift-start/" title="swift学习笔记">http://zhengbomo.github.io/2016-06-28/swift-start/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/swift/" rel="tag"># swift</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2016-06-28/Python-tip/" rel="prev" title="《编写高质量代码 改善Python程序的91个建议》学习笔记">
      <i class="fa fa-chevron-left"></i> 《编写高质量代码 改善Python程序的91个建议》学习笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2016-07-07/swift-constructor/" rel="next" title="swift构造器总结">
      swift构造器总结 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">一、基础语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">二、数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TODO%EF%BC%9AAny-AnyObject"><span class="nav-number">2.1.</span> <span class="nav-text">TODO：Any, AnyObject,</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F"><span class="nav-number">3.</span> <span class="nav-text">三、常量变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8"><span class="nav-number">3.1.</span> <span class="nav-text">类型标注</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%BA%8F%E5%88%97%E5%92%8C%E9%9B%86%E5%90%88"><span class="nav-number">4.</span> <span class="nav-text">四、序列和集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%95%B0%E7%BB%84Array"><span class="nav-number">4.1.</span> <span class="nav-text">1. 数组Array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AD%97%E5%85%B8Dictionary"><span class="nav-number">4.2.</span> <span class="nav-text">2. 字典Dictionary</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Set"><span class="nav-number">4.3.</span> <span class="nav-text">3. Set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%85%83%E7%BB%84Tuple"><span class="nav-number">4.4.</span> <span class="nav-text">4. 元组Tuple</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%AD%97%E7%AC%A6%E4%B8%B2String"><span class="nav-number">4.5.</span> <span class="nav-text">5. 字符串String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E9%9B%86%E5%90%88%E7%9A%84%E8%B5%8B%E5%80%BC%E5%92%8C%E6%8B%B7%E8%B4%9D%E8%A1%8C%E4%B8%BA"><span class="nav-number">4.6.</span> <span class="nav-text">6. 集合的赋值和拷贝行为</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%8F%AF%E9%80%89%E7%B1%BB%E5%9E%8B%EF%BC%88%E5%8F%AF%E7%A9%BA%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="nav-number">5.</span> <span class="nav-text">五、可选类型（可空类型）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%A3%B0%E6%98%8E"><span class="nav-number">5.1.</span> <span class="nav-text">1. 声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%BC%BA%E5%88%B6%E8%A7%A3%E6%9E%90"><span class="nav-number">5.2.</span> <span class="nav-text">2. 强制解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%8F%AF%E9%80%89%E7%BB%91%E5%AE%9A"><span class="nav-number">5.3.</span> <span class="nav-text">3. 可选绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E9%9A%90%E5%BC%8F%E8%A7%A3%E6%9E%90"><span class="nav-number">5.4.</span> <span class="nav-text">4. 隐式解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%8F%AF%E9%80%89%E7%B1%BB%E5%9E%8B%E8%87%AA%E5%88%A4%E6%96%AD%E9%93%BE%E6%8E%A5"><span class="nav-number">5.5.</span> <span class="nav-text">5. 可选类型自判断链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%8F%AF%E9%80%89%E5%85%B3%E8%81%94%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.6.</span> <span class="nav-text">6. 可选关联运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">6.</span> <span class="nav-text">六、运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">7.</span> <span class="nav-text">七、流程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#guard-else"><span class="nav-number">7.1.</span> <span class="nav-text">guard-else</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#switch-case"><span class="nav-number">7.2.</span> <span class="nav-text">switch-case</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A6%E6%A0%87%E7%AD%BE%E7%9A%84%E8%AF%AD%E5%8F%A5"><span class="nav-number">7.3.</span> <span class="nav-text">带标签的语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E5%87%BD%E6%95%B0"><span class="nav-number">8.</span> <span class="nav-text">八、函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E5%BD%A2%E5%BC%8F"><span class="nav-number">8.1.</span> <span class="nav-text">1. 基本形式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="nav-number">8.2.</span> <span class="nav-text">2. 可变参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%A4%96%E9%83%A8%E5%8F%82%E6%95%B0%E5%90%8D"><span class="nav-number">8.3.</span> <span class="nav-text">3. 外部参数名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-number">8.4.</span> <span class="nav-text">4. 函数默认值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E9%97%AD%E5%8C%85"><span class="nav-number">8.5.</span> <span class="nav-text">5. 闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Trailing-%E5%B0%BE%E8%A1%8C-%E9%97%AD%E5%8C%85"><span class="nav-number">8.6.</span> <span class="nav-text">6. Trailing(尾行)闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-Escaping%EF%BC%88%E9%80%83%E9%80%B8%EF%BC%89%E9%97%AD%E5%8C%85"><span class="nav-number">8.7.</span> <span class="nav-text">7. Escaping（逃逸）闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E8%87%AA%E5%8A%A8%E9%97%AD%E5%8C%85"><span class="nav-number">8.8.</span> <span class="nav-text">8. 自动闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E5%B8%B8%E9%87%8F%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%98%E9%87%8F%E5%8F%82%E6%95%B0"><span class="nav-number">8.9.</span> <span class="nav-text">9. 常量参数和变量参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%8F%82%E6%95%B0"><span class="nav-number">8.10.</span> <span class="nav-text">10. 输入输出参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0"><span class="nav-number">8.11.</span> <span class="nav-text">11. 嵌套函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-defer"><span class="nav-number">8.12.</span> <span class="nav-text">12. defer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E6%9E%9A%E4%B8%BE"><span class="nav-number">9.</span> <span class="nav-text">九、枚举</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%A3%B0%E6%98%8E%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-number">9.1.</span> <span class="nav-text">1. 声明和使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%B5%8C%E5%A5%97%E6%9E%9A%E4%B8%BE"><span class="nav-number">9.2.</span> <span class="nav-text">2. 嵌套枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E9%80%92%E5%BD%92%E6%9E%9A%E4%B8%BE"><span class="nav-number">9.3.</span> <span class="nav-text">3. 递归枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%8E%9F%E5%A7%8B%E5%80%BC"><span class="nav-number">9.4.</span> <span class="nav-text">4. 原始值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%85%B3%E8%81%94%E5%80%BC"><span class="nav-number">9.5.</span> <span class="nav-text">5. 关联值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E3%80%81%E7%B1%BB%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">10.</span> <span class="nav-text">十、类与结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%8C%E7%B1%BB%E5%AE%9A%E4%B9%89"><span class="nav-number">10.1.</span> <span class="nav-text">1. 结构体，类定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%EF%BC%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">10.2.</span> <span class="nav-text">2. 静态属性，静态方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%9E%84%E9%80%A0%E5%99%A8%E5%92%8C%E6%9E%90%E6%9E%84%E5%99%A8"><span class="nav-number">10.3.</span> <span class="nav-text">3. 构造器和析构器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD"><span class="nav-number">10.4.</span> <span class="nav-text">4. 类型判断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="nav-number">10.5.</span> <span class="nav-text">5. 弱引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E8%AE%BF%E9%97%AE%E7%BA%A7%E5%88%AB"><span class="nav-number">10.6.</span> <span class="nav-text">6. 访问级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E5%B1%9E%E6%80%A7"><span class="nav-number">10.7.</span> <span class="nav-text">7. 属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E7%BB%A7%E6%89%BF"><span class="nav-number">10.8.</span> <span class="nav-text">8. 继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E9%99%84%E5%B1%9E%E8%84%9A%E6%9C%ACsubscript"><span class="nav-number">10.9.</span> <span class="nav-text">9. 附属脚本subscript</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E7%B1%BB%E5%9E%8B%E5%B5%8C%E5%A5%97"><span class="nav-number">10.10.</span> <span class="nav-text">10. 类型嵌套</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="nav-number">10.11.</span> <span class="nav-text">11. 类型别名</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E6%89%A9%E5%B1%95Extension"><span class="nav-number">11.</span> <span class="nav-text">十一、扩展Extension</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E5%B1%9E%E6%80%A7"><span class="nav-number">11.1.</span> <span class="nav-text">扩展属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E5%8D%8F%E8%AE%AEProtocal"><span class="nav-number">12.</span> <span class="nav-text">十二、协议Protocal</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-mutating"><span class="nav-number">12.1.</span> <span class="nav-text">1. mutating</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%8D%8F%E8%AE%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">12.2.</span> <span class="nav-text">2. 协议类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%8D%8F%E8%AE%AE%E7%BB%84%E5%90%88"><span class="nav-number">12.3.</span> <span class="nav-text">3. 协议组合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E8%87%AA%E8%BA%AB%E7%B1%BB%E5%9E%8B"><span class="nav-number">12.4.</span> <span class="nav-text">4. 自身类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-objc%E5%8D%8F%E8%AE%AE"><span class="nav-number">12.5.</span> <span class="nav-text">5. @objc协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Optional%E8%A6%81%E6%B1%82"><span class="nav-number">12.6.</span> <span class="nav-text">6. Optional要求</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%B8%89%E3%80%81%E9%94%99%E8%AF%AF"><span class="nav-number">13.</span> <span class="nav-text">十三、错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81%E6%96%AD%E8%A8%80"><span class="nav-number">14.</span> <span class="nav-text">十四、断言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%BA%94%E3%80%81%E6%B3%9B%E5%9E%8B"><span class="nav-number">15.</span> <span class="nav-text">十五、泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="nav-number">15.1.</span> <span class="nav-text">1. 定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="nav-number">15.2.</span> <span class="nav-text">2. 泛型约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%A4%9A%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="nav-number">15.3.</span> <span class="nav-text">3. 多泛型类型参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%B3%9B%E5%9E%8B%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84"><span class="nav-number">15.4.</span> <span class="nav-text">4. 泛型是不可变的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%B3%9B%E5%9E%8B%E5%8D%8F%E8%AE%AE"><span class="nav-number">15.5.</span> <span class="nav-text">5. 泛型协议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E5%85%AD%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">16.</span> <span class="nav-text">十六、运算符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%89%8D%E7%BC%80%EF%BC%8C%E4%B8%AD%E7%BC%80%EF%BC%8C%E5%90%8E%E7%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">16.1.</span> <span class="nav-text">1. 前缀，中缀，后缀运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%A3%B0%E6%98%8E%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">16.2.</span> <span class="nav-text">1.1 声明运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%AE%9E%E7%8E%B0%E4%B8%8A%E9%9D%A2%E4%B8%89%E4%B8%AA%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">16.3.</span> <span class="nav-text">1.2 实现上面三个运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E4%BD%BF%E7%94%A8"><span class="nav-number">16.4.</span> <span class="nav-text">1.3 使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">16.5.</span> <span class="nav-text">2. 优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%BB%93%E5%90%88%E6%80%A7"><span class="nav-number">16.6.</span> <span class="nav-text">3. 结合性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%B8%83%E3%80%81%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">17.</span> <span class="nav-text">十七、命名空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E5%85%AB%E3%80%81%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="nav-number">18.</span> <span class="nav-text">十八、参考链接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%B9%9D%E3%80%81%E6%80%BB%E7%BB%93"><span class="nav-number">19.</span> <span class="nav-text">十九、总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Author"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Author</p>
  <div class="site-description" itemprop="description">懒人</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">99</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhengbomo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhengbomo" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhengbomo@hotmail.com" title="Email → mailto:zhengbomo@hotmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>Email</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/intent/user?user_id=371531868" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;intent&#x2F;user?user_id&#x3D;371531868" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://facebook.com/zhengbomo" title="Facebook → http:&#x2F;&#x2F;facebook.com&#x2F;zhengbomo" rel="noopener" target="_blank"><i class="fab fa-facebook fa-fw"></i>Facebook</a>
      </span>
      <span class="links-of-author-item">
        <a href="tencent://message/?uin=449179249&Site=&Menu=yes" title="QQ → tencent:&#x2F;&#x2F;message&#x2F;?uin&#x3D;449179249&amp;Site&#x3D;&amp;Menu&#x3D;yes" rel="noopener" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/1891587992" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;1891587992" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bomo</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
